<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CE306 - Instrumentação Matemática para Estatística - 3&nbsp; Métodos numéricos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../content/Modulo04/index.html" rel="next">
<link href="../../content/Modulo02/index.html" rel="prev">
<link href="../../default_overview_image.jpg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../custom.css">
<meta property="og:title" content="CE306 - Instrumentação Matemática para Estatística - 3&nbsp; Métodos numéricos">
<meta property="og:description" content="Material da disciplina CE306 - Instrumentação Matemática para Estatística do curso de Estatística da Universidade Federal do Paraná (UFPR).">
<meta property="og:image" content="default_overview_image.jpg">
<meta property="og:site_name" content="CE306 - Instrumentação Matemática para Estatística">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../content/Modulo03/index.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos numéricos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">CE306 - Instrumentação Matemática para Estatística</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://raymz1990.github.io/CE313/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-git"></i></a>
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="../../CE306---Instrumentação-Matemática-para-Estatística.pdf">
              <i class="bi bi-bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="../../CE306---Instrumentação-Matemática-para-Estatística.docx">
              <i class="bi bi-bi-file-word pe-1"></i>
            Download Docx
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Apresentação</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefácio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo01/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Cálculo Diferencial e Integral</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo02/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Álgebra Matricial</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo03/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos numéricos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo04/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Função de Distribuição Empírica</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Exercicios</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo01/Exercicios/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Cálculo Diferencial e Integral para Cientista de Dados</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo02/Exercicios/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algebra Matricial</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo03/Exercicios/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Métodos numéricos</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sistemas-de-equações-não-lineares" id="toc-sistemas-de-equações-não-lineares" class="nav-link active" data-scroll-target="#sistemas-de-equações-não-lineares"><span class="header-section-number">3.1</span> Sistemas de equações não-lineares</a>
  <ul class="collapse">
  <li><a href="#método-da-bisseção" id="toc-método-da-bisseção" class="nav-link" data-scroll-target="#método-da-bisseção"><span class="header-section-number">3.1.1</span> Método da bisseção</a></li>
  <li><a href="#método-regula-falsi" id="toc-método-regula-falsi" class="nav-link" data-scroll-target="#método-regula-falsi"><span class="header-section-number">3.1.2</span> Método regula-falsi</a></li>
  <li><a href="#método-de-newton" id="toc-método-de-newton" class="nav-link" data-scroll-target="#método-de-newton"><span class="header-section-number">3.1.3</span> Método de Newton</a></li>
  <li><a href="#método-do-gradiente-descendente" id="toc-método-do-gradiente-descendente" class="nav-link" data-scroll-target="#método-do-gradiente-descendente"><span class="header-section-number">3.1.4</span> Método do gradiente descendente</a></li>
  </ul></li>
  <li><a href="#diferenciação-numérica" id="toc-diferenciação-numérica" class="nav-link" data-scroll-target="#diferenciação-numérica"><span class="header-section-number">3.2</span> Diferenciação numérica</a></li>
  <li><a href="#integração-numérica" id="toc-integração-numérica" class="nav-link" data-scroll-target="#integração-numérica"><span class="header-section-number">3.3</span> Integração numérica</a>
  <ul class="collapse">
  <li><a href="#método-trapezoidal" id="toc-método-trapezoidal" class="nav-link" data-scroll-target="#método-trapezoidal"><span class="header-section-number">3.3.1</span> Método Trapezoidal</a></li>
  <li><a href="#método-de-simpson-13" id="toc-método-de-simpson-13" class="nav-link" data-scroll-target="#método-de-simpson-13"><span class="header-section-number">3.3.2</span> Método de Simpson <span class="math inline">\(1/3\)</span></a></li>
  <li><a href="#quadratura-gaussiana" id="toc-quadratura-gaussiana" class="nav-link" data-scroll-target="#quadratura-gaussiana"><span class="header-section-number">3.3.3</span> Quadratura Gaussiana</a></li>
  <li><a href="#quadratura-de-gauss-hermite-adaptativa" id="toc-quadratura-de-gauss-hermite-adaptativa" class="nav-link" data-scroll-target="#quadratura-de-gauss-hermite-adaptativa"><span class="header-section-number">3.3.4</span> Quadratura de Gauss-Hermite adaptativa</a></li>
  <li><a href="#aproximação-de-laplace" id="toc-aproximação-de-laplace" class="nav-link" data-scroll-target="#aproximação-de-laplace"><span class="header-section-number">3.3.5</span> Aproximação de Laplace</a></li>
  <li><a href="#método-de-monte-carlo" id="toc-método-de-monte-carlo" class="nav-link" data-scroll-target="#método-de-monte-carlo"><span class="header-section-number">3.3.6</span> Método de Monte Carlo</a></li>
  <li><a href="#função-do-r-para-integração-numérica" id="toc-função-do-r-para-integração-numérica" class="nav-link" data-scroll-target="#função-do-r-para-integração-numérica"><span class="header-section-number">3.3.7</span> Função do <code>R</code> para integração numérica</a></li>
  </ul></li>
  <li><a href="#otimização" id="toc-otimização" class="nav-link" data-scroll-target="#otimização"><span class="header-section-number">3.4</span> Otimização</a>
  <ul class="collapse">
  <li><a href="#programação-linear" id="toc-programação-linear" class="nav-link" data-scroll-target="#programação-linear"><span class="header-section-number">3.4.1</span> Programação linear</a></li>
  <li><a href="#programação-quadrática" id="toc-programação-quadrática" class="nav-link" data-scroll-target="#programação-quadrática"><span class="header-section-number">3.4.2</span> Programação quadrática</a></li>
  <li><a href="#programação-não-linear" id="toc-programação-não-linear" class="nav-link" data-scroll-target="#programação-não-linear"><span class="header-section-number">3.4.3</span> Programação não-linear</a></li>
  </ul></li>
  <li><a href="#referências-bibliográficas" id="toc-referências-bibliográficas" class="nav-link" data-scroll-target="#referências-bibliográficas"><span class="header-section-number">3.5</span> Referências bibliográficas</a></li>
  <li><a href="#exercícios" id="toc-exercícios" class="nav-link" data-scroll-target="#exercícios"><span class="header-section-number">3.6</span> Exercícios</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://raymz1990.github.io/CE313/edit/main/book/content/Modulo03/index.qmd" class="toc-action"><i class="bi bi-git"></i>Edit this page</a></li><li><a href="https://raymz1990.github.io/CE313/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos numéricos</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Neste capítulo serão apresentados os principais métodos numéricos com aplicações importantes em ciência de dados. Vamos começar discutindo a solução de sistemas de equações não-lineares. Neste contexto surge um dos métodos numéricos mais famosos em aprendizagem de máquina: o <strong>método do gradiente descendente</strong>. Também será apresentado o método de <strong>Newton-Raphson</strong>, que é uma espécie de refinamento do gradiente descendente. Na sequência discutiremos métodos numéricos para a obtenção de aproximações para derivadas e integrais. Por fim, serão apresentados de forma breve os métodos de otimização linear e não-linear.</p>
<section id="sistemas-de-equações-não-lineares" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sistemas-de-equações-não-lineares"><span class="header-section-number">3.1</span> Sistemas de equações não-lineares</h2>
<p>Na seção 2.3 discutimos a solução de sistemas de equações lineares. Nesta seção estendemos a discussão para sistemas de equações não-lineares. Vamos começar a discussão com apenas uma equação da forma <span class="math inline">\(f(x) = 0\)</span>, onde <span class="math inline">\(f(x)\)</span> é alguma função não-linear de <span class="math inline">\(x\)</span>. Neste tipo de equação nem sempre é possível obter uma solução em forma fechada, ou seja, expressar a solução como uma simples equação envolvendo <span class="math inline">\(x\)</span> como foi possível para equações lineares. Neste caso, a <strong>solução</strong> ou <strong>raiz</strong> é um valor numérico de <span class="math inline">\(x\)</span> que satisfaz a equação de forma aproximada. A Figura 3.1 apresenta algumas situações possíveis quando resolvendo uma equação não-linear.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/naolinear-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: Situações que podem ocorrer quando resolvendo uma equação não-linear.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Como ilustrado na Figura 3.1 a equação pode não ter solução, ou seja, a função nunca toca o eixo horizontal. Outra possibilidade é ter apenas uma solução ou mesmo ter várias soluções. Em geral, nas técnicas mais simples de ciência de dados, o modelo é construído de tal forma que seu treinamento ou estimação é o resultado da solução de um sistema de equações não-lineares. Além disso, tal sistema é construído para ter apenas uma solução. Porém, em técnicas mais avançadas como redes neurais e suas extensões como <em>deep learning</em> o sistema de equações não-lineares gerado apresenta diversas soluções. Neste livro será dado mais atenção a situações onde a equação tem apenas uma solução.</p>
<p>Como dito, existem diversas situações em que obter uma solução analítica não é possível. Por exemplo, a equação não-linear <span class="math inline">\(8 - 4.5(x - \sin(x)) = 0\)</span> não tem solução analítica. Neste tipo de situação podemos recorrer a métodos numéricos para resolver a equação de forma aproximada. Métodos numéricos para resolver equações não-lineares são divididos em dois grupos:</p>
<ol type="i">
<li>métodos de confinamento; e</li>
<li>métodos abertos.</li>
</ol>
<p>Nos métodos de confinamento primeiro identifica-se um intervalo que possui a solução, na sequência usando algum esquema numérico, o tamanho do intervalo é reduzido sucessivamente até que a precisão desejada seja atingida. A Figura 3.2 ilustra a ideia dos métodos de confinamento.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/ideiaconfinamento-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.2: Ideia dos métodos de confinamento.
</figcaption>
</figure>
</div>
</div>
</div>
<p>O objetivo é a cada passo diminuir a amplitude do intervalo que contém a solução até que o intervalo seja tão pequeno quanto necessário dado um certo nível de precisão. Diferentes estratégias para reduzir o tamanho do intervalo dão origem aos diferentes métodos numéricos. Neste livro nós vamos apresentar os métodos da bisseção e regula-falsi.</p>
<p>Por outro lado, nos métodos abertos assume-se que uma solução inicial próxima a solução esteja disponível. A partir da solução inicial usando um esquema numérico a solução é melhorada até que o nível de precisão desejado seja atingido. A Figura 3.3 ilustra a ideia por trás dos métodos abertos.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/ideiaaberto-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.3: Ideia dos métodos de confinamento.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Na Figura 3.3, o ponto vermelho representa a solução inicial que é melhorada passo-a-passo na direção da solução ótima. Novamente existem diversas estratégias para melhorar uma solução inicial e cada uma destas estratégias leva a um método numérico para solução da equação não-linear. Neste livro serão apresentados os métodos do gradiente descendente e o método de Newton.</p>
<p>Seja usando métodos de confinamento ou métodos diretos as soluções numéricas não são exatas. Portanto é necessário ter critérios para determinar se uma solução é suficientemente precisa. Seja <span class="math inline">\(x_{ts}\)</span> a solução verdadeira e <span class="math inline">\(x_{ns}\)</span> uma solução numérica.</p>
<p>Quatro critérios são comumente usados na literatura:</p>
<ol type="1">
<li>Erro real <span class="math inline">\(x_{ts} - x_{ns}\)</span>.</li>
<li>Tolerância em <span class="math inline">\(f(x)\)</span> <span class="math display">\[| f(x_{ts}) - f(x_{ns}) | = |0 - \epsilon| = |\epsilon|.\]</span></li>
<li>Tolerância na solução: tolerância máxima da qual a solução numérica pode desviar da solução verdadeira. Útil em geral quando métodos de confinamento são usados <span class="math display">\[\left | \frac{b - a}{2} \right |.\]</span></li>
<li>Erro relativo estimado: <span class="math display">\[\left | \frac{x_{ns}^{n} - x_{ns}^{n-1}}{x_{ns}^{n-1}} \right |.\]</span></li>
</ol>
<p>O uso de cada critério depende do método numérico sendo usado e vamos discutir em cada método qual ou quais critérios são mais adequados.</p>
<section id="método-da-bisseção" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="método-da-bisseção"><span class="header-section-number">3.1.1</span> Método da bisseção</h3>
<p>O método da bisseção é um método de confinamento. Neste caso, sabe-se que dentro de um intervalo <span class="math inline">\([a,b]\)</span>, <span class="math inline">\(f(x)\)</span> é contínua e possui uma solução. Sendo assim, <span class="math inline">\(f(x)\)</span> tem sinais opostos nos pontos finais do intervalo, conforme ilustrado na Figura 3.4.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/bissecao-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.4: Ilustração do método da bisseção.
</figcaption>
</figure>
</div>
</div>
</div>
<p>O algoritmo do método da bisseção é muito simples e consiste nos seguintes passos:</p>
<ol type="1">
<li>Encontre <span class="math inline">\([a,b]\)</span>, tal que <span class="math inline">\(f(a)f(b) &lt; 0\)</span>.</li>
<li>Calcule a primeira estimativa <span class="math inline">\(x_{ns}^{(1)}\)</span> usando <span class="math inline">\(x_{ns}^{(1)} = \frac{a+b}{2}\)</span>.</li>
<li>Determine se a solução exata está entre <span class="math inline">\(a\)</span> e <span class="math inline">\(x_{ns}^{(1)}\)</span> ou entre <span class="math inline">\(x_{ns}^{(1)}\)</span> e <span class="math inline">\(b\)</span>. Isso é feito verificando o sinal do produto <span class="math inline">\(f(a) f(x_{ns}^{(1)})\)</span>:</li>
</ol>
<ul>
<li>Se <span class="math inline">\(f(a) f(x_{ns}^{(1)}) &lt; 0\)</span>, a solução está entre <span class="math inline">\(a\)</span> e <span class="math inline">\(x_{ns}^{(1)}\)</span>.</li>
<li>Se <span class="math inline">\(f(a) f(x_{ns}^{(1)}) &gt; 0\)</span>, a solução está entre <span class="math inline">\(x_{ns}^{(1)}\)</span> e <span class="math inline">\(b\)</span>.</li>
</ul>
<ol start="4" type="1">
<li>Selecione o subintervalo que contém a solução e volte ao passo 2.</li>
<li>Repita os passos 2 a 4 até que a tolerância especificada seja satisfeita.</li>
</ol>
<p>O Código 3.1 implementa o algoritmo do método da bisseção em <code>R</code>.</p>
<p><strong>Código 3.1</strong> Método da bisseção.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>bissecao <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, a, b, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">100</span>) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fa <span class="ot">&lt;-</span> <span class="fu">fx</span>(a);  fb <span class="ot">&lt;-</span> <span class="fu">fx</span>(b)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(fa<span class="sc">*</span>fb <span class="sc">&gt;</span> <span class="dv">0</span>) <span class="fu">stop</span>(<span class="st">"Solução não está no intervalo"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">c</span>() </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  sol <span class="ot">&lt;-</span> (a <span class="sc">+</span> b)<span class="sc">/</span><span class="dv">2</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>] <span class="ot">&lt;-</span> sol</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  limites <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> max_iter)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    test <span class="ot">&lt;-</span> <span class="fu">fx</span>(a)<span class="sc">*</span><span class="fu">fx</span>(sol)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(test <span class="sc">&lt;</span> <span class="dv">0</span>) { </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> (a <span class="sc">+</span> sol)<span class="sc">/</span><span class="dv">2</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> sol</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(test <span class="sc">&gt;</span> <span class="dv">0</span>) { </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> (b <span class="sc">+</span> sol)<span class="sc">/</span><span class="dv">2</span> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">=</span> sol</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">abs</span>( (b<span class="sc">-</span>a)<span class="sc">/</span><span class="dv">2</span>) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    sol <span class="ot">=</span> solucao[i<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    limites[i,] <span class="ot">&lt;-</span> <span class="fu">c</span>(a,b)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Tentativas"</span> <span class="ot">=</span> solucao, <span class="st">"Limites"</span> <span class="ot">=</span> limites, <span class="st">"Raiz"</span> <span class="ot">=</span> solucao[i<span class="sc">+</span><span class="dv">1</span>])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso do método da bisseção vamos resolver a seguinte equação não-linear <span class="math inline">\(f(x) = -\ln(x) - 1 = 0\)</span>. Apesar de ser uma equação não-linear é possível resolvê-la de forma analítica e a solução é <span class="math inline">\(\exp(-1)\)</span>. A ideia é poder comparar a solução numérica com a analítica neste simples exemplo.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implementando a função</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="sc">-</span><span class="fu">log</span>(x) <span class="sc">-</span> <span class="dv">1</span>}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Resolvendo numericamente</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>resul <span class="ot">&lt;-</span> <span class="fu">bissecao</span>(<span class="at">fx =</span> fx, <span class="at">a =</span> <span class="fl">0.1</span>, <span class="at">b =</span> <span class="dv">1</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Tentativas</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0.5500000 0.3250000 0.4375000 0.3812500 0.3531250 0.3671875 0.3742187
 [8] 0.3707031 0.3689453 0.3680664 0.3676270 0.3678467 0.3679565 0.3679016</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Limites[<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>           [,1]      [,2]
 [1,] 0.1000000 0.5500000
 [2,] 0.3250000 0.5500000
 [3,] 0.3250000 0.4375000
 [4,] 0.3250000 0.3812500
 [5,] 0.3531250 0.3812500
 [6,] 0.3671875 0.3812500
 [7,] 0.3671875 0.3742187
 [8,] 0.3671875 0.3707031
 [9,] 0.3671875 0.3689453
[10,] 0.3671875 0.3680664
[11,] 0.3676270 0.3680664
[12,] 0.3678467 0.3680664</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Raiz <span class="co"># Solução aproximada</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3679016</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">exp</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="co"># Solução exata</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3678794</code></pre>
</div>
</div>
<p>O método da bisseção forneceu uma aproximação bastante razoável para a solução da equação. É possível ver claramente que os intervalos foram se estreitando até que a precisão especificada, neste caso <span class="math inline">\(1e^{-4}\)</span> foi atingida.</p>
</section>
<section id="método-regula-falsi" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="método-regula-falsi"><span class="header-section-number">3.1.2</span> Método regula-falsi</h3>
<p>O método regula-falsi é também um método de confinamento. Assume-se que a solução está em um certo intervalo <span class="math inline">\([a,b]\)</span> em que <span class="math inline">\(f(x)\)</span> é contínua. A Figura 3.5 ilustra o método regula-falsi.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/regulafalsi-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.5: Ilustração do método da regula-falsi.
</figcaption>
</figure>
</div>
</div>
</div>
<p>O algoritmo do método regula-falsi é um pouco mais elaborado e consiste nos seguintes passos:</p>
<ol type="1">
<li>Escolha os pontos <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> entre os quais existe uma solução.</li>
<li>Calcule a primeira estimativa: <span class="math inline">\(x^{(i)} = \frac{a f(b) - b f(a)}{f(b) - f(a)}.\)</span></li>
<li>Determine se a solução está entre <span class="math inline">\(a\)</span> e <span class="math inline">\(x^{i}\)</span>, ou entre <span class="math inline">\(x^{(i)}\)</span> e <span class="math inline">\(b\)</span>.
<ul>
<li>Se <span class="math inline">\(f(a)f(x^{(i)}) &lt; 0\)</span>, a solução está entre <span class="math inline">\(a\)</span> e <span class="math inline">\(x^{(i)}\)</span>.</li>
<li>Se <span class="math inline">\(f(a)f(x^{(i)}) &gt; 0\)</span>, a solução está entre <span class="math inline">\(x^{(i)}\)</span> e <span class="math inline">\(b\)</span>.</li>
</ul></li>
<li>Selecione o subintervalo que contém a solução como o novo intervalo <span class="math inline">\([a,b]\)</span> e volte ao passo 2.</li>
<li>Repita passos 2 a 4 até a convergência.</li>
</ol>
<p>O Código 3.2 implementa o algoritmo do método da regula-falsi em <code>R</code>.</p>
<p><strong>Código 3.2</strong> Método regula-falsi.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>regula_falsi <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, a, b, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">100</span>) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  fa <span class="ot">&lt;-</span> <span class="fu">fx</span>(a);  fb <span class="ot">&lt;-</span> <span class="fu">fx</span>(b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(fa<span class="sc">*</span>fb <span class="sc">&gt;</span> <span class="dv">0</span>) <span class="fu">stop</span>(<span class="st">"Solução não está no intervalo"</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">c</span>() </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  sol <span class="ot">&lt;-</span> (a<span class="sc">*</span><span class="fu">fx</span>(b) <span class="sc">-</span> b<span class="sc">*</span><span class="fu">fx</span>(a))<span class="sc">/</span>(<span class="fu">fx</span>(b) <span class="sc">-</span> <span class="fu">fx</span>(a))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>] <span class="ot">&lt;-</span> sol</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  limites <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> max_iter)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    test <span class="ot">&lt;-</span> <span class="fu">fx</span>(a)<span class="sc">*</span><span class="fu">fx</span>(sol)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(test <span class="sc">&lt;</span> <span class="dv">0</span>) { </span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> sol</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> (a<span class="sc">*</span><span class="fu">fx</span>(b) <span class="sc">-</span> b<span class="sc">*</span><span class="fu">fx</span>(a))<span class="sc">/</span>(<span class="fu">fx</span>(b) <span class="sc">-</span> <span class="fu">fx</span>(a))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(test <span class="sc">&gt;</span> <span class="dv">0</span>) { </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">=</span> sol</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> sol <span class="ot">&lt;-</span> (a<span class="sc">*</span><span class="fu">fx</span>(b) <span class="sc">-</span> b<span class="sc">*</span><span class="fu">fx</span>(a))<span class="sc">/</span>(<span class="fu">fx</span>(b) <span class="sc">-</span> <span class="fu">fx</span>(a))</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="sc">-</span> solucao[i]) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    sol <span class="ot">=</span> solucao[i<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    limites[i,] <span class="ot">&lt;-</span> <span class="fu">c</span>(a,b)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Tentativas"</span> <span class="ot">=</span> solucao, <span class="st">"Limites"</span> <span class="ot">=</span> limites, <span class="st">"Raiz"</span> <span class="ot">=</span> sol)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso do método vamos resolver a mesma equação da seção #BISSE3.1.1.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implementando a função</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="sc">-</span><span class="fu">log</span>(x) <span class="sc">-</span> <span class="dv">1</span>}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Resolvendo numericamente</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>resul <span class="ot">&lt;-</span> <span class="fu">regula_falsi</span>(<span class="at">fx =</span> fx, <span class="at">a =</span> <span class="fl">0.1</span>, <span class="at">b =</span> <span class="fl">0.55</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Tentativas</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0.4438416 0.4005326 0.3821146 0.3741249 0.3706274 0.3690900 0.3684130
 [8] 0.3681147 0.3679832 0.3679252</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Limites[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1]      [,2]
 [1,]  0.1 0.4438416
 [2,]  0.1 0.4005326
 [3,]  0.1 0.3821146
 [4,]  0.1 0.3741249
 [5,]  0.1 0.3706274
 [6,]  0.1 0.3690900
 [7,]  0.1 0.3684130
 [8,]  0.1 0.3681147
 [9,]   NA        NA
[10,]   NA        NA</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>resul<span class="sc">$</span>Raiz <span class="co"># Solução aproximada</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3679832</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">exp</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="co"># Solução exata</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3678794</code></pre>
</div>
</div>
<p>Novamente vemos que o método numérico, neste caso o regula-falsi, forneceu uma aproximação razoável para a solução exata. Neste exemplo foram necessárias oito iterações para atingir a tolerância especificada.</p>
<p>De forma geral, os métodos de confinamento sempre convergem desde que a solução esteja no intervalo especificado. Um caso em que os métodos de confinamento podem falhar é quando a função é tangente ao eixo <span class="math inline">\(x\)</span> e portanto não cruza o ponto <span class="math inline">\(f(x) = 0\)</span>. A convergência dos métodos de confinamento é lenta em comparação com os métodos abertos e são praticamente impossíveis de generalizar para sistemas de equações não-lineares de alta dimensão.</p>
</section>
<section id="método-de-newton" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="método-de-newton"><span class="header-section-number">3.1.3</span> Método de Newton</h3>
<p>O método de Newton é um método aberto. Supõe-se que a função seja contínua e diferenciável e que a solução está perto do valor inicial. A ideia é aproximar a função original por uma reta tangente ao valor inicial. Projetar a reta até o eixo <span class="math inline">\(x\)</span> e projetar o ponto novamente até a função para obter a atualização da solução inicial. O processo é repetido até que algum critério de convergência seja atingido. A Figura 3.6 ilustra o esquema de atualização do método de Newton.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-6" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/Newton-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.6: Ilustração do método de Newton.
</figcaption>
</figure>
</div>
</div>
</div>
<p>O algoritmo do método de Newton é simples e consiste nos seguintes passos:</p>
<ol type="1">
<li>Escolha um ponto <span class="math inline">\(x_1\)</span> como inicial. 2 Para <span class="math inline">\(i=1,2,\ldots\)</span> até que o erro seja menor que um valor especificado, calcule <span class="math display">\[x^{(i+1)} = x^{(i)} - \frac{f(x)}{f^{\prime}(x)}.\]</span></li>
</ol>
<p>O Código 3.3 implementa o algoritmo do método de Newton em <code>R</code>.</p>
<p><strong>Código 3.3</strong> Método de Newton para resolver uma equação não-linear.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>newton <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, f_prime, x1, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">10</span>) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>] <span class="ot">&lt;-</span> x1</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">=</span> solucao[i] <span class="sc">-</span> <span class="fu">fx</span>(solucao[i])<span class="sc">/</span><span class="fu">f_prime</span>(solucao[i])</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>] <span class="sc">-</span> solucao[i]) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(solucao)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Novamente ilustramos o uso do método resolvendo a equação <span class="math inline">\(f(x) = -\ln(x) - 1 = 0\)</span>. Note que agora precisamos da derivada de <span class="math inline">\(f(x)\)</span> que neste caso é <span class="math inline">\(f^{\prime}(x) = -1/x\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Função a ser resolvida</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="sc">-</span><span class="fu">log</span>(x) <span class="sc">-</span> <span class="dv">1</span>}</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Derivada da função a ser resolvida</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>fprime <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span>x}</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Solução numérica</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>sol_new <span class="ot">&lt;-</span> <span class="fu">newton</span>(<span class="at">fx =</span> fx, <span class="at">f_prime =</span> fprime, <span class="at">x1 =</span> <span class="fl">0.5</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Método de Newton</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>sol_new[<span class="fu">length</span>(sol_new)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3678794</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">exp</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="co"># Solução exata</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3678794</code></pre>
</div>
</div>
<p>A solução fornecida pelo método de Newton é idêntica à solução exata. A grande vantagem do método de Newton em relação aos métodos de confinamento é que ele pode ser facilmente estendido para resolver um sistema de equações não-lineares.</p>
<p>O algoritmo sofre apenas uma pequena alteração trocando a derivada de <span class="math inline">\(f(x)\)</span> pelo Jacobiana de <span class="math inline">\(f(\boldsymbol{x})\)</span>, lembrando que agora <span class="math inline">\(\boldsymbol{x}\)</span> é um vetor. O algoritmo é o seguinte:</p>
<ol type="1">
<li>Escolha um vetor <span class="math inline">\(\boldsymbol{x}_1\)</span> como inicial.</li>
<li>Para <span class="math inline">\(i=1,2,\ldots\)</span> até que o erro seja menor que um valor especificado, calcule <span class="math display">\[\boldsymbol{x}^{(i+1)} = \boldsymbol{x}^{(i)} - \mathbf{J}(\boldsymbol{x}^{(i)})^{-1} f(\boldsymbol{x}^{(i)})\]</span> onde <span class="math display">\[
\mathbf{J}(\boldsymbol{x}^{(i)}) = \begin{bmatrix}
\frac{\partial f_1}{\partial x_1} &amp;  \frac{\partial f_1}{\partial x_2}  &amp;  \ldots &amp;  \frac{\partial f_1}{\partial x_n}\\
\frac{\partial f_2}{\partial x_1} &amp;  \frac{\partial f_2}{\partial x_2} &amp;  \ldots &amp;  \frac{\partial f_2}{\partial x_n} \\
\vdots &amp;  \vdots &amp;  \ddots &amp;  \vdots\\
\frac{\partial f_n}{\partial x_1} &amp;  \frac{\partial f_n}{\partial x_2} &amp;  \ldots &amp;  \frac{\partial f_n}{\partial x_n}
\end{bmatrix}
\]</span> é o Jacobiano de <span class="math inline">\(\mathbf{f}(\boldsymbol{x})\)</span>.</li>
</ol>
<p>A implementação computacional é apresentada no Código #lem:NewtonSistema3.4</p>
<p><strong>Código 3.4</strong> Método de Newton para resolver um sistema de equações não-lineares.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>newton <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, jacobian, x1, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">10</span>) {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(x1), <span class="at">nrow =</span> max_iter)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> x1</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    J <span class="ot">&lt;-</span> <span class="fu">jacobian</span>(solucao[i,])</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    grad <span class="ot">&lt;-</span> <span class="fu">fx</span>(solucao[i,])</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">=</span> solucao[i,] <span class="sc">-</span> <span class="fu">solve</span>(J, grad)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(solucao)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso do método vamos resolver o seguinte sistema de duas equações não-lineares.</p>
<p><span class="math display">\[\begin{eqnarray*}
f_1(x_1, x_2) &amp; =&amp;  x_2 - \frac{1}{2}( \exp^{x_1/2} + \exp^{-x/2}) = 0 \\
f_2(x_1, x_2) &amp; =&amp;  9x_1^2 + 25x_2^2 - 225 = 0.
\end{eqnarray*}\]</span></p>
<p>Para usar o método de Newton precisamos obter o Jacobiano que neste caso é dado por <span class="math display">\[
\mathbf{J}(\boldsymbol{x}^{(i)}) = \begin{bmatrix}
-\frac{1}{2}( \frac{\exp^{x1/2}}{2} - \frac{\exp^{-x1/2}}{2}) &amp;  1 \\
18 x_1 &amp;  50 x_2
\end{bmatrix}.
\]</span></p>
<p>Finalmente, implementamos o sistema e seu Jacobiano e usamos a função em #lem:NewtonSistema3.4 para resolver o sistema.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sistema a ser resolvido</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="fu">c</span>(x[<span class="dv">2</span>] <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">*</span>(<span class="fu">exp</span>(x[<span class="dv">1</span>]<span class="sc">/</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>x[<span class="dv">1</span>]<span class="sc">/</span><span class="dv">2</span>)), </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">9</span><span class="sc">*</span>x[<span class="dv">1</span>]<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> <span class="dv">25</span><span class="sc">*</span>x[<span class="dv">2</span>]<span class="sc">^</span><span class="dv">2</span> <span class="sc">-</span> <span class="dv">225</span> )}</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Jacobiano</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>Jacobian <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  jac <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  jac[<span class="dv">1</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">0.5</span><span class="sc">*</span>(<span class="fu">exp</span>(x[<span class="dv">1</span>]<span class="sc">/</span><span class="dv">2</span>)<span class="sc">/</span><span class="dv">2</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>x[<span class="dv">1</span>]<span class="sc">/</span><span class="dv">2</span>)<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  jac[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  jac[<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">18</span><span class="sc">*</span>x[<span class="dv">1</span>]</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  jac[<span class="dv">2</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="dv">50</span><span class="sc">*</span>x[<span class="dv">2</span>]</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(jac)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Resolvendo</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">&lt;-</span> <span class="fu">newton</span>(<span class="at">fx =</span> fx, <span class="at">jacobian =</span> Jacobian, <span class="at">x1 =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(sol,<span class="dv">4</span>) <span class="co"># Solução</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]     [,2]
 [7,] 3.031159 2.385865
 [8,] 3.031155 2.385866
 [9,]       NA       NA
[10,]       NA       NA</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fx</span>(sol[<span class="dv">8</span>,]) <span class="co"># OK</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -3.125056e-12  9.907808e-11</code></pre>
</div>
</div>
<p>Neste exemplo foram necessárias oito iterações para atingir a convergência. Para verificar a solução obtida, simplesmente avaliamos o sistema no ponto e vemos que a solução é bastante satisfatória. O método de Newton irá convergir tipicamente se três condições forem satisfeitas:</p>
<ol type="1">
<li>As funções <span class="math inline">\(f_1, f_2, \ldots, f_n\)</span> e suas derivadas forem contínuas e limitadas na vizinhança da solução.</li>
<li>O Jacobiano deve ser diferente de zero na vizinhança da solução.</li>
<li>A estimativa inicial de solução deve estar suficientemente próxima da solução exata.</li>
</ol>
<p>O principal custo operacional do método de Newton é que as derivadas parciais (elementos da matriz Jacobiana) devem ser determinadas. Isso pode ser feito analítica ou numericamente. Além disso, o principal custo computacional é que, a cada iteração do algoritmo, deve-se resolver um sistema de equações. Esse passo pode ser crítico para sistemas com centenas ou milhares de incógnitas tornando o método não aplicável nestas situações.</p>
</section>
<section id="método-do-gradiente-descendente" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="método-do-gradiente-descendente"><span class="header-section-number">3.1.4</span> Método do gradiente descendente</h3>
<p>O método do Gradiente descendente em geral é usado para encontrar o mínimo ou máximo de uma função. Suponha que desejamos maximizar <span class="math inline">\(F(x)\)</span> cuja derivada é <span class="math inline">\(f(x)\)</span>. Sabemos que um ponto crítico será obtido em <span class="math inline">\(f(x) = 0\)</span>. Note que <span class="math inline">\(f(x)\)</span> é o gradiente de <span class="math inline">\(F(x)\)</span>, assim aponta na direção do máximo da função. Assim, podemos caminhar na direção da raiz apenas seguindo o gradiente, ou seja,</p>
<p><span class="math display">\[x^{(i+1)} = x^{(i)} - \alpha f(x^{(i)}),\]</span></p>
<p>onde <span class="math inline">\(\alpha &gt; 0\)</span> é um parâmetro de <em>tuning</em> usado para controlar o tamanho do passo. Sua especificação não é simples e é comum ser obtido por tentativa e erro. Resumindo, o algoritmo do método do gradiente descendente é o seguinte:</p>
<ol type="1">
<li>Escolha um ponto <span class="math inline">\(x_1\)</span> como inicial.</li>
<li>Para <span class="math inline">\(i=1,2,\ldots\)</span> até que o erro seja menor que um valor especificado, calcule <span class="math display">\[x^{(i+1)} = x^{(i)} - \alpha f(x^{(i)}).\]</span></li>
</ol>
<p>A implementação computacional para o caso de apenas uma equação não-linear é apresentada no Código 3.5.</p>
<p><strong>Código 3.5</strong> Método do gradiente descendente para resolver uma equação não-linear.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>grad_des <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, x1, alpha, <span class="at">max_iter =</span> <span class="dv">100</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>) {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  sol <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  sol[<span class="dv">1</span>] <span class="ot">&lt;-</span> x1</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    sol[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> sol[i] <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">fx</span>(sol[i])</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(sol[i<span class="sc">+</span><span class="dv">1</span>] <span class="sc">&lt;</span> <span class="dv">0</span>) {sol[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">=</span> <span class="fl">1e-04</span>}</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">abs</span>(<span class="fu">fx</span>(sol[i<span class="sc">+</span><span class="dv">1</span>])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sol)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Novamente ilustramos o uso do método resolvendo a equação <span class="math inline">\(f(x) = -\ln(x) - 1 = 0\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Função a ser resolvida</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x){<span class="sc">-</span><span class="fu">log</span>(x) <span class="sc">-</span> <span class="dv">1</span>}</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Solução numérica</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>sol_grad <span class="ot">&lt;-</span> <span class="fu">grad_des</span>(<span class="at">fx =</span> fx, <span class="at">alpha =</span> <span class="sc">-</span><span class="fl">0.2</span>, <span class="at">x1 =</span> <span class="dv">1</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>sol_grad[<span class="fu">length</span>(sol_grad)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3679003</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exata</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">exp</span>(<span class="sc">-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3678794</code></pre>
</div>
</div>
<p>Note que neste exemplo <span class="math inline">\(\alpha = -0.2\)</span>. Este valor foi obtido por tentativa e erro. A recomendação geral é usar valores não muito distantes de zero. Uma outra opção é fazer uma busca em uma grade de valores de <span class="math inline">\(\alpha\)</span>. O fato é que <span class="math inline">\(\alpha\)</span> é fundamental para a convergência do método e deve ser especificado caso a caso.</p>
<p>Da mesma forma que o método de Newton, o método do gradiente descendente estende naturalmente para o caso de sistemas de equações não-lineares. O algoritmo é o seguinte</p>
<ol type="1">
<li>Escolha um vetor <span class="math inline">\(\boldsymbol{x}_1\)</span> como inicial.</li>
<li>Para <span class="math inline">\(i=1,2,\ldots\)</span> até que o erro seja menor que um valor especificado, calcule</li>
</ol>
<p><span class="math display">\[\boldsymbol{x}^{(i+1)} = \boldsymbol{x}^{(i)} - \alpha \mathbf{f}(\boldsymbol{x}^{(i)}).\]</span></p>
<p>Diversas modificações do método surgem por meio de diferentes estratégias para especificar o parâmetro <span class="math inline">\(\alpha\)</span>, que na literatura de aprendizagem de máquina é chamado de <strong>taxa de aprendizagem</strong>. O Código #lem:graddessist3.6 apresenta a implementação computacional do método.</p>
<p><strong>Código 3.6</strong> Método do gradiente descendente para resolver um sistema de equações não-lineares.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>grad_des <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, x1, alpha, <span class="at">max_iter =</span> <span class="dv">100</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>) {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(x1), <span class="at">nrow =</span> max_iter)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> x1</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> solucao[i,] <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">fx</span>(solucao[i,])</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print(c(i, solucao[i+1,]))</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;=</span> tol) <span class="cf">break</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(solucao)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso do método vamos resolver o sistema de equações não-lineares</p>
<p><span class="math display">\[\begin{eqnarray*}
f_1(x_1, x_2) &amp; =&amp;  -2\sum_{i=1}^{10}(y_i - x_1 - x_2 z_i) \\
f_2(x_1, x_2) &amp; =&amp;  -2\sum_{i=1}^{10}(y_i - x_1 - x_2 z_i)z_i
\end{eqnarray*}\]</span></p>
<p>onde <span class="math display">\[
y_i = (5.15; 6.40; 2.77; 5.72; 6.25; 3.45; 5.00; 6.86; 4.86; 3.72) \quad \text{ e} \\
z_i = (0.28; 0.78; 0.40; 0.88; 0.94; 0.04; 0.52; 0.89; 0.55; 0.45)
\]</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">5.15</span>, <span class="fl">6.40</span>, <span class="fl">2.77</span>, <span class="fl">5.72</span>, <span class="fl">6.25</span>, <span class="fl">3.45</span>, <span class="fl">5.00</span>, <span class="fl">6.86</span>, <span class="fl">4.86</span>, <span class="fl">3.72</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.28</span>, <span class="fl">0.78</span>, <span class="fl">0.40</span>, <span class="fl">0.88</span>, <span class="fl">0.94</span>, <span class="fl">0.04</span>, <span class="fl">0.52</span>, <span class="fl">0.89</span>, <span class="fl">0.55</span>, <span class="fl">0.45</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  term1 <span class="ot">&lt;-</span> <span class="sc">-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">sum</span>(y <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">-</span> x[<span class="dv">2</span>]<span class="sc">*</span>z)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  term2 <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span><span class="sc">*</span><span class="fu">sum</span>( (y <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">-</span> x[<span class="dv">2</span>]<span class="sc">*</span>z)<span class="sc">*</span>z)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">c</span>(term1, term2)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>sol_grad <span class="ot">&lt;-</span> <span class="fu">grad_des</span>(<span class="at">fx =</span> fx, <span class="at">x1 =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">0</span>), <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">max_iter =</span> <span class="dv">140</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(sol_grad)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>           [,1]     [,2]
[135,] 2.925670 3.651604
[136,] 2.925631 3.651668
[137,] 2.925594 3.651728
[138,]       NA       NA
[139,]       NA       NA
[140,]       NA       NA</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fx</span>(<span class="at">x =</span> sol_grad[<span class="dv">137</span>,])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  0.0006924313 -0.0011375970</code></pre>
</div>
</div>
<p>A grande vantagem do método do gradiente descendente é a sua simplicidade e facilidade computacional. Uma vez que não é necessário obter o Jacobiano como no método de Newton, esse método é a primeira escolha quando precisamos lidar com grandes sistemas de equações não-lineares. É importante notar que esse método pressupõe que existe uma função multidimensional sendo minimizada. No caso de estarmos resolvendo diretamente um sistema de equações, temos que ter cuidado ao avaliar se a função multidimensional que gerou o sistema deve ser minimizada ou maximizada. No caso de ser maximizada deve-se ter cuidado com o sinal do parâmetro de <em>tuning</em> <span class="math inline">\(\alpha\)</span>, que neste caso será negativo. Outra solução é modificar a função multiplicando por <span class="math inline">\(-1\)</span> para que o objetivo seja minimizar a função, levando o sistema de equações para a forma adequada para o método do gradiente descendente.</p>
<p>A desvantagem do método gradiente descendente é a necessidade de especificar o parâmetro <span class="math inline">\(\alpha\)</span>, o que pode ser difícil em termos práticos. Em particular neste exemplo, foi bastante difícil obter a convergência, note que foram necessárias <span class="math inline">\(137\)</span> iterações para convergência. Em geral, o método do gradiente descendente vai precisar de mais iterações para atingir convergência do que o método de Newton. Porém, cada iteração é mais barata e rápida computacionalmente. Vale mencionar que grande parte das técnicas modernas de aprendizagem de máquina, como <em>deep learnig</em>, usam variações deste método na fase de treinamento.</p>
</section>
</section>
<section id="diferenciação-numérica" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="diferenciação-numérica"><span class="header-section-number">3.2</span> Diferenciação numérica</h2>
<p>Nós discutimos no Capítulo 1 a importância da derivada em ciência de dados e como obtê-la por meio do cálculo de limites. Nesta subseção vamos ver que a derivada pode ser aproximada de forma numérica usando diferenças finitas. Calcular o valor da derivada de uma função de forma numérica é indicado em pelo menos três situações:</p>
<ol type="1">
<li><span class="math inline">\(f^{\prime}(x)\)</span> é difícil de obter analiticamente.</li>
<li><span class="math inline">\(f^{\prime}(x)\)</span> é caro de calcular computacionalmente, porém <span class="math inline">\(f(x)\)</span> é barata de calcular computacionalmente.</li>
<li>Quando a função é especificada apenas por um conjunto de pontos.</li>
</ol>
<p>O caso número 3 é comum em problemas de engenharia, porém pouco comum em ciência de dados. Sendo assim, daremos maior ênfase aos casos 1 e 2.</p>
<p>Lembre-se que a derivada <span class="math inline">\(f^{\prime}(x)\)</span> de uma função <span class="math inline">\(f(x)\)</span> no ponto <span class="math inline">\(x = a\)</span> é definida como:</p>
<p><span class="math display">\[f^{\prime}(a) = \lim_{x \to a} \frac{f(x) - f(a)}{x-a}.\]</span></p>
<p>A derivada é o valor da inclinação da reta tangente à função em <span class="math inline">\(x = a\)</span>. A ideia de diferenciação numérica é simplesmente imitar essa equação de forma computacional. Assim, escolhe-se um ponto <span class="math inline">\(x\)</span> próximo a <span class="math inline">\(a\)</span> e calcula-se a inclinação da reta que conecta os dois pontos. Claramente a precisão do cálculo aumenta quando <span class="math inline">\(x\)</span> aproxima de <span class="math inline">\(a\)</span>.</p>
<p>A aproximação da derivada por diferenças finitas pode ser feito de maneira simples usando as seguintes fórmulas de diferenciação numérica:</p>
<ul>
<li>Diferença progressiva: inclinação da reta que conecta os pontos <span class="math inline">\((x_i, f(x_i))\)</span> e <span class="math inline">\((x_{i+1}, f(x_{i+1}))\)</span>: <span class="math display">\[f^{\prime}(x_i) = \frac{f(x_{i+1}) - f(x_i)}{x_{i+1} - x_i}.\]</span></li>
<li>Diferença regressiva: inclinação da reta que conecta os pontos <span class="math inline">\((x_{i-1}, f(x_{i-1}))\)</span> e <span class="math inline">\((x_{i}, f(x_{i}))\)</span>: <span class="math display">\[f^{\prime}(x_i) = \frac{f(x_i) - f(x_{i-1})}{x_i - x_{i-1}}.\]</span></li>
<li>Diferença central: inclinação da reta que conecta os pontos <span class="math inline">\((x_{i-1}, f(x_{i-1}))\)</span> e <span class="math inline">\((x_{i+1}, f(x_{i+1}))\)</span>: <span class="math display">\[f^{\prime}(x_i) = \frac{f(x_{i+1}) - f(x_{i-1})}{x_{i+1} - x_{i-1}}.\]</span></li>
</ul>
<p>A Figura 3.7 ilustra graficamente cada um destes métodos.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-7" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/difnum-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.7: Ilustração dos métodos de diferenças finitas para aproximação da derivada numericamente.
</figcaption>
</figure>
</div>
</div>
</div>
<p>A implementação computacional é muito simples, conforme as funções em 3.7, 3.8 e 3.9.</p>
<p><strong>Código 3.7</strong> Diferença progressiva.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>dif_prog <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, x, h) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">&lt;-</span> (<span class="fu">fx</span>(x <span class="sc">+</span> h) <span class="sc">-</span> <span class="fu">fx</span>(x))<span class="sc">/</span>( (x <span class="sc">+</span> h) <span class="sc">-</span> x)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(df)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.8</strong> Diferença regressiva.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>dif_reg <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, x, h) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">&lt;-</span> (<span class="fu">fx</span>(x) <span class="sc">-</span> <span class="fu">fx</span>(x <span class="sc">-</span> h))<span class="sc">/</span>( x <span class="sc">-</span> (x <span class="sc">-</span> h))</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(df)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.9</strong> Diferença central.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>dif_cen <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, x, h) {</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">&lt;-</span> (<span class="fu">fx</span>(x <span class="sc">+</span> h) <span class="sc">-</span> <span class="fu">fx</span>(x <span class="sc">-</span> h))<span class="sc">/</span>( (x <span class="sc">+</span> h) <span class="sc">-</span> (x <span class="sc">-</span> h))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(df)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso destes métodos vamos obter a derivada da função <span class="math inline">\(f(x) = x^3\)</span> que podemos facilmente obter analiticamente e é dada por <span class="math inline">\(f^{\prime}(x) = 3 x^2\)</span>. Assim, podemos comparar a qualidade da aproximação fornecida por cada método.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) x<span class="sc">^</span><span class="dv">3</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Diferença progressiva</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="fu">dif_prog</span>(fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 12.006</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Diferença regressiva</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dif_reg</span>(fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11.994</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Diferença central</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dif_cen</span>(fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.001</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 12</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exata</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span><span class="sc">*</span><span class="dv">2</span><span class="sc">^</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 12</code></pre>
</div>
</div>
<p>Os três métodos fornecem valores próximos ao valor verdadeiro da derivada da função. A qualidade da aproximação depende do tamanho de <span class="math inline">\(h\)</span> que neste caso foi <span class="math inline">\(h=0.01\)</span>. Pode parecer natural simplesmente diminuir <span class="math inline">\(h\)</span> tanto quanto possível para melhorar a qualidade da aproximação. No entanto, tal estratégia não é recomendada, uma vez que ao diminuir o valor de <span class="math inline">\(h\)</span>, você estará realizando uma divisão por um número muito próximo de zero o que pode levar a um erro de arredondamento muito maior do que o erro no cálculo da derivada.</p>
<p>Por ser uma aproximação, alguma diferença deve existir entre a aproximação e o cálculo obtido de forma analítica. Para estudar essa diferença ou pelo menos ter uma noção do tamanho do erro de aproximação é comum obter as fórmulas de diferenciação numérica usando a expansão em séries de Taylor. Vamos ver como tais aproximações são realizadas no caso da diferença progressiva, regressiva e central e depois como elas podem ser generalizadas.</p>
<p>Para o caso da diferença progressiva, começamos fazendo a aproximação de Taylor para o ponto <span class="math inline">\(x_{i+1}\)</span> em torno de <span class="math inline">\(x_i\)</span>, ou seja, <span class="math display">\[f(x_{i+1}) = f(x_i) + f^{\prime}(x_i)h + \frac{f''(x_i)}{2!}h^2 + \frac{f'''(x_i)}{3!}h^3 + \ldots,\]</span> onde <span class="math inline">\(h = x_{i+1} - x_i\)</span>. Fixando dois termos e deixando os outros termos como um resíduo, temos <span class="math display">\[f(x_{i+1}) = f(x_i) + f'(x_i) h + \frac{f''(\xi)}{2!}h^2. \]</span> Agora simplesmente isolamos <span class="math inline">\(f'(x_i)\)</span> e temos <span class="math display">\[f'(x_i) = \frac{f(x_{i+1}) - f(x_i)}{h} - \frac{f''(\xi)}{2!}h^2.\]</span> Neste caso o erro de truncamento é <span class="math display">\[- \frac{f''(\xi)}{2!}h^2 = O(h).\]</span> A notação <span class="math inline">\(O(h)\)</span> diz que o erro da aproximação é da ordem de <span class="math inline">\(h\)</span>. Veja que <span class="math inline">\(h\)</span> é o que controla a precisão da aproximação no termo que não é deixado como o resíduo.</p>
<p>Para o caso da diferença regressiva trabalhamos exatamente da mesma forma, porém expandimos em torno do ponto <span class="math inline">\(x_{i-1}\)</span>, assim obtemos <span class="math display">\[f(x_{i-1}) = f(x_i) - f^{\prime}(x_i)h + \frac{f''(x_i)}{2!}h^2 + \frac{f'''(x_i)}{3!}h^3 + \ldots,\]</span></p>
<p>onde <span class="math inline">\(h = x_{i} - x_{i-1}\)</span>.</p>
<p>Novamente, fixando dois termos e deixando os outros termos como um resíduo, temos <span class="math display">\[f(x_{i-1}) = f(x_i) - f'(x_i) h + \frac{f''(\xi)}{2!}h^2. \]</span> Agora isolando <span class="math inline">\(f'(x_i)\)</span>, temos <span class="math display">\[f'(x_i) = \frac{f(x_{i}) - f(x_{i-1})}{h} + \frac{f''(\xi)}{2!}h^2.\]</span> Por fim, o erro de truncamento é dado por <span class="math display">\[\frac{f''(\xi)}{2!}h^2 = O(h).\]</span> Para o caso da diferença central é um pouco mais trabalhoso. Primeiro expandimos em séries de Taylor em torno de <span class="math inline">\(x_{i+1}\)</span>,</p>
<p><span class="math display">\[\begin{equation}
f(x_{i+1}) = f(x_i) + f^{\prime}(x_i)h + \frac{f''(x_i)}{2!}h^2 + \frac{f'''(\xi_1)}{3!}h^3,
  \tag{3.1}
\end{equation}\]</span> onde <span class="math inline">\(\xi_1\)</span> está entre <span class="math inline">\(x_i\)</span> e <span class="math inline">\(x_{i+1}\)</span>.</p>
<p>Agora procedemos com a expansão em torno de <span class="math inline">\(x_{i-1}\)</span>, <span class="math display">\[\begin{equation}
f(x_{i-1}) = f(x_i) - f^{\prime}(x_i)h + \frac{f''(x_i)}{2!}h^2 + \frac{f'''(\xi_2)}{3!}h^3,
  \tag{3.2}
\end{equation}\]</span> onde <span class="math inline">\(\xi_2\)</span> está entre <span class="math inline">\(x_{i-1}\)</span> e <span class="math inline">\(x_{i}\)</span>.</p>
<p>Subtraindo (3.1) de (3.2), obtemos <span class="math display">\[f(x_{i+1}) - f(x_{i-1}) = 2f'(x_i) h + \frac{f'''(\xi_1)}{3!}h^3 + \frac{f'''(\xi_2)}{3!}h^3.\]</span> Resolvendo para <span class="math inline">\(f'(x_i)\)</span>, temos <span class="math display">\[f'(x_i) = \frac{f(x_{i+1}) - f(x_{i-1})}{2h} + O(h^2).\]</span> Note que para o caso da diferença central a ordem do erro de truncamento é de <span class="math inline">\(O(h^2)\)</span> e portanto mais precisa que a diferença progressiva e regressiva.</p>
<p>As fórmulas obtidas até aqui usam apenas dois pontos para aproximar a derivada. Porém, usando a expansão em séries de Taylor podemos obter fórmulas com um maior número de pontos. Para mostrar como é o processo, vamos obter a fórmula de diferença finita progressiva com três pontos.</p>
<p>A ideia é aproximar <span class="math inline">\(f'(x_i)\)</span> avaliando a função no ponto <span class="math inline">\(x_i\)</span> e nos dois pontos seguintes <span class="math inline">\(x_{i+1}\)</span> e <span class="math inline">\(x_{i+2}\)</span>. Procedendo com a aproximação de Taylor em <span class="math inline">\(x_{i+1}\)</span> e <span class="math inline">\(x_{i+2}\)</span>,</p>
<p><span class="math display">\[\begin{equation}
f(x_{i+1}) = f(x_i) + f^{\prime}(x_i)h + \frac{f''(x_i)}{2!}h^2 + \frac{f'''(\xi_1)}{3!}h^3,
   \tag{3.3}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
f(x_{i+2}) = f(x_i) + f^{\prime}(x_i)2h + \frac{f''(x_i)}{2!}(2h)^2 + \frac{f'''(\xi_2)}{3!}(2h)^3.
    \tag{3.4}
\end{equation}\]</span></p>
<p>As equações (3.3) e (3.4) são combinadas de forma que os termos com derivada segunda desapareçam. Assim, multiplicando Equação (3.3) por <span class="math inline">\(4\)</span> e subtraindo Equação (3.4), temos</p>
<p><span class="math display">\[4 f(x_{i+1}) - f(x_{i+2}) = 3 f(x_i) + 2 f'(x_i)h + \frac{4f'''(\xi_1)}{3!}h^3 - \frac{f'''(\xi_2)}{3!}(2h)^3.\]</span></p>
<p>Resolvendo em <span class="math inline">\(f'(x_i)\)</span>, temos</p>
<p><span class="math display">\[f'(x_i) = \frac{f(x_{i-2}) - 4 f(x_{i-1}) + 3 f(x_i)}{2h} + O(h).\]</span></p>
<p>Usando as mesmas ideias podemos aproximar a derivada segunda de uma função qualquer por diferenças finitas. A derivação das fórmulas é idêntica, porém mais tediosa. A fórmula da diferença central com três pontos para a derivada segunda é</p>
<p><span class="math display">\[f''(x_i) = \frac{f(x_{i-1}) - 2 f(x_i) + f(x_{i+1})}{h^2} + O(h^2),\]</span></p>
<p>e com quatro pontos a diferença central fica dada por</p>
<p><span class="math display">\[f''(x_i) = \frac{-f(x_{i-2}) + 16 f(x_{i-1}) - 30 f(x_i) + 16 f(x_{i+1}) - f(x_{i+2})}{12 h^2} + O(h^4).\]</span></p>
<p>Em todas as fórmulas o erro de truncamento é função de <span class="math inline">\(h\)</span>, ou seja, do espaçamento entre os pontos, i.e.&nbsp;<span class="math inline">\(h = x_{i+1} - x_i\)</span>. Portanto, fazendo <span class="math inline">\(h\)</span> pequeno o erro de truncamento será pequeno. O erro de arredondamento depende da precisão finita de cada computador. Mesmo que <span class="math inline">\(h\)</span> possa ser tão pequeno quanto desejado, o erro de arredondamento pode crescer quando se diminui <span class="math inline">\(h\)</span>. Por isso, a recomendação é usar <span class="math inline">\(h\)</span> não tão pequeno, porém que forneça uma aproximação razoável. Isso significa que algumas tentativas são necessárias para fixar um valor de <span class="math inline">\(h\)</span> razoável para a função sendo derivada.</p>
<p>Uma forma de melhorar a aproximação quando precisão é desejada ao invés de velocidade computacional é usar o <strong>método de Richardson</strong>. A ideia da extrapolação de <strong>Richardson</strong> é obter uma aproximação mais precisa da derivada a partir de duas aproximações menos precisas.</p>
<p>Considere o valor <span class="math inline">\(D\)</span> de uma derivada (desconhecida) calculada pela fórmula</p>
<p><span class="math display">\[\begin{equation}
D = D(h) + k_2 h^2 + k_4 h^4,
  \tag{3.5}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(D(h)\)</span> aproxima <span class="math inline">\(D\)</span> e <span class="math inline">\(k_2\)</span> e <span class="math inline">\(k_4\)</span> são termos de erro.</p>
<p>O uso da mesma fórmula, porém com espaçamento <span class="math inline">\(h/2\)</span> resulta</p>
<p><span class="math display">\[\begin{equation}
D = D\left(\frac{h}{2}\right) + k_2 \left(\frac{h}{2}\right)^2 + k_4 \left(\frac{h}{2}\right)^4.
  \tag{3.6}
\end{equation}\]</span></p>
<p>A Equação (3.6) pode ser reescrita, após multiplicar por 4, como <span class="math display">\[\begin{equation}
4D = 4D\left(\frac{h}{2}\right) + k_2 h^2 + k_4 \frac{h^4}{4}.
  \tag{3.7}
\end{equation}\]</span></p>
<p>Subtraindo (3.5) de (3.7) elimina os termos com <span class="math inline">\(h^2\)</span> e fornece <span class="math display">\[\begin{equation}
3D = 4D\left(\frac{h}{2}\right) + D(h) - k_4 \frac{3h^4}{4}.
  \tag{3.8}
\end{equation}\]</span></p>
<p>Por fim, resolvendo (3.8), temos <span class="math display">\[\begin{equation}
D = \frac{1}{3} \left( 4D\left(\frac{h}{2}\right) + D(h) \right) - k_4 \frac{h^4}{4}.
  \tag{3.9}
\end{equation}\]</span></p>
<p>O erro na Equação (3.9) é agora <span class="math inline">\(O(h^4)\)</span>. O valor de <span class="math inline">\(D\)</span> é aproximado por <span class="math display">\[\begin{equation*}
D = \frac{1}{3} \left( 4D\left(\frac{h}{2}\right) + D(h) \right) + O(h^4).
\end{equation*}\]</span></p>
<p>Note que a partir de duas aproximações de ordem inferiores, obtemos uma aproximação de <span class="math inline">\(O(h^4)\)</span> mais precisa. Seguindo um procedimento similar a partir de duas aproximações com erro <span class="math inline">\(O(h^4)\)</span> chegamos que <span class="math display">\[\begin{equation*}
D = \frac{1}{15} \left( 16 D\left(\frac{h}{2}\right) + D(h) \right) + O(h^6).
\end{equation*}\]</span></p>
<p>Que proporciona uma aproximação ainda mais precisa.</p>
<p>Para ilustrar o uso da extrapolação de Richardson vamos calcular a derivada de <span class="math inline">\(f(x) = \frac{2^x}{x}\)</span> no ponto <span class="math inline">\(x = 2\)</span>. A solução exata é facilmente obtida e dada por <span class="math inline">\(\frac{\log(2)2^x}{x} - \frac{2^x}{x^2}\)</span>. Assim, poderemos comparar a solução numérica com a exata para ver o ganho no uso do método de Richardson. Para comparar os erros vamos fazer a razão entre a solução exata e a aproximada. Quanto mais próxima de 1 for essa razão melhor é a aproximação. Como as quantidades envolvidas são pequenas, podemos ainda subtrair 1 da razão para ter valores em torno de 0 e multiplicar por 100 para evidenciar as diferenças. O Código 3.10 apresenta a comparação entre o valor exato da derivada e a aproximação usando diferença central.</p>
<p><strong>Código 3.10</strong> Diferença entre a solução exata e a diferença central.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) (<span class="dv">2</span><span class="sc">^</span>x)<span class="sc">/</span>x</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>fpx <span class="ot">&lt;-</span> <span class="cf">function</span>(x)(<span class="fu">log</span>(<span class="dv">2</span>)<span class="sc">*</span>(<span class="dv">2</span><span class="sc">^</span>x))<span class="sc">/</span>x <span class="sc">-</span> (<span class="dv">2</span><span class="sc">^</span>x)<span class="sc">/</span>x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>erro <span class="ot">&lt;-</span> <span class="fu">fpx</span>(<span class="at">x =</span> <span class="dv">2</span>)<span class="sc">/</span><span class="fu">dif_cen</span>(<span class="at">fx =</span> fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.2</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>(erro<span class="dv">-1</span>)<span class="sc">*</span><span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.345544</code></pre>
</div>
</div>
<p>Agora vamos usar a fórmula da diferença central e a extrapolação de Richardson para obter uma aproximação ainda mais precisa. O procedimento é ilustrado no Código 3.11.</p>
<p><strong>Código 3.11</strong> Diferença entre a solução exata e extrapolação de Richardson.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>D2 <span class="ot">&lt;-</span> <span class="fu">dif_cen</span>(<span class="at">fx =</span> fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.2</span><span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>D <span class="ot">&lt;-</span> <span class="fu">dif_cen</span>(<span class="at">fx =</span> fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.2</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>der <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>)<span class="sc">*</span>( <span class="dv">4</span><span class="sc">*</span>D2 <span class="sc">-</span> D)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>erro2 <span class="ot">&lt;-</span> <span class="fu">fpx</span>(<span class="at">x =</span> <span class="dv">2</span>)<span class="sc">/</span>der</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>(erro2<span class="dv">-1</span>)<span class="sc">*</span><span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.001585268</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"Exata"</span> <span class="ot">=</span> <span class="fu">fpx</span>(<span class="at">x =</span> <span class="dv">2</span>), <span class="st">"Richardson"</span> <span class="ot">=</span> der, </span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Central"</span> <span class="ot">=</span> <span class="fu">dif_cen</span>(<span class="at">fx =</span> fx, <span class="at">x =</span> <span class="dv">2</span>, <span class="at">h =</span> <span class="fl">0.2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Exata Richardson    Central 
 0.3862944  0.3863005  0.3849641 </code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"Erro: Diferença Central"</span> <span class="ot">=</span> (erro<span class="dv">-1</span>)<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Erro: Richardson"</span> <span class="ot">=</span> (erro2<span class="dv">-1</span>)<span class="sc">*</span><span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Erro: Diferença Central        Erro: Richardson 
            0.345543965            -0.001585268 </code></pre>
</div>
</div>
<p>Como esperado, o método de Richardson oferece uma aproximação mais precisa que o método usando apenas a diferença central.</p>
<p>As técnicas para diferenciação numéricas apresentadas até aqui estendem naturalmente para a situação em que as funções têm mais de uma variável. Lembre-se que como discutido no Capítulo 1 para funções com muitas variáveis a derivada parcial da função em relação a uma das variáveis representa a taxa de variação da função em relação a essa variável, mantendo as demais variáveis constantes. Portanto, as fórmulas de diferenças finitas podem ser usadas no cálculo das derivadas parciais. A ideia é simplesmente aplicar as fórmulas em cada uma das variáveis, mantendo as outras fixas. A implementação computacional é mais trabalhosa e difícil de generalizar.</p>
<p>Para mostrar como obter derivadas parciais numéricas, considere que é de interesse derivar <span class="math inline">\(f(\beta_0, \beta_1) = \sum_{i=1}^n | y_i - (\beta_0 + \beta_1 x_i) |\)</span> em relação a <span class="math inline">\(\beta_0\)</span> e <span class="math inline">\(\beta_1\)</span>. Essa função é a chamada perda absoluta e pode ser usada como uma alternativa à perda quadrática que foi usada no modelo de regressão linear. Para aproximar a derivada vamos usar a fórmula de diferença central com dois pontos. O Código em 3.12 apresenta uma função genérica para calcular a derivada via diferença central de uma função <span class="math inline">\(f(x)\)</span> qualquer em um ponto especificado. O argumento <code>fx</code> é a função a ser diferenciada, o argumento <code>pt</code> é o ponto onde a derivada deve ser calculada. Por fim, o uso dos <code>...</code> indica que a função tem outros argumentos que não são explicitamente especificados. Esses argumentos serão neste caso os argumentos da função <code>fx</code>.</p>
<p><strong>Código 3.12</strong> Implementação genérica da diferença central com dois pontos.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>dif_cen <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, pt, h, ...) {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">&lt;-</span> (<span class="fu">fx</span>(pt <span class="sc">+</span> h, ...) <span class="sc">-</span> <span class="fu">fx</span>(pt <span class="sc">-</span> h, ...))<span class="sc">/</span>( (pt <span class="sc">+</span> h) <span class="sc">-</span> (pt <span class="sc">-</span> h))</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(df)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Vamos agora implementar a função a ser derivada. Note que a função deve receber um vetor como entrada. O argumento <code>par</code> deve ser um vetor. Como argumentos extras a função precisa de <code>y</code> e <code>x1</code> para ser calculada.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(par, y, x1) {<span class="fu">sum</span> ( <span class="fu">abs</span>( y <span class="sc">-</span> (par[<span class="dv">1</span>] <span class="sc">+</span> par[<span class="dv">2</span>]<span class="sc">*</span>x1)) )}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Por ser uma função de duas variáveis independentes, o vetor gradiente terá tamanho dois. O Código #lem:gradexemplo3.13 implementa o vetor gradiente para a função perda absoluta.</p>
<p><strong>Código 3.13</strong> Aproximação via diferenças finitas para o gradiente da função perda absoluta.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>grad_fx <span class="ot">&lt;-</span> <span class="cf">function</span>(fx, par, h, ...) {</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  fbeta0 <span class="ot">&lt;-</span> <span class="cf">function</span>(beta0, beta1, y, x) <span class="fu">fx</span>(<span class="at">par =</span> <span class="fu">c</span>(beta0, beta1), <span class="at">y =</span> y, <span class="at">x =</span> x)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  fbeta1 <span class="ot">&lt;-</span> <span class="cf">function</span>(beta1, beta0, y, x) <span class="fu">fx</span>(<span class="at">par =</span> <span class="fu">c</span>(beta0, beta1), <span class="at">y =</span> y, <span class="at">x =</span> x)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>  db0 <span class="ot">&lt;-</span> <span class="fu">dif_cen</span>(<span class="at">fx =</span> fbeta0, <span class="at">pt =</span> par[<span class="dv">1</span>], <span class="at">h =</span> h, <span class="at">beta1 =</span> par[<span class="dv">2</span>], <span class="at">y =</span> y, <span class="at">x =</span> x)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  db1 <span class="ot">&lt;-</span> <span class="fu">dif_cen</span>(<span class="at">fx =</span> fbeta1, <span class="at">pt =</span> par[<span class="dv">2</span>], <span class="at">h =</span> h, <span class="at">beta0 =</span> par[<span class="dv">1</span>], <span class="at">y =</span> y, <span class="at">x =</span> x)</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">c</span>(db0, db1))</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Apenas como exemplo vamos simular um conjunto de <code>x</code> e <code>y</code> e comparar a aproximação via diferenças finitas com o gradiente obtido de forma analítica. Simulando o vetor <code>x</code> de uma distribuição uniforme no intervalo <span class="math inline">\((0,1)\)</span> e <code>y</code> de uma distribuição Normal com média <span class="math inline">\(\mu = 2 + 3 x\)</span> e desvio-padrão <span class="math inline">\(1\)</span>. Esses valores foram escolhidos de forma arbitrária e não têm nenhuma relação com o cálculo das derivadas. São apenas para criar dados artificiais.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="dv">100</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="at">mean =</span> <span class="dv">2</span> <span class="sc">+</span> <span class="dv">3</span><span class="sc">*</span>x, <span class="at">sd =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Obtendo o gradiente numericamente e comparando com a solução exata.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Solução numérica</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="fu">grad_fx</span>(<span class="at">fx =</span> fx, <span class="at">par =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>), <span class="at">h =</span> <span class="fl">0.001</span>, <span class="at">y =</span> y, <span class="at">x1 =</span> x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.000000 2.272805</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Solução exata</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="fu">sum</span>(((y <span class="sc">-</span> <span class="dv">2</span> <span class="sc">-</span> <span class="dv">3</span><span class="sc">*</span>x)<span class="sc">/</span><span class="fu">abs</span>(y <span class="sc">-</span> <span class="dv">2</span> <span class="sc">-</span><span class="dv">3</span><span class="sc">*</span>x))<span class="sc">*</span>(<span class="sc">-</span><span class="dv">1</span>)),  </span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>(((y <span class="sc">-</span> <span class="dv">2</span> <span class="sc">-</span> <span class="dv">3</span><span class="sc">*</span>x)<span class="sc">/</span><span class="fu">abs</span>(y <span class="sc">-</span> <span class="dv">2</span> <span class="sc">-</span><span class="dv">3</span><span class="sc">*</span>x))<span class="sc">*</span>(<span class="sc">-</span>x)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.000000 2.272805</code></pre>
</div>
</div>
<p>Neste caso, o gradiente analítico e numérico coincidem. Convidamos o leitor a tentar diferentes pontos para avaliação do gradiente e verificar se essa situação se repete. Conforme o número de variáveis independentes cresce, ou a ordem da derivada cresce, a implementação de tais aproximações fica mais complicada e trabalhosa. No entanto, o <code>R</code> dispõe de diversos pacotes extras que trazem implementações eficientes tanto do gradiente como do Hessiano usando as fórmulas de diferenças finitas. Em particular, o pacote <code>numDeriv</code> é uma escolha usual. Este pacote oferece as funções <code>grad()</code> e <code>hessian()</code> para obter o gradiente e o hessiano de uma função qualquer. O Código 3.14 ilustra o uso destas funções para obter o gradiente e o hessiano da função perda absoluta.</p>
<p><strong>Código 3.14</strong> Exemplo de uso do pacote <code>numDeriv</code> para obter o gradiente e o hessiano.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> fx, <span class="at">x =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>), <span class="at">y =</span> y, <span class="at">x1 =</span> x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.000000 2.272805</code></pre>
</div>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="do">## [1] 6.00 2.27</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>numDeriv<span class="sc">::</span><span class="fu">hessian</span>(<span class="at">func =</span> fx, <span class="at">x =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>), <span class="at">y =</span> y, <span class="at">x1 =</span> x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>         [,1]     [,2]
[1,] 58.91271 29.53710
[2,] 29.53710 48.86648</code></pre>
</div>
</div>
<p>Como opção <em>default</em> a função <code>grad()</code> usa o método de Richardson para aproximar a derivada via diferenças finitas. Existem outras opções mais baratas computacionalmente para mais detalhes veja <code>?grad</code>.</p>
</section>
<section id="integração-numérica" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="integração-numérica"><span class="header-section-number">3.3</span> Integração numérica</h2>
<p>O cálculo de integrais aparece com frequência em modelos estatísticos avançados. Na teoria das probabilidades integrais são fundamentais. Em algumas situações, o cálculo da integral como a antiderivada conforme discutido no Capítulo 1 não é possível. Assim, precisamos recorrer a métodos numéricos para resolver a integral de forma aproximada. Um exemplo muito comum da aplicação de métodos numéricos em probabilidades é o cálculo de probabilidades baseado na distribuição Normal. Em cursos de estatística básica, para obter probabilidades com base na curva da distribuição Normal, é comum o uso de tabelas que foram obtidas para a distribuição Normal padrão usando métodos numéricos, já que a solução analítica da área abaixo da curva não é possível. Obviamente essa solução é sub-ótima e na maioria dos softwares modernos métodos numéricos são usados para aproximar o valor de tais integrais. Para resolver uma integral de forma numérica temos pelo menos três abordagens:</p>
<ol type="1">
<li>Métodos baseados em soma finita.</li>
<li>Aproximar a função por uma outra de fácil integração.</li>
<li>Estimar o valor da integral.</li>
</ol>
<p>Vamos começar apresentando alguns métodos simples apenas para introduzir as ideias gerais e depois discutiremos os métodos mais usados em termos práticos.</p>
<section id="método-trapezoidal" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="método-trapezoidal"><span class="header-section-number">3.3.1</span> Método Trapezoidal</h3>
<p>O método trapezoidal usa uma função linear para aproximar o integrando e integra a função aproximada de forma usual. Sendo <span class="math inline">\(f(x)\)</span> o integrando pode ser aproximado por séries de Taylor da seguinte forma <span class="math display">\[f(x) \approx f(a) + (x - a) \left[ \frac{f(b) - f(a)}{ b - a} \right].\]</span></p>
<p>Integrando analiticamente essa aproximação, tem-se <span class="math display">\[\begin{eqnarray*}
  I(f) &amp; \approx&amp;  \int_a^b f(a) + (x - a)\left[ \frac{f(b) - f(a)}{ b - a} \right] dx \\
       &amp; =&amp;  f(a) (b - a) + \frac{1}{2}[f(b) - f(a)](b - a).
\end{eqnarray*}\]</span></p>
<p>Simplificando, tem-se</p>
<p><span class="math display">\[\begin{equation*}
  I(f) \approx \frac{[f(a) + f(b)]}{2} (b - a).
  \tag{3.10}
\end{equation*}\]</span> A implementação computacional é muito simples e apresentada no Código 3.15</p>
<p><strong>Código 3.15</strong> Método trapezoidal</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>trapezio <span class="ot">&lt;-</span> <span class="cf">function</span>(integrando, a, b, ...){</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  Int <span class="ot">&lt;-</span> ((<span class="fu">integrando</span>(a, ...) <span class="sc">+</span> <span class="fu">integrando</span>(b, ...))<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>(b<span class="sc">-</span>a)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(Int)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o método vamos calcular a integral <span class="math inline">\(\int_{2}^3 x^2 dx\)</span>. A solução exata é simples e dada por <span class="math display">\[\int_{2}^3 x^2 dx = \frac{x^3}{3}|_2^3 = \frac{3^3}{3} - \frac{2^3}{3} = 6.33.\]</span></p>
<p>Assim, podemos comparar a aproximação numérica com a solução exata.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="fu">trapezio</span>(<span class="at">integrando =</span> fx, <span class="at">a =</span> <span class="dv">2</span>, <span class="at">b =</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.5</code></pre>
</div>
</div>
<p>Neste caso vemos que a aproximação não foi próxima ao valor verdadeiro. Isso é porque aproximamos uma função quadrática por uma função linear. Se ao invés de aproximarmos por uma função linear aproximarmos por um polinômio a aproximação deve melhorar. Essa é a ideia do método de Simpson.</p>
</section>
<section id="método-de-simpson-13" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="método-de-simpson-13"><span class="header-section-number">3.3.2</span> Método de Simpson <span class="math inline">\(1/3\)</span></h3>
<p>No método de Simpson <span class="math inline">\(1/3\)</span> o integrando é aproximado usando um polinômio de segundo grau. Os pontos finais do polinômio são escolhidos de forma a coincidir com os limites de integração, ou seja,<span class="math inline">\(x_1 = a\)</span> e <span class="math inline">\(x_3 = b\)</span>. Por fim, é incluído um ponto central, <span class="math inline">\(x_2 = (a+b)/2\)</span>. Desta forma, o polinômio pode ser escrito na forma:</p>
<p><span class="math display">\[\begin{equation}
p(x) = \alpha + \beta(x - x_1) + \lambda(x - x_1)(x - x_2),
  \tag{3.11}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> e <span class="math inline">\(\lambda\)</span> são constantes desconhecidas.</p>
<p>Impomos a condição de que o polinômio deve passar por todos os pontos, <span class="math display">\[p(x_1) = f(x_1), p(x_2) = f(x_2) \quad \text{e} \quad p(x_3) = f(x_3).\]</span></p>
<p>Isso resulta em: <span class="math display">\[\begin{equation*}
\alpha = f(x_1), \quad \beta = [ f(x_2) - f(x_1)] / (x_2 - x_1) \quad \text{e}
\end{equation*}\]</span> <span class="math display">\[\lambda = \frac{f(x_3) - 2 f(x_2) + f(x_1)}{2(h)^2}\]</span></p>
<p>onde <span class="math inline">\(h = (b-a)/2\)</span>.</p>
<p>Agora, substituindo em simpson(3.11) e integrando <span class="math inline">\(p(x)\)</span>, obtém-se <span class="math display">\[\begin{equation*}
I = \int_{a}^{b} f(x) dx \approx \int_{a}^{b} p(x) dx = \frac{h}{3} \left[ f(a) + 4 f\left(\frac{a+b}{2}\right) + f(b) \right].
\end{equation*}\]</span></p>
<p>Neste método a integral é resolvida facilmente com apenas três avaliações da função. O Código 3.16 implementa o método de Simpson <span class="math inline">\(1/3\)</span>.</p>
<p><strong>Código 3.16</strong> Método de Simpson <span class="math inline">\(1/3\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>simpson <span class="ot">&lt;-</span> <span class="cf">function</span>(integrando, a, b, ...){</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> (b<span class="sc">-</span>a)<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  x2 <span class="ot">&lt;-</span>(a<span class="sc">+</span>b)<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> (h<span class="sc">/</span><span class="dv">3</span>)<span class="sc">*</span>(<span class="fu">integrando</span>(a,...) <span class="sc">+</span> </span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>               <span class="dv">4</span><span class="sc">*</span><span class="fu">integrando</span>(x2, ...) <span class="sc">+</span> <span class="fu">integrando</span>(b, ...))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar vamos novamente resolver <span class="math inline">\(\int_{2}^3 x^2 dx\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="fu">simpson</span>(<span class="at">integrando =</span> fx, <span class="at">a =</span> <span class="dv">2</span>, <span class="at">b =</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.333333</code></pre>
</div>
</div>
<p>Neste exemplo a solução aproximada coincide com a exata. O método de Simpson <span class="math inline">\(1/3\)</span> é assim chamado porque usa apenas três pontos para aproximar o valor da integral. Existem diversas extensões do método de Simpson que não vamos discutir neste livro. Para mais detalhes, considere as referências no final do capítulo.</p>
</section>
<section id="quadratura-gaussiana" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="quadratura-gaussiana"><span class="header-section-number">3.3.3</span> Quadratura Gaussiana</h3>
<p>Os métodos trapezoidal e de Simpson são simples e intuitivos. Porém, são de difícil generalização para funções com mais do que uma variável independente e raramente são usados em termos práticos. O método da quadratura Gaussiana é um dos métodos mais populares de integração numérica. Aplicações em modelagem estatística aparecem em modelos mistos não-lineares, análise de dados longitudinais e medidas repetidas e de forma mais geral na classe dos modelos lineares generalizados mistos. Neste livro vamos apenas apresentar as ideias gerais e mostrar como a quadratura Gaussiana pode ser facilmente implementada em <code>R</code>.</p>
<p>A ideia básica da quadratura Gaussiana é reescrever o integrando como um somatório <span class="math display">\[\begin{equation}
\int_{a}^b f(x) dx \approx \sum_{i=1}^n C_i f(x_i),
\tag{3.12}
\end{equation}\]</span> onde <span class="math inline">\(C_i\)</span> são pesos e <span class="math inline">\(x_i\)</span> são os pontos de Gauss em <span class="math inline">\([a,b]\)</span>. Por exemplo, para <span class="math inline">\(n = 2\)</span> a Equação (3.12) tem a forma: <span class="math display">\[\int_{a}^b f(x) dx \approx C_1 f(x_1) + C_2 f(x_2).\]</span> Para <span class="math inline">\(n = 3\)</span> a Equação (3.12) tem a forma: <span class="math display">\[\int_{a}^b f(x) dx \approx C_1 f(x_1) + C_2 f(x_2) + C_3f(x_3).\]</span> Os coeficientes <span class="math inline">\(C_i\)</span> e a localização dos pontos <span class="math inline">\(x_i\)</span> dependem dos valores de <span class="math inline">\(n\)</span>, <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> e são determinados de forma que o lado direito da Equação (3.12) seja igual ao lado esquerdo para funções <span class="math inline">\(f(x)\)</span> especificadas. A especificação de <span class="math inline">\(f(x)\)</span> vai depender do domínio de integração. Para cada domínio de integração temos as diferentes variações do método. Algumas variações comuns são:</p>
<ol type="1">
<li>Gauss-Legendre, Gauss-Jacobi e Gauss-Chebyshev <span class="math display">\[\int_{a}^{b} f(x) dx.\]</span></li>
<li>Gauss-Laguerre <span class="math display">\[\int_{0}^{\infty} f(x)e^{-x} dx.\]</span></li>
<li>Gauss-Hermite <span class="math display">\[\int_{-\infty}^{\infty} f(x) e^{-x^2} dx.\]</span></li>
</ol>
<p>Para exemplificar a obtenção dos coeficientes <span class="math inline">\(C_i\)</span> e dos pontos <span class="math inline">\(x_i\)</span> vamos considerar o domínio <span class="math inline">\([-1,1]\)</span> onde a quadratura de Gauss toma a forma <span class="math display">\[\int_{-1}^1 f(x) dx \approx \sum_{i=1}^n C_i f(x_i).\]</span></p>
<p>Os coeficientes <span class="math inline">\(C_i\)</span> e <span class="math inline">\(x_i\)</span> são determinados fazendo com que a Equação (3.12) seja exata quando <span class="math inline">\(f(x) = 1, x, x^2, x^3 \ldots\)</span>. O grau do polinômio depende do valor de <span class="math inline">\(n\)</span> (números de pontos de integração). Para simplificar, vamos usar <span class="math inline">\(n=2\)</span>. Neste caso, tem-se <span class="math display">\[\begin{equation}
\int_{-1}^{1} f(x) dx \approx C_1 f(x_1) + C_2 f(x_2).
   \tag{3.13}
\end{equation}\]</span></p>
<p>As quatro constantes <span class="math inline">\(C_1, C_2, x_1\)</span> e <span class="math inline">\(x_2\)</span> são determinadas fazendo a Equação (3.13) exata quando aplicada aos quatro casos: <span class="math display">\[
\begin{matrix}
\text{Caso 1} &amp;  f(x) = 1  &amp;  \int_{-1}^{1} 1 dx = 2 = C_1 + C_2 \\
\text{Caso 2} &amp;  f(x) = x &amp;   \int_{-1}^{1} x dx = 0 = C_1 x_1 + C_2 x_2 \\
\text{Caso 3} &amp;  f(x) = x^2 &amp;  \int_{-1}^{1} x^2 dx = \frac{2}{3} = C_1 x_1^2 + C_2 x_2^2  \\
\text{Caso 4} &amp;  f(x) = x^3 &amp;  \int_{-1}^{1} x^3 dx = 0 = C_1 x_1^3 + C_2 x_2^3
\end{matrix}
\]</span></p>
<p>Este é um sistema não-linear de quatro equações e quatro incógnitas com múltiplas soluções. Uma solução particular é obtida por impor que <span class="math inline">\(x_1 = -x_2\)</span>. Pelo Caso 2, implica que <span class="math inline">\(C_1 = C_2\)</span> e a solução é <span class="math display">\[C_1 = 1, \quad C_2 = 1, \quad x_1 = -\frac{1}{\sqrt{3}} \quad \text{e} \quad x_2 = \frac{1}{\sqrt{3}}.\]</span></p>
<p>Para exemplificar o uso destes valores, considere o cálculo da integral <span class="math inline">\(\int_{-1}^{1} x^2 dx\)</span>. Usando Gauss-Legendre com dois pontos de integração, tem-se <span class="math display">\[\int_{-1}^{1} x^2 dx \approx 1 \left(\frac{-1}{\sqrt{3}}\right)^2 + 1 \left(\frac{1}{\sqrt{3}}\right)^2 = \frac{2}{3}.\]</span></p>
<p>A Figura 3.8 ilustra o procedimento de integração via Gauss-Legendre.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-8" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/GaussLegendre-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.8: Ilustração do método de Gauss-Legendre.
</figcaption>
</figure>
</div>
</div>
</div>
<p>A área abaixo da curva em preto é aproximada pela área do retângulo abaixo da linha azul. Note que a base do retângulo tem tamanho <span class="math inline">\(1 - (-1) = 2\)</span>. Como a altura é <span class="math inline">\((1/\sqrt{3})^2\)</span>. Temos que a área do retângulo é <span class="math inline">\(2 \cdot (1/\sqrt{3})^2 = 2/3.\)</span></p>
<p>Quando <span class="math inline">\(f(x)\)</span> é uma função do tipo <span class="math inline">\(f(x) = 1\)</span>, <span class="math inline">\(f(x) = x\)</span>, <span class="math inline">\(f(x) = x^2\)</span> ou <span class="math inline">\(f(x) = x^3\)</span> ou qualquer combinação linear destas o método de Gauss-Legendre é exato. Caso contrário o procedimento fornece uma aproximação. Considere <span class="math inline">\(f(x) = cos(x)\)</span> o valor exato é <span class="math display">\[\int_{-1}^{1} cos(x) dx = sen(x)|_{-1}^{1} = sen(1) - sen(-1) = 1.682841.\]</span></p>
<p>Usando Quadratura de Gauss-Legendre com <span class="math inline">\(n = 2\)</span>, tem-se <span class="math display">\[\int_{-1}^{1} cos(x) dx \approx cos(-1/\sqrt{3}) + cos(1/\sqrt{3}) = 1.675823.\]</span></p>
<p>Uma aproximação bastante razoável e fácil de obter. A Figura 3.9 mostra como a aproximação de Gauss-Legendre funciona neste caso.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-9" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/coseno-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.9: Ilustração do método de Gauss-Legendre para a integral do coseno.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Neste caso, a área abaixo da curva em preto é aproximada pela área do retângulo em vermelho. Veja como a altura do retângulo é regulada para que a área seja o mais próximo possível da área abaixo da curva em preto.</p>
<p>Em todos os métodos de quadratura Gaussiana o número de pontos de integração controla a precisão da aproximação. Nós obtemos os pesos e pontos de integração para o caso mais simples, Gauss-Legendre com dois pontos de integração. No entanto, procedimentos similares são possíveis para um número arbitrário de pontos de integração e também para os outros métodos.</p>
<p>Em <code>R</code> o pacote <code>pracma</code> fornece uma implementação eficiente para obter os pesos e pontos de integração para os principais tipos de quadratura Gaussiana. O Código 3.17 mostra o uso do método de Gauss-Legendre com dois pontos de integração.</p>
<p><strong>Código 3.17</strong> Ilustração do uso do pacote <code>pracma</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(pracma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: pracma</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'pracma'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked _by_ '.GlobalEnv':

    newton</code></pre>
</div>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gaussLegendre</span>(<span class="at">n =</span> <span class="dv">2</span>, <span class="at">a =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">b =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$x
[1] -0.5773503  0.5773503

$w
[1] 1 1</code></pre>
</div>
</div>
<p>Baseado nos pontos e pesos de integração fornecidos pelo pacote <code>pracma</code> é fácil construir funções genéricas para integração numérica via quadratura Gaussiana. O Código 3.18 apresenta uma função genérica para o cálculo de integrais via o método de quadratura de Gauss-Legendre.</p>
<p><strong>Código 3.18</strong> Quadratura de Gauss-Legendre.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>gauss_legendre <span class="ot">&lt;-</span> <span class="cf">function</span>(integrando, n_pontos, a, b, ...){</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  pontos <span class="ot">&lt;-</span> <span class="fu">gaussLegendre</span>(n_pontos, <span class="at">a =</span> a, <span class="at">b =</span> b)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="fu">sum</span>(pontos<span class="sc">$</span>w<span class="sc">*</span><span class="fu">integrando</span>(pontos<span class="sc">$</span>x,...))</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Vamos resolver novamente a integral <span class="math inline">\(\int_{-1}^{1} cos(x) dx\)</span>, porém agora usando dois e dez pontos de integração.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 2</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_legendre</span>(<span class="at">integrando =</span> cos, <span class="at">n_pontos =</span> <span class="dv">2</span>, <span class="at">a =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">b =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.675824</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 10</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_legendre</span>(<span class="at">integrando =</span> cos, <span class="at">n_pontos =</span> <span class="dv">10</span>, <span class="at">a =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">b =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.682942</code></pre>
</div>
</div>
<p>A quadratura de Gauss-Laguerre resolve integrais do tipo:<br> <span class="math display">\[\int_{0}^{\infty} e^{-x} f(x) dx.\]</span></p>
<p>Novamente, a integral é aproximada por uma soma ponderada <span class="math display">\[\int_{0}^{\infty} e^{-x} f(x) dx \approx \sum_{i=1}^n w_i f(x_i).\]</span></p>
<p>Os pesos e pontos de integração são obtidos de forma similar ao caso de Gauss-Legendre, porém baseado no polinômio de Laguerre. A implementação computacional é análoga ao caso de Gauss-Legendre e apresentada no Código 3.19.</p>
<p><strong>Código 3.19</strong> Quadratura de Gauss-Laguerre.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>gauss_laguerre <span class="ot">&lt;-</span> <span class="cf">function</span>(integrando, n.pontos, ...){</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>  pontos <span class="ot">&lt;-</span> <span class="fu">gaussLaguerre</span>(n.pontos)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="fu">sum</span>(pontos<span class="sc">$</span>w<span class="sc">*</span><span class="fu">integrando</span>(pontos<span class="sc">$</span>x,...)</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>                  <span class="sc">/</span><span class="fu">exp</span>(<span class="sc">-</span>pontos<span class="sc">$</span>x))</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Como exemplo, considere resolver a integral <span class="math inline">\(\int_{0}^\infty \lambda \exp(-\lambda x) dx\)</span>, cuja solução exata é <span class="math inline">\(1\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x, lambda) lambda<span class="sc">*</span><span class="fu">exp</span>(<span class="sc">-</span>lambda<span class="sc">*</span>x)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 2</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_laguerre</span>(<span class="at">integrando =</span> fx, <span class="at">n.pontos =</span> <span class="dv">2</span>, <span class="at">lambda =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.04381233</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 10</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_laguerre</span>(<span class="at">integrando =</span> fx, <span class="at">n.pontos =</span> <span class="dv">10</span>, <span class="at">lambda =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.8981046</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 100</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_laguerre</span>(<span class="at">integrando =</span> fx, <span class="at">n.pontos =</span> <span class="dv">100</span>, <span class="at">lambda =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Note que neste caso foram necessários <span class="math inline">\(100\)</span> pontos de integração para chegar a uma solução próxima a exata.</p>
<p>A quadratura de Gauss-Hermite resolve integrais do tipo: <span class="math display">\[\int_{-\infty}^{\infty} e^{-x^2} f(x) dx.\]</span></p>
<p>Novamente, a integral é aproximada por uma soma ponderada <span class="math display">\[\int_{-\infty}^{\infty} e^{-x^2} f(x) dx \approx \sum_{i=1}^n w_i f(x_i).\]</span></p>
<p>Os pesos e pontos de integração são obtidos de forma similar ao caso de Gauss-Legendre, porém baseado no polinômio de Hermite. A implementação computacional é similar ao caso de Gauss-Legendre e Gauss-Laguerre e apresentada no Código 3.20.</p>
<p><strong>Código 3.20</strong> Quadratura de Gauss-Hermite.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>gauss_hermite <span class="ot">&lt;-</span> <span class="cf">function</span>(integrando, n.pontos, ...){</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>  pontos <span class="ot">&lt;-</span> <span class="fu">gaussHermite</span>(n.pontos)</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="fu">sum</span>(pontos<span class="sc">$</span>w<span class="sc">*</span><span class="fu">integrando</span>(pontos<span class="sc">$</span>x,...)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>                  <span class="sc">/</span><span class="fu">exp</span>(<span class="sc">-</span>pontos<span class="sc">$</span>x<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso do método considere resolver a integral <span class="math inline">\(\int_{-\infty}^\infty \frac{1}{\sqrt{2 \pi}} \exp \left( -\frac{1}{2} y^2 \right) dy.\)</span> Essa integral corresponde a função de densidade probabilidade da distribuição Normal padrão e a solução analítica apesar de disponível (<span class="math inline">\(=1\)</span>) é dificil de obter.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 2</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_hermite</span>(<span class="at">integrando =</span> dnorm, <span class="at">n.pontos =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9079431</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 10</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_hermite</span>(<span class="at">integrando =</span> dnorm, <span class="at">n.pontos =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9999876</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 100</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gauss_hermite</span>(<span class="at">integrando =</span> dnorm, <span class="at">n.pontos =</span> <span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
</section>
<section id="quadratura-de-gauss-hermite-adaptativa" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="quadratura-de-gauss-hermite-adaptativa"><span class="header-section-number">3.3.4</span> Quadratura de Gauss-Hermite adaptativa</h3>
<p>A quadratura de Gauss-Hermite apresenta duas grandes limitações:</p>
<ol type="1">
<li>Os pontos são escolhidos baseados no polinômio de Hermite, ignorando a função a ser integrada.</li>
<li>O número de pontos necessários para a integração cresce como uma potência da dimensão da integral. Por exemplo, <span class="math inline">\(20\)</span> pontos em uma dimensão demanda <span class="math inline">\(20^2 = 400\)</span> pontos em duas dimensões e assim por diante.</li>
</ol>
<p>Essas duas limitações levaram ao desenvolvimento do método de quadratura de Gauss adaptativa. A ideia é simplesmente espalhar os pontos de forma mais inteligente para diminuir o número de pontos necessários para aproximar a integral. A Figura 3.10 ilustra as limitações da quadratura Gaussiana de Gauss-Hermite em uma dimensão.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-10" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/limiteGauss-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.10: Espalhamento dos pontos de integração: Quadratura Gaussiana de Gauss-Hermite.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Na Figura 3.10(A) temos vinte pontos de integração de Gauss-Hermite. Note que, para aproximar a integral traçada pela linha preta cheia, os pontos estão bem colocados. No entanto, para aproximar a integral abaixo da curva em pontilhado os pontos estão mal colocados. Assim, na Figura 3.10(B) aumentamos o número de pontos de integração para <span class="math inline">\(100\)</span>. Neste caso temos pontos para integrar as duas funções, porém também existe um desperdício em relação ao número de avaliações da função. Uma vez que pela má colocação dos pontos estaremos avaliando a função muitas vezes em regiões onde a área é muito próxima de zero. Assim, fica claro que um melhor espalhamento dos pontos de integração é importante para a eficiência dos métodos de quadratura Gaussiana.</p>
<p>No método de Gauss-Hermite adaptativo os pontos de integração são centrados e escalonados como se <span class="math inline">\(f(x) e^{-x^2}\)</span> fosse a distribuição Gaussiana. A média da aproximação Gaussiana será a moda <span class="math inline">\(\hat{x}\)</span> de <span class="math inline">\(ln[f(x)e^{-x^2}]\)</span>. A variância da aproximação Gaussiana será <span class="math display">\[\begin{bmatrix}
- \frac{\partial^2}{\partial x^2} ln[f(x)e^{-x^2}]|_{x=\hat{x}}
\end{bmatrix}^{-1}.\]</span></p>
<p>Portanto, os novos pontos de integração adaptados serão dados por <span class="math display">\[x_i^+ = \hat{x} + \begin{bmatrix}
- \frac{\partial^2}{\partial x^2} ln[f(x)e^{-x^2}]|_{x=\hat{x}}
\end{bmatrix}^{-1/2} x_i\]</span></p>
<p>com correspondentes pesos, <span class="math display">\[w_i^+ = \begin{bmatrix}
- \frac{\partial^2}{\partial x^2} ln[f(x)e^{-x^2}]|_{x=\hat{x}}
\end{bmatrix}^{-1/2} \frac{e^{x_i^+}}{e^{-x_i}} w_i.\]</span></p>
<p>Como antes, a integral é aproximada por <span class="math display">\[\int f(x) e^{-x^2} dx \approx \sum_{i=1}^n w_i^+ f(x_i^+).\]</span></p>
<p>O principal desafio que surge no uso do método de Gauss-Hermite adaptativo é a necessidade de encontrar a moda e o hessiano de <span class="math inline">\(ln[f(x)e^{-x^2}]\)</span>. Na maioria dos casos uma solução analítica não estará disponível. Assim, a abordagem padrão é maximizar <span class="math inline">\(ln[f(x)e^{-x^2}]\)</span> usando algum método de otimização numérica, conforme os que serão vistos na próxima seção. Outra abordagem é transformar o problema de maximização em um problema de resolução de sistema de equações não-lineares e proceder a solução usando o método de Newton ou gradiente descendente. Note que para isso precisamos obter a primeira derivada de <span class="math inline">\(ln[f(x)e^{-x^2}]\)</span> e igualar a zero. Essa derivada pode ser obtida de forma analítica ou numérica, conforme discutido anteriormente.</p>
</section>
<section id="aproximação-de-laplace" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="aproximação-de-laplace"><span class="header-section-number">3.3.5</span> Aproximação de Laplace</h3>
<p>Um caso especial do método de Gauss-Hermite adaptativo é a aproximação de Laplace que corresponde a usar o método Gauss-Hermite adaptativo com apenas um ponto de integração. Denotando <span class="math inline">\(f(x)e^{-x^2}\)</span> por <span class="math inline">\(Q(x)\)</span> e como <span class="math inline">\(n=1\)</span>, <span class="math inline">\(x_1 = 0\)</span> e <span class="math inline">\(w_1 = 1\)</span>, obtemos <span class="math inline">\(x_1^+ = \hat{x}\)</span>. Portanto, os pesos de integração são iguais a <span class="math display">\[w_1^+ = | Q''(\hat{x}) |^{-1/2} \frac{e^{-\hat{x}}}{e^{-0}} = (2\pi)^{n/2} |Q''(\hat{x})|^{-1/2} \frac{e^{Q(\hat{x})}}{f(\hat{x})}.\]</span></p>
<p>Assim, a aproximação fica dada por <span class="math display">\[\begin{align*}
  \int f(x) e^{-x^2} dx &amp; = \int e^{Q(x)} dx \\
        &amp; \approx w_1^+ f(x_1^+) = (2\pi)^{n/2} |Q''(\hat{x})|^{-1/2} e^{Q(\hat{x})}.
\end{align*}\]</span></p>
<p>O Código 3.21 fornece uma implementação genérica da aproximação de Laplace. Nesta implementação estamos usando a função <code>optim()</code> que implementa diferentes métodos de otimização numérica para encontrar o máximo e o hessiano do integrando.</p>
<p><strong>Código 3.21</strong> Aproximação de Laplace.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>laplace <span class="ot">&lt;-</span> <span class="cf">function</span>(funcao, otimizador,n.dim, ...){</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">999999</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>  inicial <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>,n.dim)</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> <span class="fu">try</span>(<span class="fu">optim</span>(inicial, funcao,..., <span class="at">method=</span>otimizador, </span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>              <span class="at">hessian=</span><span class="cn">TRUE</span>, <span class="at">control=</span><span class="fu">list</span>(<span class="at">fnscale=</span><span class="sc">-</span><span class="dv">1</span>)))</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">class</span>(temp) <span class="sc">!=</span> <span class="st">"try-error"</span>){</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="fu">exp</span>(temp<span class="sc">$</span>value) <span class="sc">*</span> (<span class="fu">exp</span>((n.dim<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span><span class="fu">log</span>(<span class="dv">2</span><span class="sc">*</span>pi) <span class="sc">-</span> </span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>                  <span class="fl">0.5</span><span class="sc">*</span><span class="fu">determinant</span>(<span class="sc">-</span>temp<span class="sc">$</span>hessian)<span class="sc">$</span>modulus))}</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para exemplificar o uso do método vamos resolver a seguinte integral <span class="math inline">\(\int_{-\infty}^\infty \frac{1}{\sqrt{2 \pi}} \exp \left( -\frac{1}{2} y^2 \right) dy\)</span> que corresponde a função densidade probabilidade da distribuição Normal padrão e portanto, tal integral deve ser igual a <span class="math inline">\(1\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="fu">laplace</span>(dnorm, <span class="at">otimizador =</span> <span class="st">"BFGS"</span>, <span class="at">n.dim =</span> <span class="dv">1</span>, <span class="at">log =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1
attr(,"logarithm")
[1] TRUE</code></pre>
</div>
</div>
</section>
<section id="método-de-monte-carlo" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="método-de-monte-carlo"><span class="header-section-number">3.3.6</span> Método de Monte Carlo</h3>
<p>O método de Monte Carlo é um método estatístico para a resolução de integrais. A ideia é tratar a integral como uma quantidade desconhecida da qual podemos retirar amostras para então estimar o valor da integral como uma média simples. Em outras palavras o objetivo é estimar o valor da integral de uma função <span class="math inline">\(f(x)\)</span> em algum domínio <span class="math inline">\(D\)</span> qualquer, em notação temos</p>
<p><span class="math display">\[\begin{equation}
I = \int_D f(x) dx.
  \tag{3.14}
\end{equation}\]</span></p>
<p>Seja <span class="math inline">\(p(x)\)</span> uma função densidade probabilidade cujo domínio coincide com <span class="math inline">\(D\)</span>. Então, a integral em (3.14) é equivalente a <span class="math display">\[I = \int_D \frac{f(x)}{p(x)} p(x) dx.\]</span></p>
<p>Que por sua vez corresponde a <span class="math inline">\(E\left( \frac{f(x)}{p(x)} \right)\)</span>. Assim, tendo valores amostrais <span class="math inline">\(x\)</span> de <span class="math inline">\(p(x)\)</span> nos permite calcular a razão <span class="math inline">\(\frac{f(x)}{p(x)}\)</span> e por fim a esperança é aproximada usando a média amostral. Obviamente quanto maior a amostra de <span class="math inline">\(x\)</span> melhor é a precisão do método. O algoritmo de Monte Carlo para resolução de uma integral pode ser resumido da seguinte forma:</p>
<ol type="1">
<li>Gere números aleatórios de <span class="math inline">\(p(x)\)</span>;</li>
<li>Calcule <span class="math inline">\(m_i = f(x_i)/p(x_i)\)</span> para cada amostra, <span class="math inline">\(i = 1, \ldots, n\)</span>. 3, Calcule a média <span class="math inline">\(\sum_{i=1}^n \frac{m_i}{n}\)</span>.</li>
</ol>
<p>Para <span class="math inline">\(D = \Re\)</span> podemos usar a distribuição Normal como <span class="math inline">\(p(x)\)</span> e uma implementação genérica do método de Monte Carlo é apresentada no Código 3.22.</p>
<p><strong>Código 3.22</strong> Método de Monte Carlo.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>monte.carlo <span class="ot">&lt;-</span> <span class="cf">function</span>(funcao, n.pontos, ...) { </span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>  pontos <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n.pontos) </span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>  norma <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(pontos) </span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>  integral <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">funcao</span>(pontos,...)<span class="sc">/</span>norma) </span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(integral)</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Integrando novamente a densidade Normal, agora usando o método de Monte Carlo.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Integrando a Normal padrão</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="fu">monte.carlo</span>(<span class="at">funcao =</span> dnorm, <span class="at">n.pontos =</span> <span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
</section>
<section id="função-do-r-para-integração-numérica" class="level3" data-number="3.3.7">
<h3 data-number="3.3.7" class="anchored" data-anchor-id="função-do-r-para-integração-numérica"><span class="header-section-number">3.3.7</span> Função do <code>R</code> para integração numérica</h3>
<p>O <code>R</code> tem uma função nativa para a resolução de integrais: a <code>integrate()</code>. O método implementado depende do domínio de integração, mas é sempre uma variação do método de quadratura adaptativa. O uso da função é limitado a funções de uma variável independente. O Código 3.23 ilustra o uso da função <code>integrate()</code> na resolução de duas integrais.</p>
<p><strong>Código 3.23</strong> Uso da função <code>integrate()</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Integral da densidade Normal padrão</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="fu">integrate</span>(<span class="at">f =</span> dnorm, <span class="at">lower =</span> <span class="sc">-</span><span class="cn">Inf</span>, <span class="at">upper =</span> <span class="cn">Inf</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1 with absolute error &lt; 9.4e-05</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x)x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="fu">integrate</span>(<span class="at">f =</span> fx, <span class="at">lower =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">upper =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>0.6666667 with absolute error &lt; 7.4e-15</code></pre>
</div>
</div>
<p>Na literatura de modelos estatísticos, a integração numérica é fundamental para a classe dos modelos mistos não-Gaussianos. Neste contexto, o método de Gauss-Hermite é muito popular. Porém, o método de Gauss-Hermite é limitado a integrais de baixa dimensão (&lt; 5$). Trata-se de um método computacionalmente caro. Por esse motivo os estatísticos desenvolveram o método de Gauss-Hermite adaptativo que é menos caro computacionalmente, porém ainda é muito limitado em termos da dimensão da integral que consegue resolver. Por fim, a aproximação de Laplace tem despontado como o método de escolha por ser mais rápido computacionalmente e poder lidar com integrais de alta dimensão. A principal limitação da aproximação de Laplace é que ela é acurada apenas para integrandos simétricos. Por fim, a integração Monte Carlo é um método muito simples que pode, pelo menos em teoria, lidar com integrais de alta dimensão. Em termos práticos sua implementação é extremamente cara computacionalmente e difícil de implementar de forma genérica.</p>
</section>
</section>
<section id="otimização" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="otimização"><span class="header-section-number">3.4</span> Otimização</h2>
<p>Otimização é uma grande área da matemática com aplicações que vão desde a área da saúde até a indústria. Nesta subseção vamos ver apenas uma breve introdução aos métodos de otimização. De forma geral, os métodos de otimização partem de um modelo matemático rigoroso para determinar a solução mais eficiente para um dado problema.</p>
<p>Para usar os métodos de otimização precisamos identificar um objetivo. Isso envolve criar uma medida que mensure a performance. Por exemplo: rendimento, tempo, custo, total de vendas, entre outros. A ideia é resumir o problema a uma quantidade ou combinação de quantidades que possam ser representadas por um número. Lembrando do modelo de regressão linear múltipla, a função perda quadrática resumia o nosso objetivo, encontrar <span class="math inline">\(\hat{\beta}_0\)</span> e <span class="math inline">\(\hat{\beta}_1\)</span> que minimizam a perda implicada em usar o modelo ao invés dos dados observados. Até aqui falamos apenas da perda quadrática, mas existe uma infinidade de outras opções que seguem a mesma ideia. Para motivar a discussão sobre métodos de otimização, vamos voltar ao problema de redução de dados discutido na seção &lt;a href=“CDI.html#RD1.2.5. Só que ao invés de considerar apenas a perda quadrática vamos considerar outras funções perda, como apresentado abaixo:</p>
<ol type="1">
<li>Perda quadrática: <span class="math inline">\(\sum_{i=1}^n (y_i - \mu)^2\)</span>.</li>
<li>Perda absoluta: <span class="math inline">\(\sum_{i=1}^n |y_i - \mu|\)</span>.</li>
<li>Perda minimax: Minimize <span class="math inline">\(max(|y_i - \mu|)\)</span>.</li>
</ol>
<p>Dado um conjunto de observações <span class="math inline">\(y_i\)</span> queremos resumir a informação por meio de apenas um número que chamaremos de <span class="math inline">\(\mu\)</span>. A ideia é usar <span class="math inline">\(\mu\)</span> que minimize alguma função perda. Podemos facilmente fazer um gráfico de cada função perda para ver o seu comportamento. A Figura 3.11 apresenta o gráfico das funções perda quadrática, valor absoluto e minmax para um conjunto de dados com <span class="math inline">\(100\)</span> observações de <span class="math inline">\(y_i\)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-11" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/fcperda-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.11: Gráficos das funções perda quadrática, absoluto e minmax.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Note que a função perda quadrática é muito suscetível a valores extremos. Uma vez que ela eleva as diferenças ao quadrado, um valor discrepante tem grande influência no valor de <span class="math inline">\(\mu\)</span>. Por outro lado, a função perda absoluta não é tão suscetível a valores discrepantes. Por fim, a perda minmax busca minimizar apenas a maior perda. Sendo portanto uma medida bastante conservadora, no sentido de apresentar valores de perda reduzido (veja as escalas dos eixos <span class="math inline">\(y\)</span> em cada gráfico).</p>
<p>Seja qual for a medida escolhida, o problema se resume em encontrar o valor, digamos, <span class="math inline">\(\hat{\mu}\)</span> que minimiza cada uma destas funções perda. Assim, temos claramente um problema de otimização. Este tipo de construção é muito comum em estatística e ciência de dados. Basta você entender que <span class="math inline">\(\mu\)</span> pode ser substituído por um modelo tão complexo quanto necessário, variando desde o mais ingênuo modelo de regressão linear simples até redes neurais convolucionais com múltiplas camadas de milhões de parâmetros. A ideia continua a mesma, minimizar a distância entre os dados e o modelo representado em <span class="math inline">\(\mu\)</span>.</p>
<p>Os problemas de otimização são classificados de acordo com o tipo de função objetivo. Nos problemas chamados de <strong>programação linear (LP)</strong> tanto a função objetivo como as restrições são lineares, <span class="math display">\[\underset{\boldsymbol{y}}{\mathrm{min}} \quad \boldsymbol{c}^{\top} \boldsymbol{y}, \quad \text{sujeito a} \quad \boldsymbol{A} \boldsymbol{y} \leq \boldsymbol{b} \quad \text{e} \quad \boldsymbol{y} \geq 0.\]</span></p>
<p>Nos problemas chamados de <strong>programação quadrática (QP)</strong> a função objetivo é quadrática, mas as restrições ainda são lineares, <span class="math display">\[\underset{\boldsymbol{y}}{\mathrm{min}} \quad \boldsymbol{y}^{\top} \boldsymbol{Q} \boldsymbol{y} + \boldsymbol{c}^{\top} \boldsymbol{y}, \quad \text{sujeito a} \quad \boldsymbol{A} \boldsymbol{y} \leq \boldsymbol{b} \quad \text{e} \boldsymbol{y} \geq 0.\]</span></p>
<p>Por fim, a classe mais geral de problemas são chamados de <strong>programação não-linear (NLP)</strong>, onde a função objetivo ou ao menos uma restrição é não linear.</p>
<p>Cada classe de problemas tem seus próprios métodos de solução. Em <code>R</code> temos pacotes específicos para cada tipo de problema. Além disso, é comum também distinguir se o problema tem ou não restrições. Quando o problema tem restrição é chamado de otimização restrita. Tais restrições podem ser de igualdades ou desigualdades.</p>
<p>A Tabela 3.1 apresenta um resumo dos principais pacotes <code>R</code> e o tipo de problemas de otimização que eles resolvem.</p>
<table class="table">
<caption>Tabela 3.1: Principais pacotes e suas funções por tipo de problemas de otimização. {#table01}</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo de problema</th>
<th style="text-align: left;">Pacote</th>
<th style="text-align: left;">Função</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Propósito geral (1 dim)</td>
<td style="text-align: left;">Built in</td>
<td style="text-align: left;">optimize(…)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Propósito geral (n dim)</td>
<td style="text-align: left;">Built in</td>
<td style="text-align: left;">optim(…)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Programação Linear</td>
<td style="text-align: left;">lpSolve</td>
<td style="text-align: left;">lp(…)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Programação quadrática</td>
<td style="text-align: left;">quadprog</td>
<td style="text-align: left;">solve.QP(…)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Programação não-linear</td>
<td style="text-align: left;">optimize</td>
<td style="text-align: left;">optimize(…)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Programação não-linear</td>
<td style="text-align: left;">optimx</td>
<td style="text-align: left;">optimx(…)</td>
</tr>
</tbody>
</table>
<p>Além dos pacotes mencionados na Tabela #tab:otimpacote3.1 existe uma infinidade de outros pacotes com os mais diversos algoritmos implementados em <code>R</code>. Para uma lista completa o leitor deve consultar o <em><a href="https://cran.r-project.org/web/views/Optimization.html">Task View - Optimization and Mathematical programming</a></em>.</p>
<p>Em geral, as funções que implementam os diferentes algoritmos de otimização em <code>R</code> seguem um padrão. A função <code>optim()</code> é provavelmente a mais popular para problemas de programação não-linear. O Código 3.24 apresenta os seus principais argumentos.</p>
<p><strong>Código 3.24</strong> Argumentos da função <code>optim()</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(optim)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>function (par, fn, gr = NULL, ..., method = c("Nelder-Mead", 
    "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), lower = -Inf, 
    upper = Inf, control = list(), hessian = FALSE) 
NULL</code></pre>
</div>
</div>
<p>O mínimo que um otimizador numérico precisa para trabalhar é de valores iniciais (argumento <code>par</code>) e a função a ser otimizada (argumento <code>fn</code>). Como veremos, existem diversos algoritmos, alguns precisam do gradiente da função a ser otimizada (argumento <code>gr</code>), porém ter o gradiente não é obrigatório para a maioria dos algoritmos, uma vez que o gradiente pode ser obtido numericamente. Alguns algoritmos permitem restringir o campo de busca da solução informando um valor mínimo (<code>lower</code>) e máximo (<code>upper</code>) de busca. Por fim, funções genéricas como a <code>optim()</code> apresentam um argumento <code>method</code> que permite usar diferentes algoritmos com a mesma chamada geral.</p>
<p>Para exemplificar o uso de um otimizador genérico, vamos considerar o problema de redução de dados usando as funções perda quadrática, absoluta e minmax. Como este é um problema unidimensional, a função recomendada é a <code>optimize()</code>. O primeiro passo é implementar cada uma das funções perda, conforme o Código 3.25.</p>
<p><strong>Código 3.25</strong> Funções perda quadrática, absoluta e minmax.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda quadrática</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>perda_quad <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, y) { <span class="fu">sum</span>((y<span class="sc">-</span>mu)<span class="sc">^</span><span class="dv">2</span>) }</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda absoluta</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>perda_abs <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, y) { <span class="fu">sum</span>(<span class="fu">abs</span>(y<span class="sc">-</span>mu)) }</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda minmax</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>perda_minmax <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, y) { <span class="fu">max</span>(<span class="fu">abs</span>(y<span class="sc">-</span>mu)) }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Apenas para a ilustração vamos simular um conjunto de <span class="math inline">\(100\)</span> valores, seguindo um modelo de Poisson com média <span class="math inline">\(3\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rpois</span>(<span class="dv">100</span>, <span class="at">lambda =</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Agora usamos o otimizador numérico para encontrar <span class="math inline">\(\hat{\mu}\)</span> baseado em cada uma das funções perda.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda quadrática</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>fit_quad <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> perda_quad, <span class="at">interval =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">20</span>), <span class="at">y =</span> y)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda absoluta</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>fit_abs <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> perda_abs, <span class="at">interval =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">20</span>), <span class="at">y =</span> y)</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Perda minmax</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>fit_minmax <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> perda_minmax, <span class="at">interval =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">20</span>), <span class="at">y =</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-12" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/perdagraf-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.12: 3.12: Ilustração das soluções obtidos pelas funções perda quadrática, absoluta e minmax.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Conforme já tínhamos obtido, a perda quadrática é minimizada pela média amostral, enquanto que a perda absoluta resulta na mediana amostral. A perda minmax é uma função alternativa usada quando quer-se minimizar grandes discrepâncias entre o modelo e os dados.</p>
<p>Em termos operacionais, usar o otimizador numérico foi muito mais fácil do que proceder com o uso de derivadas seguida pela solução de um sistema de equações. Principalmente no caso da perda minmax o trabalho para obter uma solução analítica é oneroso. Note que não foi necessário fazer nenhum cálculo, seja de derivada ou solução de equações. O uso de otimizadores numéricos parece ser a solução para quem não gosta de matemática. Porém não se engane, tem muita matemática acontecendo por trás da função otimizadora. Nas próximas seções, vamos dar uma noção do tipo de algoritmo usado para resolver cada um dos tipos de problemas de otimização: linear, quadrática e não-linear. Sendo que a maior ênfase será a problemas de otimização não-linear.</p>
<section id="programação-linear" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="programação-linear"><span class="header-section-number">3.4.1</span> Programação linear</h3>
<p>Um problema de otimização é linear se a função objetivo e as restrições são lineares. Em termos de notação matemática, temos <span class="math display">\[\underset{\boldsymbol{x}}{\mathrm{min}} \begin{bmatrix}
c_1 \\
c_2 \\
\vdots \\
c_n
\end{bmatrix}^\top
\begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix} \quad \text{s.t}
\begin{bmatrix}
a_{11} &amp;  a_{12} &amp;  \ldots  &amp;  a_{1n} \\
a_{21} &amp;  a_{22} &amp;   \ldots &amp;  a_{2n} \\
\vdots &amp;  \ddots  &amp;  \ddots &amp;  \vdots \\
a_{m1} &amp;  a_{m2} &amp;  \ldots  &amp;  a_{mn}
\end{bmatrix} \begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix} \geq
\begin{bmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n
\end{bmatrix}, \quad
\begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix} \geq 0.\]</span></p>
<p>Alternativamente, podemos usar uma notação mais compacta <span class="math display">\[\begin{eqnarray*}
\underset{\boldsymbol{x}}{\mathrm{min}} \boldsymbol{c}^{\top} \boldsymbol{x} &amp; =&amp;  \underset{\boldsymbol{x}}{\mathrm{min}} \quad c_1 x_1 + c_2 x_2 + \ldots + c_n x_n \\
&amp; \text{s.t}&amp;  \quad \boldsymbol{A} \boldsymbol{x} \geq \boldsymbol{b}, \boldsymbol{x} \geq 0.
\end{eqnarray*}\]</span></p>
<p>Para materializar o problema vamos fazer um exemplo. Considere que uma empresa fabrica dois tipos de produtos. O produto A é vendido por R$ 25 e o produto B é vendido por R$ 20. Existem algumas restrições para a produção, por exemplo o produto A precisa de 20 u.p (unidades de produção) e o produto B precisa de 12 u.p. Para um dia de trabalho a empresa dispõe de 1800 u.p. Uma outra restrição é a questão do tempo de produção. Para produzir tanto o produto A como o B a empresa gasta <span class="math inline">\(1/15\)</span> hrs. Lembrando que o dia de trabalho tem 8 horas. Note que a empresa pode escolher quanto vai produzir de cada produto. Assumindo que todos os produtos fabricados serão vendidos, o objetivo é maximizar o lucro total. Para resumir o problema, temos</p>
<ul>
<li>Objetivo: maximizar o lucro total.
<ul>
<li>Produtos A e B são vendidos por R$ 25 e R$ 20.</li>
</ul></li>
<li>Restrição de recursos
<ul>
<li>O produto A precisa de 20 u.p e o produto B precisa 12 u.p.</li>
<li>Apenas 1800 u.p estão disponíveis por dia.</li>
</ul></li>
<li>Restrição de tempo
<ul>
<li>Produtos A e B demoram <span class="math inline">\(1/15\)</span> hrs para produzir.</li>
<li>Um dia de trabalho tem 8 hrs.</li>
</ul></li>
</ul>
<p>Temos um problema prático. Agora precisamos estabelecer um modelo matemático rigoroso que possa ser resolvido usando alguma das técnicas de otimização. Esta etapa é chamada de <strong>formulação do problema</strong>.</p>
<p>Primeiro, denote <span class="math inline">\(x_1\)</span> e <span class="math inline">\(x_2\)</span> o número de itens A e B produzidos. O objetivo é maximizar o total de vendas, assim o lucro total será dado por <span class="math display">\[\underset{\boldsymbol{x_1,x_2}}{\mathrm{max}}\quad 25 x_1 + 20 x_2.\]</span></p>
<p>Porém, temos diversas restrições com relação a recursos e tempo de produção. <span class="math display">\[\begin{matrix}
20x_1 + 12x_2 \leq 1800 \\
\frac{1}{15}x_1 + \frac{1}{15}x_2 \leq 8
\end{matrix}.\]</span></p>
<p>Reescrevendo as restrições em forma matricial. <span class="math display">\[\underset{\boldsymbol{A}}{\underbrace{\begin{bmatrix}
20 &amp;  12\\
\frac{1}{15} &amp;  \frac{1}{15}
\end{bmatrix}}}
\underset{\boldsymbol{x}}{\underbrace{\begin{bmatrix}
x_1\\
x_2
\end{bmatrix}}} \leq
\underset{\boldsymbol{b}}{\underbrace{\begin{bmatrix}
1800\\
8
\end{bmatrix}}}.\]</span></p>
<p>O problema está formulado, agora precisamos resolvê-lo. Para um problema simples como este, apenas pelo exemplo podemos usar a chamada solução força bruta. Que consiste simplesmente em tentar todas as possibilidades possíveis para um certo conjunto de <span class="math inline">\(x_1\)</span> e <span class="math inline">\(x_2\)</span> e depois verificar quais atendem as restrições do problema e selecionar a melhor. Vamos começar implementando essa solução ingênua.</p>
<p>Primeiro vamos criar uma sequência de possíveis valores para <span class="math inline">\(x_1\)</span> e <span class="math inline">\(x_2\)</span>. Depois combiná-las usando a função <code>expand.grid()</code>. Por fim, criamos uma função genérica para dado uma vetor de entrada com <span class="math inline">\(x = (x_1, x_2)\)</span> seja retornado o lucro.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>x1 <span class="ot">&lt;-</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">140</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>x2 <span class="ot">&lt;-</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">140</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(x1,x2)</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>lucro <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="dv">25</span><span class="sc">*</span>x[<span class="dv">1</span>] <span class="sc">+</span> <span class="dv">20</span><span class="sc">*</span>x[<span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Vamos também implementar uma função que avalia a restrição de recursos.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>recurso <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="dv">20</span><span class="sc">*</span>x[<span class="dv">1</span>] <span class="sc">+</span> <span class="dv">12</span><span class="sc">*</span>x[<span class="dv">2</span>]</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(out <span class="sc">&gt;</span> <span class="dv">1800</span>) out <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>E por fim, uma função que avalia a restrição de tempo.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>tempo <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">/</span><span class="dv">15</span>)<span class="sc">*</span>x[<span class="dv">1</span>] <span class="sc">+</span> (<span class="dv">1</span><span class="sc">/</span><span class="dv">15</span>)<span class="sc">*</span>x[<span class="dv">2</span>]</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(out <span class="sc">&gt;</span> <span class="dv">8</span>) out <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A Figura 3.13 apresenta todas as tentativas de soluções e marca a região factível, ou seja, soluções que respeitam as restrições de produção e tempo.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-13" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/proglinear-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.13: Método gráfico para a solução de problemas lineares.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Na Figura 3.13 (A) são apresentadas todas as possibilidades de produção envolvendo os produtos A e B. As linhas em vermelho são as restrições de recursos e tempo. Note que cada vez que impomos uma restrição, tiramos uma série de possíveis soluções. A solução ótima é aquela que está dentro da região factível e resulta no maior lucro possível. Este ponto é exatamente onde as linhas representando as restrições se cruzam.</p>
<p>Esta ideia pode ser generalizada para <span class="math inline">\(n\)</span> restrições e dá origem ao algoritmo Simplex. O pacote <code>lpSolve</code> fornece uma implementação eficiente do algoritmo Simplex por meio da função <code>lp()</code>. O Código 3.26 apresenta a solução do problema da empresa usando a função <code>lp()</code>.</p>
<p><strong>Código 3.26</strong> Exemplo de uso da função <code>lp()</code> do pacote <code>lpSolve()</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(lpSolve)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: lpSolve</code></pre>
</div>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>objective.in <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">25</span>, <span class="dv">20</span>) <span class="co"># c's</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>const.mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">12</span>, <span class="dv">1</span><span class="sc">/</span><span class="dv">15</span>, <span class="dv">1</span><span class="sc">/</span><span class="dv">15</span>), <span class="at">nrow=</span><span class="dv">2</span>, <span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>const.rhs <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1800</span>, <span class="dv">8</span>)</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>const.dir <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"&lt;="</span>, <span class="st">"&lt;="</span>)</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>optimum <span class="ot">&lt;-</span> <span class="fu">lp</span>(<span class="at">direction =</span> <span class="st">"max"</span>, objective.in, const.mat,</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>              const.dir, const.rhs)</span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>optimum<span class="sc">$</span>solution <span class="co"># Solução</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 45 75</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>optimum<span class="sc">$</span>objval <span class="co"># Lucro</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2625</code></pre>
</div>
</div>
<p>A solução mostra que a empresa deve produzir <span class="math inline">\(45\)</span> itens do produto A e <span class="math inline">\(75\)</span> do produto B para atingir o lucro máximo de R$ 2.625. Sendo esta a solução ótima dado os recursos disponíveis. Podemos incluir a solução no gráfico anterior para ver que ela se posiciona exatamente no cruzamento entre as retas das restrições, conforme a Figura 3.14 mostra.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-14" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/proglinearsolu-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.14: Solução ótima.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="programação-quadrática" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="programação-quadrática"><span class="header-section-number">3.4.2</span> Programação quadrática</h3>
<p>No caso da programação quadrática o problema matemático é especificado da seguinte forma <span class="math display">\[\underset{\boldsymbol{x}}{\mathrm{min}} \frac{1}{2} \boldsymbol{x}^\top \mathbf{D} \boldsymbol{x} - \boldsymbol{d}^{\top} \boldsymbol{x}, \text{s.t} \quad \mathbf{A} \boldsymbol{x} \geq \boldsymbol{b}.\]</span> onde <span class="math inline">\(\mathbf{D}\)</span> representa os coeficientes quadráticos, <span class="math inline">\(\boldsymbol{d}\)</span> os coeficientes lineares e <span class="math inline">\(\mathbf{A}\)</span> é uma matriz de constantes. As restrições de igualdade ou desigualdade são representadas por <span class="math inline">\(\boldsymbol{b}\)</span>. Em <code>R</code> o pacote <code>quadprog</code> resolve problemas de programação quadrática sua principal função é <code>solve.QP()</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(quadprog)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: quadprog</code></pre>
</div>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(solve.QP)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>function (Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE) 
NULL</code></pre>
</div>
</div>
<p>Mapeando os argumentos da função <code>solve.QP()</code> com os componentes do problema de programação quadrática temos:</p>
<ul>
<li>Coeficientes quadráticos <span class="math inline">\(\mathbf{D} \to\)</span> <code>Dmat</code>.</li>
<li>Coeficientes lineares <span class="math inline">\(\boldsymbol{d} \to\)</span> <code>dvec</code>.</li>
<li>Matriz de constantes <span class="math inline">\(\mathbf{A} \to\)</span> <code>Amat</code>.</li>
<li>Restrições de igualdade ou desigualdade <span class="math inline">\(\boldsymbol{b} \to\)</span> <code>bvec</code>.</li>
<li>Argumento <code>meq = n</code> fixa as primeiras <span class="math inline">\(n\)</span> restrições como lineares.</li>
</ul>
<p>Já nos deparamos com um problema de programação quadrática quando discutimos sobre o modelo de regressão linear múltipla. Para mostrar um problema ligeiramente diferente vamos considerar um modelo de regressão múltipla, porém com uma restrição nos coeficientes de regressão. Neste caso, o problema de regressão é resolvido por minimizar a perda quadrática sob uma restrição. Por exemplo, <span class="math display">\[\underset{\boldsymbol{\beta}}{\mathrm{min}} (\boldsymbol{y} - \mathbf{X}\boldsymbol{\beta})^{\top}(\boldsymbol{y} - \mathbf{X}\boldsymbol{\beta}), \quad \text{sujeito a} \quad \sum f(\boldsymbol{\beta}) \leq s.\]</span></p>
<p>Abrindo a forma quadrática, temos <span class="math display">\[\underset{\boldsymbol{\beta}}{\mathrm{min}} \quad \boldsymbol{y}^{\top}\boldsymbol{y} - 2 \boldsymbol{y}^{\top} \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\beta}^{\top} \mathbf{X}^{\top} \mathbf{X} \boldsymbol{\beta}.\]</span></p>
<p>Assim, fica fácil identificar os componentes do problema de programação quadrática, <span class="math display">\[\mathbf{D} = \mathbf{X}^{\top} \mathbf{X} \quad \text{e} \quad
\boldsymbol{d} = \boldsymbol{y}^{\top} \mathbf{X}.\]</span></p>
<p>Suponha que o interesse seja restringir que a soma dos coeficientes de regressão seja igual a <span class="math inline">\(1\)</span>. Neste caso a matriz de restrições <span class="math inline">\(A\)</span> é um vetor coluna <span class="math inline">\(p \times 1\)</span>, onde <span class="math inline">\(p\)</span> é o número de coeficientes de regressão a serem estimados.</p>
<p>Para ilustrar os cálculos computacionais, vamos começar simulando um conjunto de dados para o ajuste do modelo de regressão. O conjunto de dados simulado terá <span class="math inline">\(100\)</span> observações e duas covariáveis <span class="math inline">\(x_1\)</span> e <span class="math inline">\(x_2\)</span>, sendo ambas de uma distribuição uniforme no intervalo <span class="math inline">\((0,1)\)</span>. Os coeficientes de regressão serão fixados em <span class="math inline">\(\beta_0 = 0.15\)</span>, <span class="math inline">\(\beta_1 = 0.25\)</span> e <span class="math inline">\(\beta_2 = 0.6\)</span>. Para gerar algum ruído nas observações vamos adicionar valores de uma distribuição Normal padrão.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>x1 <span class="ot">&lt;-</span> <span class="fu">runif</span>(n)</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>x2 <span class="ot">&lt;-</span> <span class="fu">runif</span>(n)</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fl">0.15</span> <span class="sc">+</span> <span class="fl">0.25</span><span class="sc">*</span>x1 <span class="sc">+</span> <span class="fl">0.6</span><span class="sc">*</span>x2 <span class="sc">+</span> <span class="fu">rnorm</span>(n)</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">rep</span>(<span class="dv">1</span>,n), x1, x2 )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>O próximo passo é criar a matriz de restrições e estimar os coeficientes de regressão.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>Amat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>),<span class="at">ncol =</span> <span class="dv">1</span>, <span class="at">nrow =</span> <span class="dv">3</span>) <span class="co"># Soma dos betas = 1</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span>)</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">solve.QP</span>( <span class="fu">t</span>(X) <span class="sc">%*%</span> X, <span class="fu">t</span>(y) <span class="sc">%*%</span> X, <span class="at">Amat =</span> Amat, <span class="at">bvec =</span> b, <span class="at">meq =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Por fim, verificamos se a restrição foi atendida.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>s<span class="sc">$</span>solution</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.06258905 0.54262211 0.39478885</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(s<span class="sc">$</span>solution)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Diversas outras restrições podem ser impostas aos coeficientes do modelo de acordo com a necessidade de cada análise. Em geral, tais restrições não são populares nas técnicas convencionais de ciência de dados. Talvez as técnicas mais famosas que usam os princípios de programação quadrática com restrições sejam as <strong>máquinas de vetores de suporte</strong> ou em Inglês <em>support vector machines</em>. Porém, uma discussão mais detalhada sobre tais técnicas está fora do escopo deste livro.</p>
</section>
<section id="programação-não-linear" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="programação-não-linear"><span class="header-section-number">3.4.3</span> Programação não-linear</h3>
<p>Nos casos em que a função objetivo ou alguma restrição seja não-linear estamos lidando com um problema de <strong>programação não-linear</strong>. Esta é uma grande área da matemática e é comum categorizar os métodos baseado na dimensionalidade do problema que eles resolvem.</p>
<p>Para problemas unidimensionais o método <em>Golden Section search</em> é provavelmente um dos mais populares. Já usamos este método no início desta seção quando usamos a função <code>optimize()</code>.</p>
<p>Para problemas multidimensionais existe uma infinidade de métodos, mas que de forma geral se encaixam em quatro tipos de algoritmos:</p>
<ul>
<li>Não baseados em gradiente (<em>gradiente free</em>): como o próprio nome já diz são métodos que não usam a informação do gradiente para otimizar a função objetivo. São também chamados de métodos de ordem <span class="math inline">\(0\)</span>. Dentro desta classe o algoritmo de Nelder-Mead é bastante popular.</li>
<li>Baseados em gradiente: esta classe de algoritmos usa o gradiente da função objetivo para orientar a otimização da função objetivo. O exemplo mais popular é o gradiente descendente, mas existem inúmeras variações tal como o gradiente conjugado.</li>
<li>Baseados em hessiano: esta classe além de usar o gradiente, usa também o hessiano da função objetivo para orientar a otimização da função objetivo. O mais popular é o método de Newton que já vimos na seção de solução de equações não-lineares. Como já discutimos, o método de Newton é caro computacionalmente. Assim, surgiram os métodos chamados quasi-Newton que tentam imitar o método de Newton, porém com alguma forma mais barata (aproximada) do hessiano. Dentro desta classe o método BFGS é muito popular.</li>
<li>Baseados em simulação e ideias genéticas: esta classe de métodos busca otimizar a função objetivo gerando uma série de soluções aproximadas que vão sendo melhoradas passo-a-passo. Em geral são métodos computacionalmente intensivos que buscam explorar toda a extensão da função objetivo em busca do seu valor ótimo. Um algoritmo popular é o <em>Simulating Annealing</em> (SANN).</li>
</ul>
<p>Em <code>R</code> a função <code>optim()</code> é a escolha inicial quando se trata de programação não-linear. Ela implementa os métodos de Nelder-Mead, Gradiente Conjugado, BFGS e SANN. Na sequência, vamos discutir as principais ideias por trás de cada um destes algoritmos. É importante ressaltar que existe uma infinidade de variações nas implementações. Assim, é importante ler a documentação para saber os detalhes e variações na implementação de cada método.</p>
<section id="golden-section-search" class="level4" data-number="3.4.3.1">
<h4 data-number="3.4.3.1" class="anchored" data-anchor-id="golden-section-search"><span class="header-section-number">3.4.3.1</span> Golden section search</h4>
<p>Para problemas unidimensionais o método <em>Golden Section Search</em> é o mais popular e eficiente. O algoritmo é simples:</p>
<ul>
<li>Defina a razão de ouro <span class="math inline">\(\psi = \frac{\sqrt{5} - 1}{2} = 0.618\)</span>;</li>
<li>Escolha um intervalo <span class="math inline">\([a,b]\)</span> que contenha a solução;</li>
<li>Avalie <span class="math inline">\(f(x_1)\)</span> onde <span class="math inline">\(x_1 = a + (1-\psi)(b-a)\)</span> e compare com <span class="math inline">\(f(x_2)\)</span> onde <span class="math inline">\(x_2 = a + \psi (b - a)\)</span>;</li>
<li>Se <span class="math inline">\(f(x_1) &lt; f(x_2)\)</span> continua a procura em <span class="math inline">\([a,x_1]\)</span> caso contrário em <span class="math inline">\([x_2,b]\)</span>.</li>
</ul>
<p>O Código 3.27 apresenta o protótipo de uma implementação do método Golden Section Search. Vale ressaltar que esta implementação é apenas para fins didáticos e que em termos práticos a função <code>optimize()</code> implementa este método de forma otimizada.</p>
<p><strong>Código 3.27</strong> Implementação didática do método Golden Section Search.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>my_gss <span class="ot">&lt;-</span> <span class="cf">function</span>(fc, interval, <span class="at">max_iter =</span> <span class="dv">10</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>, ...) {</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>  psi <span class="ot">&lt;-</span> (<span class="fu">sqrt</span>(<span class="dv">5</span>) <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>  intervalo <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> max_iter)</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>  intervalo[<span class="dv">1</span>,] <span class="ot">&lt;-</span> interval</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>  sol <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>max_iter) {</span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> intervalo[<span class="fu">c</span>(i<span class="dv">-1</span>),<span class="dv">1</span>]</span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> intervalo[<span class="fu">c</span>(i<span class="dv">-1</span>),<span class="dv">2</span>]</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>    x1 <span class="ot">&lt;-</span> a <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>psi)<span class="sc">*</span>(b<span class="sc">-</span>a)</span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>    x2 <span class="ot">&lt;-</span> a <span class="sc">+</span> psi<span class="sc">*</span>(b<span class="sc">-</span>a)</span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>    f_x1 <span class="ot">&lt;-</span> <span class="fu">fc</span>(x1, ...)</span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>    f_x2 <span class="ot">&lt;-</span> <span class="fu">fc</span>(x2, ...)</span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(f_x1 <span class="sc">&lt;</span> f_x2) {intervalo[i,] <span class="ot">&lt;-</span> <span class="fu">c</span>(a, x1); sol[i] <span class="ot">&lt;-</span> x1} <span class="cf">else</span> </span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>      {intervalo[i,] <span class="ot">&lt;-</span> <span class="fu">c</span>(x2, b); sol[i] <span class="ot">&lt;-</span> x2}</span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">abs</span>( (intervalo[i,<span class="dv">2</span>]<span class="sc">-</span>intervalo[i,<span class="dv">1</span>])<span class="sc">/</span><span class="dv">2</span>) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Solução"</span> <span class="ot">=</span> sol[i], <span class="st">"Intervalos"</span> <span class="ot">=</span> intervalo, <span class="st">"Tentativas"</span> <span class="ot">=</span> sol)</span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Como exemplo de uso do método, considere minimizar a função <span class="math inline">\(f(x) = |x-2| + 2 |x-1|\)</span>. Para usar a função <code>optimize()</code> ou a <code>my_gss()</code> precisamos implementar a função objetivo. O Código 3.28 implementa a função objetivo de forma adequada para ser otimizada usando as funções <code>optmize()</code> ou <code>my_gss()</code>.</p>
<p><strong>Código 3.28</strong> Exemplo de função objetivo unidimensional.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>fx <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">abs</span>(x<span class="dv">-2</span>) <span class="sc">+</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">abs</span>(x<span class="dv">-1</span>) </span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Usando a função <code>my_gss()</code> para otimizar a função de interesse.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">&lt;-</span> <span class="fu">my_gss</span>(<span class="at">fc =</span> fx, <span class="at">interval =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>,<span class="dv">3</span>), <span class="at">max_iter =</span> <span class="dv">15</span>)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>sol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$Solução
[1] 1.000019

$Intervalos
            [,1]     [,2]
 [1,] -3.0000000 3.000000
 [2,]  0.7082039 3.000000
 [3,]  0.7082039 1.583592
 [4,]  0.7082039 1.042572
 [5,]  0.9148551 1.042572
 [6,]  0.9937888 1.042572
 [7,]  0.9937888 1.012422
 [8,]  0.9937888 1.000906
 [9,]  0.9981876 1.000906
[10,]  0.9998678 1.000906
[11,]  0.9998678 1.000264
[12,]  0.9998678 1.000019
[13,]         NA       NA
[14,]         NA       NA
[15,]         NA       NA

$Tentativas
 [1]        NA 0.7082039 1.5835921 1.0425725 0.9148551 0.9937888 1.0124225
 [8] 1.0009062 0.9981876 0.9998678 1.0002644 1.0000193</code></pre>
</div>
</div>
<p>Fica claro pela saída do algoritmo que o intervalo foi sendo estreitado até que a precisão especificada foi atingida. Neste caso, foram necessárias <span class="math inline">\(12\)</span> iterações para atingir a convergência.</p>
<p>De forma similar, podemos usar a função <code>optmize()</code>. Vale lembrar que na função <code>optim()</code> o método Golden Section Search é chamado de <code>Brent</code>. Procedendo com a otimização, temos</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> fx, <span class="at">interval =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$minimum
[1] 1.000021

$objective
[1] 1.000021</code></pre>
</div>
</div>
<p>Figura 3.15 apresenta o traço do algoritmo, ou seja, o passo-a-passo até obter a solução final.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-15" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/goldengraf-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.15: Traço do algoritmo Golden Section Search.
</figcaption>
</figure>
</div>
</div>
</div>
<p>A Figura 3.15 (A) apresenta toda a extensão da função. Cada número representa a tentativa de solução do método. A Figura 3.15 (B) apresenta apenas a parte da função próxima ao valor ótimo. Novamente os números representam a tentativa de solução do método. Quando próximo da solução, o método propõe soluções cada vez mais próximas, é a parte de um ajuste fino. Por isso, os números ficam praticamente sobrepostos.</p>
</section>
<section id="método-nelder-mead" class="level4" data-number="3.4.3.2">
<h4 data-number="3.4.3.2" class="anchored" data-anchor-id="método-nelder-mead"><span class="header-section-number">3.4.3.2</span> Método Nelder-Mead</h4>
<p>O método de Nelder-Mead é um método genérico de otimização que não usa informação do gradiente da função a ser otimizada. O algoritmo de Nelder-Mead consiste dos seguintes passos:</p>
<ol type="1">
<li>Escolha um simplex com <span class="math inline">\(n+1\)</span> pontos <span class="math inline">\(p_1, \ldots p_{n+1}\)</span>, sendo <span class="math inline">\(n\)</span> o número de incógnitas.</li>
<li>Calcule <span class="math inline">\(f(p_i)\)</span> e ordene por tamanho <span class="math inline">\(f(p_1) \leq \ldots f(p_{n})\)</span>.</li>
<li>Avalie se o melhor valor é bom o suficiente. Se for, pare.</li>
<li>Delete o ponto com maior/menor <span class="math inline">\(f(p_i)\)</span> do simplex.</li>
<li>Escolha um novo ponto para o simplex.</li>
<li>Volte ao passo 2.</li>
</ol>
<p>O passo 1 consiste basicamente em propor algumas possíveis soluções para o problema para no passo 2 avaliá-las na função objetivo e ordená-las de modo a descartar a pior no passo 4. Em geometria, <strong>simplex</strong> é uma generalização da noção de triângulo ou tetraedro, mas que em um espaço multidimensional é difícil de nomear. Assim, é simplesmente chamado de simplex.</p>
<p>O passo 5 é crucial e consiste em escolher um novo ponto para substituir o ponto retirado no passo 4. Existem diversas formas de fazer esta substituição. Porém, a mais popular é mover para o ponto central do melhor lado e refletir o simplex para o lado da melhor solução. Se o ponto obtido oferecer uma solução melhor do que as já avaliadas, movemos na direção correta, caso contrário podemos expandir ou contrair para obter um outro ponto. O processo continua até que algum critério de convergência seja atingido.</p>
<p>É mais fácil explicar a ideia do método de Nelder-Mead por meio de uma figura. Considere a Figura 3.16(A) onde temos uma função bidimensional. Nosso objetivo é encontrar o ponto de mínimo desta função que claramente, dados os valores das curvas de nível, fica no centro da figura.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-16" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/NelderMead-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.16: Ilustração do método de Nelder-Mead.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Figura 3.16 (A) apresenta a primeira iteração do algoritmo. Começamos com o triângulo (cor preta) definido pelos pontos <span class="math inline">\((W_1, G_1\)</span> e <span class="math inline">\(B_1)\)</span>. Ordenando os pontos temos que <span class="math inline">\(B_1\)</span> é o melhor seguido por <span class="math inline">\(G_1\)</span> e o pior é <span class="math inline">\(W_1\)</span>. Sendo assim, <span class="math inline">\(W_1\)</span> é o ponto que precisa ser removido. Para isso vamos projetar o simplex para o melhor lado, ou seja, o lado <span class="math inline">\(B_1\)</span> e <span class="math inline">\(G_1\)</span>. O ponto central do melhor lado é dado por <span class="math display">\[M = \frac{B + G}{2} = \left( \frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2} \right).\]</span></p>
<p>Agora refletimos o simplex para o lado BG usando a seguinte equação <span class="math display">\[R = M + (M - W) = 2M - W.\]</span></p>
<p>Com isso obtemos um novo ponto chamado de <span class="math inline">\(R\)</span>. Ainda temos algumas decisões a serem tomadas. Se a função em <span class="math inline">\(R\)</span> é menor que em <span class="math inline">\(W\)</span> movemos na direção correta. Assim,</p>
<ul>
<li>Opção 1: faça <span class="math inline">\(W = R\)</span> e repita.</li>
<li>Opção 2: expanda usando o ponto <span class="math inline">\(E = 2R - M\)</span> e <span class="math inline">\(W = E\)</span> e repita.</li>
</ul>
<p>Por outro lado, se a função em <span class="math inline">\(R\)</span> e <span class="math inline">\(W\)</span> são iguais contraia <span class="math inline">\(W\)</span> para próximo a <span class="math inline">\(B\)</span> e repita. Note que a cada passo uma decisão lógica precisa ser tomada. Seja qual for a escolha, a ideia é ir melhorando a solução. As Figuras 3.16(B) e 3.16(C) apresentam a segunda e terceira iteração do método, respectivamente. Para facilitar a visualização, os triângulos obtidos nas iterações 2 e 3 são marcados com as cores vermelho e azul. Note que na terceira iteração o método já está próximo da solução. As iterações devem continuar até que um critério de parada seja atingido. O método de Nelder-Mead está implementado na função <code>optim()</code> sendo a opção <em>default</em>.</p>
<p>Para ilustrar o uso do método de Nelder-Mead em uma função bidimensional considere que o objetivo é otimizar a seguinte função das variáveis <span class="math inline">\(y_1\)</span> e <span class="math inline">\(y_2\)</span> fcbidi<span class="math display">\[\begin{equation}
f(\mathbf{y}) = 10 y_1 \ln(y_2) + 10 \ln \Gamma(y_1) + \frac{15}{y_2} - (y_1 - 1)1.40.
\tag{3.15}
\end{equation}\]</span></p>
<p>O primeiro passo é implementar a função objetivo. Note que a entrada é feita através de um vetor bidimensional.</p>
<p><strong>Código 3.29</strong> Função objetivo bidimensional para ilustração dos métodos de otimização.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>fc_obj <span class="ot">&lt;-</span> <span class="cf">function</span>(par) {</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>  y1 <span class="ot">&lt;-</span> par[<span class="dv">1</span>]</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>  y2 <span class="ot">&lt;-</span> par[<span class="dv">2</span>]</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">*</span>y1<span class="sc">*</span><span class="fu">log</span>(y2) <span class="sc">+</span> <span class="dv">10</span><span class="sc">*</span><span class="fu">lgamma</span>(y1) <span class="sc">+</span> (<span class="dv">15</span><span class="sc">/</span>y2) <span class="sc">-</span> (y1<span class="dv">-1</span>)<span class="sc">*</span><span class="fl">1.40</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Figuras 3.17(A) e 3.17(B) apresentam os gráficos de perspectiva e contornos da função em fcbidi(3.15).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-17" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/bidi-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.17: Gráficos de perspectiva e contornos: Função bidimensional.
</figcaption>
</figure>
</div>
</div>
</div>
<p>O próximo passo é usar a função <code>optim()</code> com o argumento <code>method = Nelder-Mead</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>otimo <span class="ot">&lt;-</span> <span class="fu">optim</span>(<span class="at">par =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">fn =</span> fc_obj, <span class="at">method =</span> <span class="st">"Nelder-Mead"</span>)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>otimo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$par
[1] 2.034705 0.737219

$value
[1] 12.84552

$counts
function gradient 
      61       NA 

$convergence
[1] 0

$message
NULL</code></pre>
</div>
</div>
<p>A função <code>optim()</code> retorna uma lista com uma série de resultados e informações sobre o processo de otimização. Importante ressaltar que por <em>default</em> a <code>optim()</code> procura pelo mínimo da função objetivo. Caso você esteja interessado no máximo você pode multiplicar a função objetivo por <span class="math inline">\(-1\)</span>, ou usar o argumento <code>fnscale = -1</code> que é equivalente. O <code>slot par</code> da lista apresenta a solução ótima. Neste caso <span class="math inline">\(y_1 = 1\)</span> e <span class="math inline">\(y_2 = 1\)</span> são os valores que tornam a função objetivo mínima. O <code>slot value</code> apresenta o valor da função objetivo no ponto de mínimo. O <code>slot count</code> indica quantas vezes a função foi avaliada até encontrar o mínimo. Por fim, o <code>slot convergence</code> é um código indicando o <em>status</em> final do algoritmo, onde <span class="math inline">\(0\)</span> indica que o algoritmo convergiu. Para mais detalhes sobre a saída veja a documentação <code>?optim</code>. Por fim, a Figura #fig:tracNelderMead3.18 apresenta o traço do algoritmo. Os números representam a iteração e os pontos de cada tentativa até encontrar o ponto de mínimo da função.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-18" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/tracNelderMead-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.18: Traço do algoritmo de Nelder-Mead.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="métodos-baseados-em-gradiente" class="level4" data-number="3.4.3.3">
<h4 data-number="3.4.3.3" class="anchored" data-anchor-id="métodos-baseados-em-gradiente"><span class="header-section-number">3.4.3.3</span> Métodos baseados em gradiente</h4>
<p>O gradiente de uma função indica a direção do seu máximo. Sendo assim, usar a informação do gradiente para otimizar uma função é uma ideia natural. Nós já discutimos o método do gradiente descendente para a solução de sistemas de equações não-lineares. Nesta seção nós vamos apenas estender a ideia para a otimização de uma função.</p>
<p>Suponha que o objetivo é minimizar uma função <span class="math inline">\(f(\mathbf{x})\)</span> que vai do <span class="math inline">\(\Re^n \to \Re\)</span> que seja diferenciável e convexa. Denote por <span class="math inline">\(\nabla f(\mathbf{x})\)</span> o gradiente de <span class="math inline">\(f(\mathbf{x})\)</span>. Como o gradiente aponta para a direção do máximo e estamos interessados no mínimo basta andar na direção contrária, ou seja, <span class="math inline">\(-\nabla f(\mathbf{x})\)</span> a um passo de tamanho, digamos, <span class="math inline">\(\alpha\)</span>. Assim, a partir de uma solução inicial podemos caminhar na direção do mínimo, simplesmente iterando a Equação (3.16) até que algum critério de convergência seja satisfeito.</p>
<p><span class="math display">\[\begin{equation}
\mathbf{x}_{k+1} = \mathbf{x}_{k} - \alpha \nabla f(\mathbf{x}_k).
  \tag{3.16}
\end{equation}\]</span></p>
<p>Note que a Equação (3.16) é exatamente a aplicação do método do gradiente descendente para resolver o sistema de equações <span class="math inline">\(\nabla f(\mathbf{x}) = \mathbf{0}\)</span>. Como já mencionado, o ponto central para o uso deste método é a escolha do valor <span class="math inline">\(\alpha\)</span>. Diferentes estratégias de especificação de <span class="math inline">\(\alpha\)</span> levam a algoritmos com nomes diferentes.</p>
<p>Uma ideia simples é encontrar o valor de <span class="math inline">\(\alpha_k\)</span> que a cada iteração torne <span class="math inline">\(f(x_{k+1})\)</span> mínima. Essa ideia resulta no algoritmo chamado de <em>steepest descendent</em>. A ideia é simples, mas envolve alguma estratégia para encontrar tal <span class="math inline">\(\alpha_k\)</span>. Uma estratégia simples é a busca em linha que nada mais é do que a cada iteração escolher <span class="math inline">\(\alpha_k\)</span> que minimiza <span class="math inline">\(f(\mathbf{x}_{k+1})\)</span> para <span class="math inline">\(\alpha_k \in \Lambda\)</span>, onde <span class="math inline">\(\Lambda\)</span> é algum intervalo a ser especificado. Como a taxa de aprendizagem <span class="math inline">\(\alpha\)</span> em geral toma valores pequenos, o intervalo unitário pode ser uma escolha razoável. Porém, obviamente deve ser avaliado caso a caso. Uma outra opção seria usar algum outro algoritmo como o <em>Golden Section Search</em> para encontrar <span class="math inline">\(\alpha_k\)</span>.</p>
<p>Neste livro, vamos seguir com a busca em linha. Assim, dada uma solução inicial, o algoritmo <em>steepest descent</em> com busca em linha atualiza a solução usando a seguinte equação <span class="math display">\[\begin{equation}
\mathbf{x}_{k+1} = \mathbf{x}_{k} - \alpha_k \nabla f(\mathbf{x}_k),
  \tag{3.17}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\alpha_k\)</span> minimiza <span class="math inline">\(f(x_{k+1})\)</span> com <span class="math inline">\(\alpha_k \in \Lambda\)</span>.</p>
<p>Tanto a Equação (3.16) quanto a Equação (3.17) assumem que o gradiente de <span class="math inline">\(f(\mathbf{x})\)</span> está disponível. Em alguns casos pode não ser simples obter <span class="math inline">\(\nabla f(\mathbf{x}_k)\)</span> analiticamente ou mesmo muito caro para calcular computacionalmente. Nestas situações pode-se usar as técnicas de diferenciação numérica vistas na seção #DN3.2 para aproximar <span class="math inline">\(\nabla f(\mathbf{x}_k)\)</span>. É claro que essa estratégia vai acarretar um custo computacional extra para aproximar o gradiente a cada iteração do algoritmo.</p>
<p>Uma outra opção é usar o gradiente descendente, porém a cada iteração forçar que a direção de busca seja <strong>conjugada</strong> a direção de busca mais recente. Dois vetores <span class="math inline">\(\mathbf{x}_1\)</span> e <span class="math inline">\(\mathbf{x}_2\)</span> são conjugado em relação a uma matriz <span class="math inline">\(\mathbf{A}\)</span> se <span class="math inline">\(\mathbf{x}_1^{\top} \mathbf{A} \mathbf{x}_2^{\top} = 0\)</span>. Essa ideia leva ao método chamado de gradiente conjugado, ou em Inglês, <em>conjugate gradient</em>. A versão do gradiente conjugado proposta por Fletcher–Reeves é a opção <em>default</em> da função <code>optim()</code> quando o argumento <code>method = "CG"</code> é especificado. Neste caso, a equação de iteração é a seguinte <span class="math display">\[\begin{equation}
\mathbf{x}_{k+1} = \mathbf{x}_k - \alpha_k \nabla f(\mathbf{x}_k) + \frac{\alpha_k \beta_k}{\alpha_{k-1}}(\mathbf{x}_k - \mathbf{x}_{k-1}),
\end{equation}\]</span> onde <span class="math inline">\(\beta_k = \frac{\nabla f(\mathbf{x}_k)^{\top} \nabla f(\mathbf{x}_k)}{\nabla f(\mathbf{x}_{k-1})^{\top} \nabla f(\mathbf{x}_{k-1})}\)</span>.</p>
<p>Outras duas variações do método propostas por Polak–Ribière e Hestenes–Stiefel estão implementadas na <code>optim()</code>. O Código 3.30 apresenta uma implementação didática do método gradiente descendente para minimizar uma função. De forma similar, os Códigos 3.31 e 3.32 implementam os métodos <em>steepest descendent</em> e gradiente conjugado com duas opções para obter <span class="math inline">\(\alpha_k\)</span>: na primeira apenas avaliamos a função em uma grade de valores para <span class="math inline">\(\alpha\)</span> e tomamos aquele que minimiza a função no próximo passo. Essa abordagem é também chamada de <em>grid search</em>. A segunda opção é usar o método <em>Golden Section Search</em>. Nas três implementações fornecer o gradiente da função objetivo é opcional. Caso não seja fornecido, o gradiente será obtido de forma numérica usando a diferença central. Esse método é obtido usando <code>method = "simple"</code> na função <code>grad()</code> do pacote <code>numDeriv</code>.</p>
<p><strong>Código 3.30</strong> Implementação didática do método do gradiente descendente para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>grad_desc <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, alpha, </span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">tol =</span> <span class="fl">1e-05</span>, <span class="at">max_iter =</span> <span class="dv">100</span>, ...) {</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para avaliar o gradiente caso o usuário não forneça</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>, ...)</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Objetos para guardar a solução</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> solucao[i,] <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> solucao[i,], ...)</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Iterações"</span> <span class="ot">=</span> solucao, <span class="st">"Solução"</span> <span class="ot">=</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),])</span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.31</strong> Implementação didática do método <em>steepest descendent</em> para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>steep_desc <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, </span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">intervalo =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), </span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">precisao =</span> <span class="fl">0.01</span>,</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">strategy =</span> <span class="st">"grid_search"</span>,</span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">tol =</span> <span class="fl">1e-05</span>, <span class="at">max_iter =</span> <span class="dv">100</span>, ...) {</span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para avaliar o gradiente caso o usuario não forneça</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>, ...)</span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para encontrar o alpha otimo a cada iteração</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>  fc <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha, xk, funcao, gradiente, ...) {</span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>    xk1 <span class="ot">&lt;-</span> xk <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> xk, ...)</span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a>    out <span class="ot">&lt;-</span> <span class="fu">funcao</span>(xk1, ...)</span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(out)</span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Forma vetorizada para o grid search</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>  fc_vec <span class="ot">&lt;-</span> <span class="fu">Vectorize</span>(fc, <span class="st">"alpha"</span>)</span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Funcao para encontrar o alpha </span></span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a>  get_alpha <span class="ot">&lt;-</span> <span class="cf">function</span>(xk, <span class="at">strategy =</span> <span class="st">"grid_search"</span>, interval, <span class="at">prec =</span> precisao, ...) {</span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"grid_search"</span>) {</span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a>      gride <span class="ot">&lt;-</span> <span class="fu">seq</span>(interval[<span class="dv">1</span>], interval[<span class="dv">2</span>], <span class="at">by =</span> prec)</span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a>      fc_value <span class="ot">&lt;-</span> <span class="fu">fc_vec</span>(<span class="at">alpha =</span> gride, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> gride[<span class="fu">which.min</span>(fc_value)]</span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"golden_search"</span>) {</span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a>      out <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> fc, <span class="at">interval =</span> interval, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, </span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>                      <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> out<span class="sc">$</span>minimum</span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(alpha_otimo)</span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Objetos para guardar a solução</span></span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb145-37"><a href="#cb145-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb145-38"><a href="#cb145-38" aria-hidden="true" tabindex="-1"></a>    alpha <span class="ot">&lt;-</span> <span class="fu">get_alpha</span>(<span class="at">xk =</span> solucao[i,], <span class="at">strategy =</span> strategy, <span class="at">interval =</span> intervalo)</span>
<span id="cb145-39"><a href="#cb145-39" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> solucao[i,] <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> solucao[i,], ...)</span>
<span id="cb145-40"><a href="#cb145-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb145-41"><a href="#cb145-41" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb145-42"><a href="#cb145-42" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Iterações"</span> <span class="ot">=</span> solucao, <span class="st">"Solução"</span> <span class="ot">=</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),])</span>
<span id="cb145-43"><a href="#cb145-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb145-44"><a href="#cb145-44" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.32</strong> Implementação didática do método do gradiente conjugado para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>grad_conju <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, </span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">intervalo =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), </span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">precisao =</span> <span class="fl">0.01</span>,</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">strategy =</span> <span class="st">"grid_search"</span>,</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">tol =</span> <span class="fl">1e-05</span>, <span class="at">max_iter =</span> <span class="dv">100</span>, ...) {</span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para avaliar o gradiente caso o usuário não forneça</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>, ...)</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para encontrar o alpha otimo a cada iteração</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>  fc <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha, xk, funcao, gradiente, ...) {</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>    xk1 <span class="ot">&lt;-</span> xk <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> xk, ...)</span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a>    out <span class="ot">&lt;-</span> <span class="fu">funcao</span>(xk1, ...)</span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(out)</span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Forma vetorizada para o grid search</span></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true" tabindex="-1"></a>  fc_vec <span class="ot">&lt;-</span> <span class="fu">Vectorize</span>(fc, <span class="st">"alpha"</span>)</span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Funcao para encontrar o alpha ótimo</span></span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true" tabindex="-1"></a>  get_alpha <span class="ot">&lt;-</span> <span class="cf">function</span>(xk, <span class="at">strategy =</span> <span class="st">"grid_search"</span>, interval, <span class="at">prec =</span> precisao, ...) {</span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"grid_search"</span>) {</span>
<span id="cb146-23"><a href="#cb146-23" aria-hidden="true" tabindex="-1"></a>      gride <span class="ot">&lt;-</span> <span class="fu">seq</span>(interval[<span class="dv">1</span>], interval[<span class="dv">2</span>], <span class="at">by =</span> prec)</span>
<span id="cb146-24"><a href="#cb146-24" aria-hidden="true" tabindex="-1"></a>      fc_value <span class="ot">&lt;-</span> <span class="fu">fc_vec</span>(<span class="at">alpha =</span> gride, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb146-25"><a href="#cb146-25" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> gride[<span class="fu">which.min</span>(fc_value)]</span>
<span id="cb146-26"><a href="#cb146-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb146-27"><a href="#cb146-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"golden_search"</span>) {</span>
<span id="cb146-28"><a href="#cb146-28" aria-hidden="true" tabindex="-1"></a>      out <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> fc, <span class="at">interval =</span> interval, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, </span>
<span id="cb146-29"><a href="#cb146-29" aria-hidden="true" tabindex="-1"></a>                      <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb146-30"><a href="#cb146-30" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> out<span class="sc">$</span>minimum</span>
<span id="cb146-31"><a href="#cb146-31" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb146-32"><a href="#cb146-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(alpha_otimo)</span>
<span id="cb146-33"><a href="#cb146-33" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb146-34"><a href="#cb146-34" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Objetos para guardar a solução</span></span>
<span id="cb146-35"><a href="#cb146-35" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb146-36"><a href="#cb146-36" aria-hidden="true" tabindex="-1"></a>  grad_temp <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb146-37"><a href="#cb146-37" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb146-38"><a href="#cb146-38" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb146-39"><a href="#cb146-39" aria-hidden="true" tabindex="-1"></a>  beta <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb146-40"><a href="#cb146-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb146-41"><a href="#cb146-41" aria-hidden="true" tabindex="-1"></a>    alpha[i] <span class="ot">&lt;-</span> <span class="fu">get_alpha</span>(<span class="at">xk =</span> solucao[i,], <span class="at">strategy =</span> strategy, <span class="at">interval =</span> intervalo)</span>
<span id="cb146-42"><a href="#cb146-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(i <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb146-43"><a href="#cb146-43" aria-hidden="true" tabindex="-1"></a>     <span class="co">#solucao[i+1,] &lt;- solucao[i,] - alpha*gradiente(ponto = solucao[i,], ...) </span></span>
<span id="cb146-44"><a href="#cb146-44" aria-hidden="true" tabindex="-1"></a>     grad_temp[i,] <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(<span class="at">ponto =</span> solucao[i,], ...) </span>
<span id="cb146-45"><a href="#cb146-45" aria-hidden="true" tabindex="-1"></a>     solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> solucao[i,] <span class="sc">-</span> alpha[i]<span class="sc">*</span>grad_temp[i,]</span>
<span id="cb146-46"><a href="#cb146-46" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb146-47"><a href="#cb146-47" aria-hidden="true" tabindex="-1"></a>      grad_temp[i,] <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(<span class="at">ponto =</span> solucao[i,], ...) </span>
<span id="cb146-48"><a href="#cb146-48" aria-hidden="true" tabindex="-1"></a>      beta[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(grad_temp[i,])<span class="sc">%*%</span>grad_temp[i,]<span class="sc">/</span><span class="fu">t</span>(grad_temp[<span class="fu">c</span>(i<span class="dv">-1</span>),])<span class="sc">%*%</span>grad_temp[<span class="fu">c</span>(i<span class="dv">-1</span>),]</span>
<span id="cb146-49"><a href="#cb146-49" aria-hidden="true" tabindex="-1"></a>      solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> solucao[i,] <span class="sc">-</span> alpha[i]<span class="sc">*</span>grad_temp[i,] <span class="sc">+</span> (alpha[i]<span class="sc">*</span>beta[i] <span class="sc">/</span>alpha[<span class="fu">c</span>(i<span class="dv">-1</span>)])<span class="sc">*</span>(solucao[i,] <span class="sc">-</span> solucao[<span class="fu">c</span>(i<span class="dv">-1</span>),])</span>
<span id="cb146-50"><a href="#cb146-50" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb146-51"><a href="#cb146-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb146-52"><a href="#cb146-52" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb146-53"><a href="#cb146-53" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Iterações"</span> <span class="ot">=</span> solucao, <span class="st">"Solução"</span> <span class="ot">=</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),])</span>
<span id="cb146-54"><a href="#cb146-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb146-55"><a href="#cb146-55" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar e comparar o uso dos métodos baseados em gradiente, vamos minimizar a função da Equação (3.15) e implementada no Código etivo3.29. É importante ressaltar que a função em (3.15) tem solução e gradiente analítico. No entanto, apenas pelo exemplo didático estamos usando algoritmos de otimização numérica e o gradiente será obtido também de forma numérica. Assim, tudo que precisamos é da implementação computacional da função objetivo e um vetor de valores iniciais.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Gradiente descendente</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>gd <span class="ot">&lt;-</span> <span class="fu">grad_desc</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">max_iter =</span> <span class="dv">150</span>)</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Steepest descedent</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>sd <span class="ot">&lt;-</span> <span class="fu">steep_desc</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj, <span class="at">intervalo =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.2</span>))</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Gradiente conjugado</span></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>gc <span class="ot">&lt;-</span> <span class="fu">grad_conju</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in log(y2): NaNs produzidos

Warning in log(y2): NaNs produzidos</code></pre>
</div>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Comparando as soluções obtidas</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cbind</span>(gd<span class="sc">$</span>Solução, sd<span class="sc">$</span>Solução, gc<span class="sc">$</span>Solução)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]      [,2]      [,3]
[1,] 2.0345651 2.0339857 2.0340624
[2,] 0.7372096 0.7374629 0.7374386</code></pre>
</div>
</div>
<p>Os resultados mostram que os três algoritmos chegaram a soluções muito próximas. Isso nem sempre será verdade e vai depender dos critérios de convergência e da função sendo otimizada.</p>
<p>Por fim, as Figuras 3.19(A), 3.19(B) e 3.19(C) apresentam o traço dos algoritmos gradiente descendente, <em>steepest descendent</em> e gradiente conjugado, respectivamente.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-19" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/traceGrad-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.19: Traço dos algoritmos gradiente descendente (A), steepest descendent (B) e gradiente conjugado (C).
</figcaption>
</figure>
</div>
</div>
</div>
<p>Neste exemplo o gradiente descendente precisou de <span class="math inline">\(140\)</span> iterações para convergir, enquanto que o <em>steepest descedent</em> e o gradiente conjugado precisaram de <span class="math inline">\(80\)</span> e <span class="math inline">\(23\)</span> iterações, respectivamente. No entanto em termos de tempo computacional o gradiente descendente é o mais rápido, seguido pelo <em>steepest descendent</em> e pelo gradiente conjugado. Isso é resultado da escolha adaptativa do parâmetro <span class="math inline">\(\alpha\)</span> que consome tempo computacional.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Gradiente descendente</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(gd <span class="ot">&lt;-</span> <span class="fu">grad_desc</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj, </span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">max_iter =</span> <span class="dv">150</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  usuário   sistema decorrido 
        0         0         0 </code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Steepest descedent</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(sd <span class="ot">&lt;-</span> <span class="fu">steep_desc</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj, </span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>                             <span class="at">intervalo =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.2</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  usuário   sistema decorrido 
     0.02      0.00      0.05 </code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Gradiente conjugado</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(gc <span class="ot">&lt;-</span> <span class="fu">grad_conju</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in log(y2): NaNs produzidos

Warning in log(y2): NaNs produzidos</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>  usuário   sistema decorrido 
     0.05      0.00      0.07 </code></pre>
</div>
</div>
</section>
<section id="métodos-baseados-em-hessiano" class="level4" data-number="3.4.3.4">
<h4 data-number="3.4.3.4" class="anchored" data-anchor-id="métodos-baseados-em-hessiano"><span class="header-section-number">3.4.3.4</span> Métodos baseados em Hessiano</h4>
<p>Conforme discutido na seção anterior, a escolha do parâmetro <span class="math inline">\(\alpha\)</span> é crucial para a eficiência computacional e sucesso dos métodos baseados em gradiente. Nos métodos baseados em gradiente e hessiano o parâmetro <span class="math inline">\(\alpha\)</span> é substituído pelo inverso do hessiano, obtendo um passo de certa forma ótimo. Uma vez que usa a própria curvatura da função no ponto avaliado a cada iteração. A ideia é que a cada passo a função objetivo é aproximada por uma função quadrática que pode ser otimizada de forma analítica. Por sucessivas otimizações de uma função mais simples a função objetivo é otimizada.</p>
<p>Nós já discutimos o método de Newton para resolver um sistema de equações não-lineares. A otimização de uma função suave e diferenciável <span class="math inline">\(f(\mathbf{x})\)</span> é o mesmo que resolver o sistema de equações não-lineares <span class="math inline">\(\nabla f(\mathbf{x}) = 0\)</span>. Usando o método de Newton o sistema é resolvido iterando a seguinte equação <span class="math display">\[\mathbf{x}^{(i+1)} = \mathbf{x}^{(i)} - \mathbf{J(x^{(i)})}^{-1} \nabla f(\mathbf{x}^{(i)}),\]</span> onde <span class="math inline">\(\mathbf{J}\)</span> é uma matrix <span class="math inline">\(p \times p\)</span> de segundas derivadas de <span class="math inline">\(f(\mathbf{x})\)</span>, ou seja, o hessiano. O ideal é que tanto o gradiente como o hessiano sejam obtidos analiticamente. Porém, em implementações genéricas é possível usar aproximações numéricas para ambos. Cabe ressaltar que neste caso o custo computacional é elevado.</p>
<p>Para problemas onde o número de variáveis <span class="math inline">\(p\)</span> é elevado, como é frequente em redes neurais, o cálculo do hessiano é extremamente oneroso computacionalmente o que torna o uso deste tipo de método praticamente inviável. Mesmo para problemas de médio porte, o cálculo e armazenamento do hessiano é caro, o que levou ao desenvolvimento de métodos que buscam aproximar <span class="math inline">\(\mathbf{J(x^{(i)})}^{-1}\)</span> de uma forma mais simples e barata para calcular e armazenar. Essa ideia leva a classe de métodos <strong>quasi-Newton</strong>.</p>
<p>A ideia dos métodos quasi-Newton é imitar o método de Newton, porém usando alguma aproximação para <span class="math inline">\(\mathbf{J(x^{(i)})}^{-1}\)</span>. Assim, a equação de iteração fica genericamente dada por <span class="math display">\[\mathbf{x}^{(i+1)} = \mathbf{x}_{(i)} - \alpha_i \mathbf{H}_i \nabla f(x^{(i)}),\]</span> onde <span class="math inline">\(\mathbf{H}_i\)</span> é alguma aproximação para o inverso do Hessiano. De forma análoga aos métodos baseados em gradiente <span class="math inline">\(\alpha_i\)</span> é o tamanho do passo e precisa ser especificado ou otimizado usando um esquema tipo <em>line search</em>. Seja <span class="math inline">\(\boldsymbol{\delta}_i = \mathbf{x}^{(i+1)} - \mathbf{x}^{(i)}\)</span> e <span class="math inline">\(\boldsymbol{\gamma}_i = \nabla f(\mathbf{x}^{(i+1)}) - \nabla f(\mathbf{x}^{(i)})\)</span>.</p>
<p>Um algoritmo pioneiro nesta classe é o chamado algoritmo DFP. O algoritmo DFP faz sucessivas aproximações do inverso do hessiano usando a seguinte equação de iteração <span class="math display">\[\mathbf{H}_{i+1} = \mathbf{H}_i - \frac{\mathbf{H}_i \boldsymbol{\gamma}_i \boldsymbol{\gamma}_i^{\top} \mathbf{H}_i}{\boldsymbol{\gamma}_i^{\top} \mathbf{H}_i \boldsymbol{\gamma}_i} + \frac{\boldsymbol{\delta}_i \boldsymbol{\delta}_i^{\top}}{\boldsymbol{\gamma}_i^{\top} \boldsymbol{\delta}_i}.\]</span></p>
<p>Broyden, Fletcher, Goldfarb e Shanno propuseram, baseado no algoritmo DFP, o algoritmo BFGS que leva as iniciais de seus autores e é provavelmente o método quasi-Newton mais popular em uso atualmente. A ideia do BFGS é aproximar o inverso do hessiano por <span class="math display">\[\mathbf{H}_{i+1} = \mathbf{H}_i + \frac{(\delta_i^{\top} \gamma_i + \gamma_i^{\top} \mathbf{H}_i \gamma_i)(\delta_i \delta_i^{\top})}{(\delta_i^{\top} \gamma_i)^2} - \frac{\mathbf{H}_i \gamma_i \delta_i^{\top} + \delta_i \gamma_i^{\top} \mathbf{H}_i}{\delta_i^{\top}\gamma_i}.\]</span> Implementações modernas do BFGS usam <em>wolfe line search</em> para encontrar <span class="math inline">\(\alpha_i\)</span>. Porém, a descrição de tal estratégia está além dos objetivos deste livro. O algoritmo BFGS está implementado na função <code>optim()</code> por meio do argumento <code>method = "BFGS"</code>.</p>
<p>Da mesma forma que fizemos para os métodos baseados em gradiente, vamos apresentar implementações computacionais do método de Newton, DFP e BFGS apenas para ilustrar os aspectos básicos e dar alguma intuição de como funcionam. Importante ressaltar que nestas implementações vamos obter o <span class="math inline">\(\alpha_i\)</span> usando a estratégia <em>golden search</em> com as mesmas funções já criadas para os métodos baseados em gradiente. Os Códigos 3.33, 3.34 e 3.35 implementam os métodos Newton, DFP e BFGS, respectivamente.</p>
<p><strong>Código 3.33</strong> Implementação didática do método de Newton para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>newton <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, <span class="at">hessiano =</span> <span class="cn">NULL</span>, </span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">150</span>) {</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>)</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(hessiano)) {</span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>    hessiano <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">hessian</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto)</span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_iter) {</span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a>    J <span class="ot">&lt;-</span> <span class="fu">hessiano</span>(solucao[i,])</span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a>    grad <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(solucao[i,])</span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a>    solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">=</span> solucao[i,] <span class="sc">-</span> <span class="fu">solve</span>(J, grad)</span>
<span id="cb158-19"><a href="#cb158-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[i<span class="sc">+</span><span class="dv">1</span>,] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb158-20"><a href="#cb158-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb158-21"><a href="#cb158-21" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Solução"</span> <span class="ot">=</span> solucao[i,], <span class="st">"Iterações"</span> <span class="ot">=</span> solucao)</span>
<span id="cb158-22"><a href="#cb158-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb158-23"><a href="#cb158-23" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.34</strong> Implementação didática do método DFP para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb159"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>DFP <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, alpha, <span class="at">Hi =</span> <span class="cn">NULL</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">150</span>) {</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>, ...)</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para encontrar o alpha ótimo a cada iteração</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>  fc <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha, xk, funcao, gradiente, ...) {</span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    xk1 <span class="ot">&lt;-</span> xk <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> xk, ...)</span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>    out <span class="ot">&lt;-</span> <span class="fu">funcao</span>(xk1, ...)</span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(out)</span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Forma vetorizada para o grid search</span></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>  fc_vec <span class="ot">&lt;-</span> <span class="fu">Vectorize</span>(fc, <span class="st">"alpha"</span>)</span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Funcao para encontrar o alpha </span></span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>  get_alpha <span class="ot">&lt;-</span> <span class="cf">function</span>(xk, <span class="at">strategy =</span> <span class="st">"golden_search"</span>, interval, <span class="at">prec =</span> precisao, ...) {</span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"grid_search"</span>) {</span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a>      gride <span class="ot">&lt;-</span> <span class="fu">seq</span>(interval[<span class="dv">1</span>], interval[<span class="dv">2</span>], <span class="at">by =</span> prec)</span>
<span id="cb159-19"><a href="#cb159-19" aria-hidden="true" tabindex="-1"></a>      fc_value <span class="ot">&lt;-</span> <span class="fu">fc_vec</span>(<span class="at">alpha =</span> gride, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb159-20"><a href="#cb159-20" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> gride[<span class="fu">which.min</span>(fc_value)]</span>
<span id="cb159-21"><a href="#cb159-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb159-22"><a href="#cb159-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"golden_search"</span>) {</span>
<span id="cb159-23"><a href="#cb159-23" aria-hidden="true" tabindex="-1"></a>      out <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> fc, <span class="at">interval =</span> interval, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, </span>
<span id="cb159-24"><a href="#cb159-24" aria-hidden="true" tabindex="-1"></a>                      <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb159-25"><a href="#cb159-25" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> out<span class="sc">$</span>minimum</span>
<span id="cb159-26"><a href="#cb159-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb159-27"><a href="#cb159-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(alpha_otimo)</span>
<span id="cb159-28"><a href="#cb159-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb159-29"><a href="#cb159-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(Hi)) {Hi <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(inicial))}</span>
<span id="cb159-30"><a href="#cb159-30" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb159-31"><a href="#cb159-31" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb159-32"><a href="#cb159-32" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb159-33"><a href="#cb159-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb159-34"><a href="#cb159-34" aria-hidden="true" tabindex="-1"></a>    grad <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(solucao[i,])</span>
<span id="cb159-35"><a href="#cb159-35" aria-hidden="true" tabindex="-1"></a>    alpha[i] <span class="ot">&lt;-</span> <span class="fu">get_alpha</span>(<span class="at">xk =</span> solucao[i,], <span class="at">interval =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.2</span>), <span class="at">prec =</span> <span class="fl">0.01</span>)</span>
<span id="cb159-36"><a href="#cb159-36" aria-hidden="true" tabindex="-1"></a>    solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="ot">=</span> solucao[i,] <span class="sc">-</span> <span class="fu">as.numeric</span>(alpha[i]<span class="sc">*</span>Hi<span class="sc">%*%</span>grad)</span>
<span id="cb159-37"><a href="#cb159-37" aria-hidden="true" tabindex="-1"></a>    deltai <span class="ot">&lt;-</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="sc">-</span> solucao[i,]</span>
<span id="cb159-38"><a href="#cb159-38" aria-hidden="true" tabindex="-1"></a>    gammai <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),]) <span class="sc">-</span> <span class="fu">gradiente</span>(solucao[i,])</span>
<span id="cb159-39"><a href="#cb159-39" aria-hidden="true" tabindex="-1"></a>    Hi <span class="ot">&lt;-</span> Hi <span class="sc">-</span> Hi<span class="sc">%*%</span>gammai<span class="sc">%*%</span><span class="fu">t</span>(gammai)<span class="sc">%*%</span>Hi<span class="sc">/</span><span class="fu">as.numeric</span>((<span class="fu">t</span>(gammai)<span class="sc">%*%</span>Hi<span class="sc">%*%</span>gammai)) <span class="sc">+</span> </span>
<span id="cb159-40"><a href="#cb159-40" aria-hidden="true" tabindex="-1"></a>      deltai<span class="sc">%*%</span><span class="fu">t</span>(deltai)<span class="sc">/</span>(<span class="fu">as.numeric</span>(<span class="fu">t</span>(gammai)<span class="sc">%*%</span>deltai))</span>
<span id="cb159-41"><a href="#cb159-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb159-42"><a href="#cb159-42" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb159-43"><a href="#cb159-43" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Solução"</span> <span class="ot">=</span> solucao[i,], <span class="st">"Iterações"</span> <span class="ot">=</span> solucao)</span>
<span id="cb159-44"><a href="#cb159-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb159-45"><a href="#cb159-45" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Código 3.35</strong> Implementação didática do método BFGS para minimizar uma função.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>BFGS <span class="ot">&lt;-</span> <span class="cf">function</span>(inicial, funcao, <span class="at">gradiente =</span> <span class="cn">NULL</span>, alpha, <span class="at">Hi =</span> <span class="cn">NULL</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>, <span class="at">max_iter =</span> <span class="dv">150</span>) {</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(gradiente)) {</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    gradiente <span class="ot">&lt;-</span> <span class="cf">function</span>(ponto, ...) {</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>      numDeriv<span class="sc">::</span><span class="fu">grad</span>(<span class="at">func =</span> funcao, <span class="at">x =</span> ponto, <span class="at">method =</span> <span class="st">"simple"</span>, ...)</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Cria uma função para encontrar o alpha otimo a cada iteração</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>  fc <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha, xk, funcao, gradiente, ...) {</span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    xk1 <span class="ot">&lt;-</span> xk <span class="sc">-</span> alpha<span class="sc">*</span><span class="fu">gradiente</span>(<span class="at">ponto =</span> xk, ...)</span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>    out <span class="ot">&lt;-</span> <span class="fu">funcao</span>(xk1, ...)</span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(out)</span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Forma vetorizada para o grid search</span></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>  fc_vec <span class="ot">&lt;-</span> <span class="fu">Vectorize</span>(fc, <span class="st">"alpha"</span>)</span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Função para encontrar o alpha </span></span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true" tabindex="-1"></a>  get_alpha <span class="ot">&lt;-</span> <span class="cf">function</span>(xk, <span class="at">strategy =</span> <span class="st">"golden_search"</span>, <span class="at">interval =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), </span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true" tabindex="-1"></a>                        <span class="at">prec =</span> <span class="fl">0.01</span>, ...) {</span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"grid_search"</span>) {</span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true" tabindex="-1"></a>      gride <span class="ot">&lt;-</span> <span class="fu">seq</span>(interval[<span class="dv">1</span>], interval[<span class="dv">2</span>], <span class="at">by =</span> prec)</span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true" tabindex="-1"></a>      fc_value <span class="ot">&lt;-</span> <span class="fu">fc_vec</span>(<span class="at">alpha =</span> gride, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb160-21"><a href="#cb160-21" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> gride[<span class="fu">which.min</span>(fc_value)]</span>
<span id="cb160-22"><a href="#cb160-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb160-23"><a href="#cb160-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(strategy <span class="sc">==</span> <span class="st">"golden_search"</span>) {</span>
<span id="cb160-24"><a href="#cb160-24" aria-hidden="true" tabindex="-1"></a>      out <span class="ot">&lt;-</span> <span class="fu">optimize</span>(<span class="at">f =</span> fc, <span class="at">interval =</span> interval, <span class="at">xk =</span> xk, <span class="at">funcao =</span> funcao, </span>
<span id="cb160-25"><a href="#cb160-25" aria-hidden="true" tabindex="-1"></a>                      <span class="at">gradiente =</span> gradiente, ...)</span>
<span id="cb160-26"><a href="#cb160-26" aria-hidden="true" tabindex="-1"></a>      alpha_otimo <span class="ot">&lt;-</span> out<span class="sc">$</span>minimum</span>
<span id="cb160-27"><a href="#cb160-27" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb160-28"><a href="#cb160-28" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(alpha_otimo)</span>
<span id="cb160-29"><a href="#cb160-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb160-30"><a href="#cb160-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(Hi)) {Hi <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">1</span>, <span class="at">nrow =</span> <span class="fu">length</span>(inicial))}</span>
<span id="cb160-31"><a href="#cb160-31" aria-hidden="true" tabindex="-1"></a>  solucao <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="fu">length</span>(inicial), <span class="at">nrow =</span> max_iter)</span>
<span id="cb160-32"><a href="#cb160-32" aria-hidden="true" tabindex="-1"></a>  solucao[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb160-33"><a href="#cb160-33" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb160-34"><a href="#cb160-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(max_iter<span class="dv">-1</span>)) {</span>
<span id="cb160-35"><a href="#cb160-35" aria-hidden="true" tabindex="-1"></a>    grad <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(solucao[i,])</span>
<span id="cb160-36"><a href="#cb160-36" aria-hidden="true" tabindex="-1"></a>    alpha[i] <span class="ot">&lt;-</span> <span class="fu">get_alpha</span>(<span class="at">xk =</span> solucao[i,])</span>
<span id="cb160-37"><a href="#cb160-37" aria-hidden="true" tabindex="-1"></a>    solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="ot">=</span> solucao[i,] <span class="sc">-</span> <span class="fu">as.numeric</span>(alpha[i]<span class="sc">*</span>Hi<span class="sc">%*%</span>grad)</span>
<span id="cb160-38"><a href="#cb160-38" aria-hidden="true" tabindex="-1"></a>    deltai <span class="ot">&lt;-</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="sc">-</span> solucao[i,]</span>
<span id="cb160-39"><a href="#cb160-39" aria-hidden="true" tabindex="-1"></a>    gammai <span class="ot">&lt;-</span> <span class="fu">gradiente</span>(solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),]) <span class="sc">-</span> <span class="fu">gradiente</span>(solucao[i,])</span>
<span id="cb160-40"><a href="#cb160-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Bi &lt;- Bi + (gammai%*%t(gammai))/as.numeric(t(gammai)%*%deltai) -</span></span>
<span id="cb160-41"><a href="#cb160-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">#  (Bi%*%deltai%*%t(deltai)%*%t(Bi))/as.numeric(t(deltai)%*%Bi%*%deltai)</span></span>
<span id="cb160-42"><a href="#cb160-42" aria-hidden="true" tabindex="-1"></a>    term1 <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>((<span class="fu">t</span>(deltai)<span class="sc">%*%</span>gammai <span class="sc">+</span> <span class="fu">t</span>(gammai)<span class="sc">%*%</span>Hi<span class="sc">%*%</span>gammai))</span>
<span id="cb160-43"><a href="#cb160-43" aria-hidden="true" tabindex="-1"></a>    Hi <span class="ot">&lt;-</span> Hi <span class="sc">+</span> term1<span class="sc">*</span>(deltai<span class="sc">%*%</span><span class="fu">t</span>(deltai))<span class="sc">/</span><span class="fu">as.numeric</span>((<span class="fu">t</span>(deltai)<span class="sc">%*%</span>gammai)<span class="sc">^</span><span class="dv">2</span>) <span class="sc">-</span></span>
<span id="cb160-44"><a href="#cb160-44" aria-hidden="true" tabindex="-1"></a>      (Hi<span class="sc">%*%</span>gammai<span class="sc">%*%</span><span class="fu">t</span>(deltai) <span class="sc">+</span> deltai<span class="sc">%*%</span><span class="fu">t</span>(gammai)<span class="sc">%*%</span>Hi)<span class="sc">/</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(deltai)<span class="sc">%*%</span>gammai)</span>
<span id="cb160-45"><a href="#cb160-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),] <span class="sc">-</span> solucao[i,])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb160-46"><a href="#cb160-46" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb160-47"><a href="#cb160-47" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Solução"</span> <span class="ot">=</span> solucao[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>),], <span class="st">"Iterações"</span> <span class="ot">=</span> solucao)</span>
<span id="cb160-48"><a href="#cb160-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(out)</span>
<span id="cb160-49"><a href="#cb160-49" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Para ilustrar o uso de cada método vamos novamente minimizar a função da Equação (3.15).</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Método de Newton</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>nt <span class="ot">&lt;-</span> <span class="fu">newton</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj)</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Método DFP</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>dfp <span class="ot">&lt;-</span> <span class="fu">DFP</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj)</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Método BFGS</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>bfgs <span class="ot">&lt;-</span> <span class="fu">BFGS</span>(<span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">funcao =</span> fc_obj)</span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a><span class="do">## Solucao</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a><span class="fu">cbind</span>(nt<span class="sc">$</span>Solução, dfp<span class="sc">$</span>Solução, bfgs<span class="sc">$</span>Solução)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]      [,2]      [,3]
[1,] 2.0346688 2.0338099 2.0339711
[2,] 0.7371705 0.7374678 0.7374127</code></pre>
</div>
</div>
<p>Novamente os três métodos convergiram para praticamente o mesmo ponto, com diferença apenas na terceira casa decimal. Neste exemplo, o método de Newton precisou de apenas <span class="math inline">\(7\)</span> iterações para atingir convergência. Já os métodos DFP e BFGS precisaram de <span class="math inline">\(111\)</span> e <span class="math inline">\(109\)</span> iterações, respectivamente.</p>
<p>Para finalizar a discussão sobre os métodos baseados em hessiano, a Figura 3.20 apresenta o traço dos métodos de Newton, DFP e BFGS para minimizar a função da Equação (3.15).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-20" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/traceNewton-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.20: Traço dos algoritmos Newton (A), DFP (B) e BFGS (C).
</figcaption>
</figure>
</div>
</div>
</div>
<p>Fica claro que o método de Newton anda muito mais rapidamente na superfície da função objetivo, uma vez que usa o seu hessiano para dar o passo. O DFP e BFGS foram inicializados com <span class="math inline">\(\mathbf{H}_i = \mathbf{I}\)</span> o que significa que o primeiro passo é o mesmo que o do método <em>steepest descendent</em>. Entretanto, conforme <span class="math inline">\(\mathbf{H}_i\)</span> vai se distanciando da identidade os algoritmos vão explorando partes diferentes da função objetivo.</p>
</section>
<section id="métodos-baseados-em-simulação" class="level4" data-number="3.4.3.5">
<h4 data-number="3.4.3.5" class="anchored" data-anchor-id="métodos-baseados-em-simulação"><span class="header-section-number">3.4.3.5</span> Métodos baseados em simulação</h4>
<p>Os métodos baseados em simulação são computacionalmente intensivos e trabalham com a ideia de propor soluções de forma aleatória e a partir destas escolher as melhores para gerarem novas soluções e assim sucessivamente. De forma genérica os algoritmos baseados em simulação buscam maximizar a função objetivo e seguem as seguintes etapas:</p>
<ol type="1">
<li>Gere uma solução aleatória <span class="math inline">\(\mathbf{x}_1\)</span>;</li>
<li>Calcule a função objetivo no ponto simulado <span class="math inline">\(f(\mathbf{x}_1)\)</span>;</li>
<li>Gere uma solução <span class="math inline">\(\mathbf{x}_2\)</span> na vizinhança de <span class="math inline">\(\mathbf{x}_1\)</span> ;</li>
<li>Calcule a função objetivo no novo ponto <span class="math inline">\(f(\mathbf{x}_2)\)</span>:
<ul>
<li>Se <span class="math inline">\(f(\mathbf{x}_2) &gt; f(\mathbf{x}_1)\)</span> mova para <span class="math inline">\(\mathbf{x}_2\)</span>.</li>
<li>Se <span class="math inline">\(f(\mathbf{x}_2) &lt; f(\mathbf{x}_1)\)</span> TALVEZ mova para <span class="math inline">\(\mathbf{x}_2\)</span>.</li>
</ul></li>
<li>Repita passos 3-4 até atingir algum critério de convergência ou número máximo de iterações.</li>
</ol>
<p>Interessante notar que mesmo se a nova solução proposta não diminuir a função objetivo, o algoritmo ainda dá alguma chance para mover para este ponto. Essa estratégia é para fugir de pontos de mínimo local e consequentemente explorar de forma completa a superfície da função objetivo.</p>
<p>Para decidir se um ponto <span class="math inline">\(\mathbf{x}_2\)</span> quando <span class="math inline">\(f(\mathbf{x}_2) &lt; f(\mathbf{x}_1)\)</span> será aceito, usa-se uma probabilidade de aceitação <span class="math display">\[a = \exp{ (f(\mathbf{x}_2) - f(\mathbf{x}_1))/T},\]</span></p>
<p>onde <span class="math inline">\(T\)</span> é a <em>temperatura</em> (pense como um <em>tuning</em>). Se <span class="math inline">\(f(\mathbf{x}_2) &gt; f(\mathbf{x}_1)\)</span> então <span class="math inline">\(a &gt; 1\)</span>, assim o <span class="math inline">\(\mathbf{x}_2\)</span> será aceito com probabilidade 1. Por outro lado, se <span class="math inline">\(f(\mathbf{x}_2) &lt; f(\mathbf{x}_1)\)</span> então <span class="math inline">\(0 &lt; a &lt; 1\)</span>. Assim, <span class="math inline">\(\mathbf{x}_2\)</span> será aceito se <span class="math inline">\(a &gt; U(0,1)\)</span>. Para implementar este tipo de algoritmo precisamos entender como gerar uma solução na vizinhança de um ponto qualquer. Isso nem sempre é trivial e em geral usa ideias de probabilidade condicional que não serão abordadas neste texto.</p>
<p>O algoritmo <em>Simulating annealing</em> é provavelmente o mais popular desta classe e está disponível na função <code>optim()</code> por meio da opção <code>method = "SANN"</code>. O uso é idêntico ao método de Nelder-Mead e ilustrado no Código 3.36.</p>
<p><strong>Código 3.36</strong> Ilustração do uso do método <em>Simulating annealing</em>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>otimo <span class="ot">&lt;-</span> <span class="fu">optim</span>(<span class="at">par =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">fn =</span> fc_obj, <span class="at">method =</span> <span class="st">"SANN"</span>)</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>otimo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$par
[1] 2.055357 0.726176

$value
[1] 12.84608

$counts
function gradient 
   10000       NA 

$convergence
[1] 0

$message
NULL</code></pre>
</div>
</div>
<p>Assim, chegamos ao fim da apresentação dos principais algoritmos de programação não-linear. Uma pergunta que fica é como escolher o melhor algoritmo para uma situação prática. Infelizmente, não existe uma resposta precisa para esta pergunta. Porém, podemos ao menos indicar ao leitor algumas recomendações práticas:</p>
<ol type="1">
<li>Se a função a ser otimizada é diferenciável e o problema é de médio porte (algumas dezenas de parâmetros), o algoritmo de Newton é uma boa opção. Porém, o ideal é que tanto o gradiente quando o hessiano sejam obtidos de forma analítica. O uso de derivadas numéricas é caro computacionalmente e o custo cresce rapidamente com o número de parâmetros a serem otimizados.</li>
<li>Se a função a ser otimizada é diferenciável e o problema é de grande porte (centenas ou milhares de parâmetros), não há muita escolha, os métodos baseados em gradiente devem ser usados. Dê preferência ao gradiente descendente e sua versão gradiente descendente estocástico.</li>
<li>Se o problema é de pequeno a médio porte e você não conhece o comportamento da função objetivo e quer usar um algoritmo numérico apenas para ter uma noção inicial e rápida do problema, recomenda-se o uso do algoritmo de Nelder-Mead. Neste caso é sempre indicado inicializar o algoritmo em diferentes valores iniciais e verificar se o resultado é sensível à escolha dos valores iniciais. Se sim, o algoritmo recomendado é o <em>Simulating annealing</em>.</li>
</ol>
<p>Por fim, lembre-se que os algoritmos numéricos tratam todos os parâmetros da mesma forma, porém em muitas situações você terá parâmetros que representam características ou mesmo grandezas diferentes. Assim, sempre que possível é recomendado transformar os parâmetros para que estejam na mesma escala. Neste sentido, padronizar as entradas é uma opção interessante. Em outras situações, pode ser que os parâmetros tenham espaço paramétricos diferentes. Neste caso o recomendado é fazer uma reparametrização para tornar todos os parâmetros irrestritos, ou seja, o espaço paramétrico seja toda a reta real. Por fim, ao utilizar algoritmos genéricos como os implementados na função <code>optim()</code> é importante que a sua função seja a prova de erros. Assim, você evita que o algoritmo pare a busca pelo ótimo. Para isto, você precisa entender o comportamento da sua função e fazer o tratamento de exceção adequado.</p>
</section>
</section>
</section>
<section id="referências-bibliográficas" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="referências-bibliográficas"><span class="header-section-number">3.5</span> Referências bibliográficas</h2>
<p>Para construir este capítulo não foi utilizado um único livro que contemplasse todos os tópicos. Como base para solução de equações não-lineares e diferenciação numérica foi consultado Gilat and Subramaniam (2009). Para a parte de integração numérica foi bastante difícil encontrar uma referência abrangente, principalmente para os métodos de quadratura Gaussiana adaptativa e Monte Carlo. Deixo como referência a documentação do pacote <code>pracma</code> Borchers (2021) para a parte de quadratura Gaussiana. Para a quadratura adaptativa e aproximação de Laplace o livro Molenberghs and Verbeke (2006) apresenta um pequeno resumo, mas suficiente para o entendimento e implementação dos métodos. Por fim, para a parte de otimização foi utilizada a documentação do pacote <code>lpSolve</code> Berkelaar and others (2020) e o livro Becker, Chambers, and Wilks (1988) que é a principal referência usada pela função <code>optim()</code>.</p>
</section>
<section id="exercícios" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="exercícios"><span class="header-section-number">3.6</span> Exercícios</h2>
<p>Os exercícios deste livro são na forma de tutoriais interativos.</p>
<p>Acesse <a href=".\Exercicios.qmd">Exercícios Métodos Numéricos</a>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../content/Modulo02/index.html" class="pagination-link  aria-label=" &lt;span="" matricial&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Álgebra Matricial</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../content/Modulo04/index.html" class="pagination-link" aria-label="<span class='chapter-number'>4</span>&nbsp; <span class='chapter-title'>Função de Distribuição Empírica</span>">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Função de Distribuição Empírica</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Estatística 2023-2026</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://raymz1990.github.io/CE313/edit/main/book/content/Modulo03/index.qmd" class="toc-action"><i class="bi bi-git"></i>Edit this page</a></li><li><a href="https://raymz1990.github.io/CE313/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>