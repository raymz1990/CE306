<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CE306 - Instrumentação Matemática para Estatística - 2&nbsp; Álgebra Matricial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../content/Modulo03/index.html" rel="next">
<link href="../../content/Modulo01/index.html" rel="prev">
<link href="../../default_overview_image.jpg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../custom.css">
<meta property="og:title" content="CE306 - Instrumentação Matemática para Estatística - 2&nbsp; Álgebra Matricial">
<meta property="og:description" content="Material da disciplina CE306 - Instrumentação Matemática para Estatística do curso de Estatística da Universidade Federal do Paraná (UFPR).">
<meta property="og:image" content="default_overview_image.jpg">
<meta property="og:site_name" content="CE306 - Instrumentação Matemática para Estatística">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../content/Modulo02/index.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Álgebra Matricial</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">CE306 - Instrumentação Matemática para Estatística</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://raymz1990.github.io/CE313/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-git"></i></a>
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="../../CE306---Instrumentação-Matemática-para-Estatística.pdf">
              <i class="bi bi-bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="../../CE306---Instrumentação-Matemática-para-Estatística.docx">
              <i class="bi bi-bi-file-word pe-1"></i>
            Download Docx
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Apresentação</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefácio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo01/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Cálculo Diferencial e Integral</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo02/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Álgebra Matricial</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo03/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estatística Não Paramétrica 2</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo04/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Função de Distribuição Empírica</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Exercicios</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo01/Exercicios/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Cálculo Diferencial e Integral para Cientista de Dados</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/Modulo02/Exercicios/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Algebra Matricial</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#vetores-e-escalares" id="toc-vetores-e-escalares" class="nav-link active" data-scroll-target="#vetores-e-escalares"><span class="header-section-number">2.1</span> Vetores e escalares</a>
  <ul class="collapse">
  <li><a href="#operações-com-vetores" id="toc-operações-com-vetores" class="nav-link" data-scroll-target="#operações-com-vetores"><span class="header-section-number">2.1.1</span> Operações com vetores</a></li>
  </ul></li>
  <li><a href="#matrizes" id="toc-matrizes" class="nav-link" data-scroll-target="#matrizes"><span class="header-section-number">2.2</span> Matrizes</a>
  <ul class="collapse">
  <li><a href="#operações-com-matrizes" id="toc-operações-com-matrizes" class="nav-link" data-scroll-target="#operações-com-matrizes"><span class="header-section-number">2.2.1</span> Operações com matrizes</a></li>
  <li><a href="#matrizes-de-formas-especiais" id="toc-matrizes-de-formas-especiais" class="nav-link" data-scroll-target="#matrizes-de-formas-especiais"><span class="header-section-number">2.2.2</span> Matrizes de formas especiais</a></li>
  <li><a href="#rank-e-inversa-de-uma-matriz" id="toc-rank-e-inversa-de-uma-matriz" class="nav-link" data-scroll-target="#rank-e-inversa-de-uma-matriz"><span class="header-section-number">2.2.3</span> <em>Rank </em> e inversa de uma matriz</a></li>
  <li><a href="#matrizes-positivas-definidas" id="toc-matrizes-positivas-definidas" class="nav-link" data-scroll-target="#matrizes-positivas-definidas"><span class="header-section-number">2.2.4</span> Matrizes positivas definidas</a></li>
  <li><a href="#determinante-e-traço-de-uma-matriz" id="toc-determinante-e-traço-de-uma-matriz" class="nav-link" data-scroll-target="#determinante-e-traço-de-uma-matriz"><span class="header-section-number">2.2.5</span> Determinante e traço de uma matriz</a></li>
  <li><a href="#cálculo-vetorial-e-matricial" id="toc-cálculo-vetorial-e-matricial" class="nav-link" data-scroll-target="#cálculo-vetorial-e-matricial"><span class="header-section-number">2.2.6</span> Cálculo vetorial e matricial</a></li>
  <li><a href="#regressão-linear-múltipla" id="toc-regressão-linear-múltipla" class="nav-link" data-scroll-target="#regressão-linear-múltipla"><span class="header-section-number">2.2.7</span> Regressão linear múltipla</a></li>
  </ul></li>
  <li><a href="#sistemas-de-equações-lineares" id="toc-sistemas-de-equações-lineares" class="nav-link" data-scroll-target="#sistemas-de-equações-lineares"><span class="header-section-number">2.3</span> Sistemas de equações lineares</a>
  <ul class="collapse">
  <li><a href="#métodos-diretos" id="toc-métodos-diretos" class="nav-link" data-scroll-target="#métodos-diretos"><span class="header-section-number">2.3.1</span> Métodos diretos</a></li>
  <li><a href="#métodos-iterativos" id="toc-métodos-iterativos" class="nav-link" data-scroll-target="#métodos-iterativos"><span class="header-section-number">2.3.2</span> Métodos iterativos</a></li>
  <li><a href="#decomposição-lu" id="toc-decomposição-lu" class="nav-link" data-scroll-target="#decomposição-lu"><span class="header-section-number">2.3.3</span> Decomposição LU</a></li>
  <li><a href="#cálculo-da-inversa" id="toc-cálculo-da-inversa" class="nav-link" data-scroll-target="#cálculo-da-inversa"><span class="header-section-number">2.3.4</span> Cálculo da inversa</a></li>
  </ul></li>
  <li><a href="#autovalores-e-autovetores" id="toc-autovalores-e-autovetores" class="nav-link" data-scroll-target="#autovalores-e-autovetores"><span class="header-section-number">2.4</span> Autovalores e autovetores</a></li>
  <li><a href="#decomposição-em-valores-singulares" id="toc-decomposição-em-valores-singulares" class="nav-link" data-scroll-target="#decomposição-em-valores-singulares"><span class="header-section-number">2.5</span> Decomposição em valores singulares</a></li>
  <li><a href="#regressão-ridge" id="toc-regressão-ridge" class="nav-link" data-scroll-target="#regressão-ridge"><span class="header-section-number">2.6</span> Regressão ridge</a></li>
  <li><a href="#referências-bibliográficas" id="toc-referências-bibliográficas" class="nav-link" data-scroll-target="#referências-bibliográficas"><span class="header-section-number">2.7</span> 2.7 Referências bibliográficas</a></li>
  <li><a href="#exercícios" id="toc-exercícios" class="nav-link" data-scroll-target="#exercícios"><span class="header-section-number">2.8</span> 2.8 Exercícios</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://raymz1990.github.io/CE313/edit/main/book/content/Modulo02/index.qmd" class="toc-action"><i class="bi bi-git"></i>Edit this page</a></li><li><a href="https://raymz1990.github.io/CE313/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Álgebra Matricial</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>A técnica escolhida para ilustrar os conceitos de funções e derivadas em ciência de dados foi o modelo de regressão linear simples. Nós vimos na Seção 1.2.9 que neste modelo o treinamento, ou estimação dos parâmetros, se resumiu a encontrar a solução de um sistema de duas equações lineares. Agora imagine uma situação prática com milhares de potenciais variáveis explicativas: como seria o treinamento deste modelo? Assim, fica claro que precisamos de ferramentas que nos permitam lidar com muitas equações simultâneas e de preferência de uma forma compacta e eficiente. É neste contexto que as ferramentas de Álgebra Matricial são valiosas em ciência de dados.</p>
<p>O objetivo deste Capítulo é apresentar as principais ferramentas de <strong>Álgebra Matricial</strong> úteis em ciência de dados. Como exemplo ilustrativo será apresentado o modelo de regressão linear múltipla que estende o modelo de regressão linear simples permitindo um número arbitrário de variáveis explicativas. Para a sua representação utilizaremos uma notação matricial em que o modelo é escrito matematicamente de uma forma compacta e de fácil entendimento. Além disso, as ferramentas de Álgebra Matricial vão permitir obter equações compactas para os estimadores dos coeficientes de regressão, o que facilita o processo de treinamento do modelo.</p>
<p>Por fim, nós vamos discutir algumas decomposições matriciais que consistem em escrever a matriz gerada pelos dados em formas convenientes para o processo de treinamento e discutir como utilizar tais decomposições em ciência de dados. Especial ênfase será dada ao caso de problemas em que o número de variáveis explicativas é maior que o número de observações ( <em>High Dimensional data </em>). Nestas situações a decomposição em valores singulares leva ao modelo de regressão <em>ridge </em>, também bastante popular em ciência de dados e uma extensão natural do modelo de regressão linear múltipla.</p>
<section id="vetores-e-escalares" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="vetores-e-escalares"><span class="header-section-number">2.1</span> Vetores e escalares</h2>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.1</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Um vetor é uma lista de <span class="math inline">\(n\)</span> números (elementos ou componentes) escritos em linha ou coluna.</p>
</div>
</div>
<p>Em termos de notação nós vamos usar letras minúsculas em negrito, por exemplo,</p>
<p><span class="math display">\[
\mathbf{a} = \begin{pmatrix}
a_1 &amp; \ldots &amp; a_n
\end{pmatrix} \quad \text{ou} \quad \mathbf{a} = \begin{pmatrix}
a_1 \\
\vdots \\
a_n
\end{pmatrix}.
\]</span></p>
<p>Quando os elementos estão organizados em linha dizemos que temos um <strong>vetor linha</strong>. Por outro lado, quando os elementos estão organizados em coluna dizemos que temos um <strong>vetor coluna</strong>. Um elemento do vetor é chamado de <span class="math inline">\(a_i\)</span>, sendo <span class="math inline">\(i\)</span> a posição do elemento no vetor. O <strong>tamanho de um vetor</strong> é o seu número de elementos.</p>
<p>O <strong>módulo de um vetor</strong> é o seu comprimento</p>
<p><span class="math display">\[
|\mathbf{a}| = \sqrt{a_1^2 + \ldots + a_n^2}.
\]</span></p>
<p>O vetor unitário é o vetor com comprimento <span class="math inline">\(1\)</span>. Podemos padronizar um vetor qualquer para ter tamanho <span class="math inline">\(1\)</span> dividindo cada elemento do vetor pelo seu comprimento,</p>
<p><span class="math display">\[
\hat{\mathbf{a}} =  \frac{\mathbf{a}}{|\mathbf{a}|}.
\]</span></p>
<p>Dizemos que dois vetores são iguais se têm o mesmo tamanho e se todos os seus elementos em posições equivalentes são iguais.</p>
<section id="operações-com-vetores" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="operações-com-vetores"><span class="header-section-number">2.1.1</span> Operações com vetores</h3>
<p>Da mesma forma que podemos fazer operações soma, subtração, multiplicação e divisão com números (no contexto de Álgebra Linear são chamados de <strong>escalares</strong>) também podemos fazer operações com vetores. No entanto, nem todas as operações usuais de escalares são válidas para vetores. De forma geral, vetores podem ser somados, subtraídos e multiplicados de forma especial. Porém, vetores não podem ser divididos e existem algumas operações especiais com vetores como o produto interno. Dois vetores podem ser somados ou subtraídos apenas se forem do mesmo tipo (linha ou coluna) e do mesmo tamanho. Para definirmos as operações com vetores, considere dois vetores <span class="math inline">\(\mathbf{a}\)</span> e <span class="math inline">\(\mathbf{b}\)</span> adequados, ou seja, mesmo tipo e tamanho, e <span class="math inline">\(\alpha\)</span> um escalar, as seguintes operações são bem definidas:</p>
<ol type="1">
<li>Soma: <span class="math inline">\(\mathbf{a} + \mathbf{b} = (a_i + b_i) = (a_1 + b_1, \ldots, a_n + b_n).\)</span></li>
<li>Subtração: <span class="math inline">\(\mathbf{a} - \mathbf{b} = (a_i - b_i) = (a_1 - b_1, \ldots, a_n - b_n).\)</span></li>
<li>Multiplicação por escalar: <span class="math inline">\(\alpha \mathbf{a} = (\alpha a_1, \ldots, \alpha a_n)\)</span>.</li>
<li>Transposta de um vetor: a operação transposta transforma um <strong>vetor coluna</strong> em um <strong>vetor linha</strong> e vice-versa. Por exemplo,</li>
</ol>
<p><span class="math display">\[
\mathbf{a} = \begin{pmatrix}
a_1 &amp; \ldots &amp; a_n
\end{pmatrix} \quad  \quad \mathbf{a}^{\top} = \begin{pmatrix}
a_1 \\
\vdots \\
a_n
\end{pmatrix}.
\]</span></p>
<ol start="5" type="1">
<li>Produto interno ou escalar entre dois vetores resulta em um escalar:</li>
</ol>
<p><span class="math display">\[
\mathbf{a} \cdot \mathbf{b} = (a_1 b_1 + a_2 b_2 + \ldots + a_n b_n).
\]</span></p>
<p>O co-seno do ângulo <span class="math inline">\(\theta\)</span> entre os vetores <span class="math inline">\(\mathbf{a}\)</span> e <span class="math inline">\(\mathbf{b}\)</span> é dado por:</p>
<p><span class="math display">\[
\begin{equation}    
\cos(\theta)=\frac{\mathbf{a}^{\top}\mathbf{b}}{\sqrt{\mathbf{a}^{\top}\mathbf{a}}\sqrt{\mathbf{b}^{\top}\mathbf{b}}}.
\end{equation}
\]</span></p>
<p>Dizemos que dois vetores são <strong>ortogonais</strong> entre si se o ângulo <span class="math inline">\(\theta\)</span> entre eles é 90º o que implica que <span class="math inline">\(\cos(\theta)=0\)</span> e que <span class="math inline">\(\mathbf{a}^{\top} \mathbf{b}=0\)</span>. Todas as operações descritas para vetores são trivialmente definidas em <code>R</code>. Vamos ver alguns exemplos. Para declarar um vetor em <code>R</code> usamos a função <code>c()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sendo os vetores compatíveis podemos facilmente somá-los, subtraí-los, multiplicar por um escalar ou obter o produto interno, conforme ilustrado no Código 2.1. Porém, cabe enfatizar que a divisão entre vetores não é definida.</p>
<p><strong>Código 2.1</strong> Operações com vetores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Soma</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>a <span class="sc">+</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5 7 9</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Subtração</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>a <span class="sc">-</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3 3 3</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiplicação por escalar</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>alpha <span class="sc">*</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 40 50 60</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Produto interno</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>a <span class="sc">%*%</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]   32</code></pre>
</div>
</div>
<p>Neste ponto é importante falar sobre a <strong>lei da reciclagem</strong> em <code>R</code> e dos cuidados que devemos ter ao fazer operações com vetores.</p>
<p>Vamos definir dois vetores, <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span>, porém de tamanhos diferentes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>a <span class="sc">+</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  5  7  9  6  8 10</code></pre>
</div>
</div>
<p>Note que apesar dos vetores não serem compatíveis para a soma, o <code>R</code> realizou alguma operação. É neste ponto que aparece a <strong>lei da reciclagem</strong>. Veja que os três primeiros elementos do vetor resultante da soma de <code>a + b</code> são <span class="math inline">\(4 + 1 = 5; 5 + 2 = 7\)</span> e <span class="math inline">\(6 + 3 = 9\)</span>. Porém, o <code>R</code> ainda reporta mais três números que são o resultado de <span class="math inline">\(5 + 1 = 6; 6 + 2 = 8\)</span> e <span class="math inline">\(7 + 3 = 10\)</span>, ou seja, o <code>R</code> reciclou os elementos do vetor <code>b</code> para completar a tarefa de somar <code>a + b</code>. Portanto, é muito importante tomar cuidado ao fazer operações com vetores em <code>R</code>.</p>
<p>Um outro ponto importante é a forma de fazer a multiplicação entre vetores. Veja o uso do operador especial <code>%*%</code> para a multiplicação entre vetores. O símbolo usual de multiplicação <code>*</code> não realiza a multiplicação vetorial, mas sim uma multiplicação elemento por elemento, também chamada de produto de Hadamard.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiplicação elemento a elemento (Hadamard)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>a<span class="sc">*</span>b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  4 10 18</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiplicação entre vetores</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>a<span class="sc">%*%</span>b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]   32</code></pre>
</div>
</div>
<p>Usando as operações com vetores podemos facilmente calcular o co-seno do ângulo <span class="math inline">\(\theta\)</span> entre dois vetores compatíveis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>cos_theta <span class="ot">&lt;-</span> <span class="fu">t</span>(a)<span class="sc">%*%</span>b<span class="sc">/</span>(<span class="fu">sqrt</span>(<span class="fu">t</span>(a)<span class="sc">%*%</span>a)<span class="sc">*</span><span class="fu">sqrt</span>(<span class="fu">t</span>(b)<span class="sc">%*%</span>b))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>cos_theta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]
[1,] 0.9746318</code></pre>
</div>
</div>
</section>
</section>
<section id="matrizes" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="matrizes"><span class="header-section-number">2.2</span> Matrizes</h2>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.2</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Uma <strong>matriz</strong> é um arranjo retangular ou quadrado de números ou variáveis. Uma matriz <span class="math inline">\((n \times m)\)</span> tem <span class="math inline">\(n\)</span> linhas e <span class="math inline">\(m\)</span> colunas:</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1m} \\
a_{21} &amp; a_{22} &amp; \ddots &amp; a_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp;  \vdots \\
a_{n1} &amp; \ldots &amp; \ldots &amp; a_{nm}
\end{pmatrix}.
\]</span></p>
</div>
</div>
<p>Em termos de notação, nós vamos usar letras maiúsculas em negrito para representar uma matriz, por exemplo: <span class="math inline">\(\mathbf{A}\)</span>. Neste livro os elementos de uma matriz serão números reais ou variáveis representando números reais. Por exemplo, a matriz <span class="math inline">\(\mathbf{A}\)</span> representa as notas e o número de faltas de três alunos do curso de estatística básica. Cada linha representa um aluno, a primeira coluna a nota e a segunda o número de faltas.</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
80 &amp; 0 \\
95 &amp; 1 \\
70 &amp; 5
\end{pmatrix}.
\]</span></p>
<p>Para representar os elementos da matriz como variáveis ou incógnitas, usamos letras minúsculas, por exemplo,</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22} \\
a_{31} &amp; a_{32}
\end{pmatrix}.
\]</span></p>
<p>Vamos adotar que o primeiro subscrito representa linha e o segundo a coluna do elemento, ou seja, <span class="math inline">\(a_{\text{linha}\;\text{coluna}}\)</span>. Assim, podemos representar a matriz também por meio dos seus elementos, <span class="math inline">\(\mathbf{A} = a_{ij}\)</span> para <span class="math inline">\(i=1, \ldots, n\)</span> e <span class="math inline">\(j=1, \ldots, m\)</span> onde <span class="math inline">\(n\)</span> e <span class="math inline">\(m\)</span> são o número de linhas e colunas da matriz, respectivamente. Para o exemplo dos alunos, temos <span class="math inline">\(n = 3\)</span> e <span class="math inline">\(m = 2\)</span>. É comum referenciar uma matriz pela sua dimensão ou tamanho, ou seja, o número de linhas e colunas. Dizemos, então que <span class="math inline">\(\mathbf{A}\)</span> tem dimensão <span class="math inline">\(n \times m\)</span>, leia-se “A matriz <span class="math inline">\(\mathbf{A}\)</span> tem dimensão <span class="math inline">\(n\)</span> por <span class="math inline">\(m\)</span>.” Particularizando para o nosso exemplo <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(3 \times 2\)</span>. Note que um vetor é simplesmente uma matriz com apenas uma linha ou uma coluna. De forma similar, podemos pensar que um escalar é apenas uma matriz de dimensão <span class="math inline">\(1 \times 1\)</span>. No entanto, um escalar é tecnicamente diferente de uma matriz <span class="math inline">\(1 \times 1\)</span> em termos de aplicações e propriedades em Álgebra Linear. Tais diferenças ficarão claras no decorrer do Capítulo. Dizemos que duas matrizes são iguais se tem a mesma dimensão e se os elementos das correspondentes posições são iguais. A operação de transpor também é definida para matrizes de forma similar ao realizado para vetores. Assim, a operação de transposição rearranja uma matriz de forma que suas linhas são transformadas em colunas e vice-versa. Considere o exemplo,</p>
<p><span class="math display">\[
\begin{pmatrix}
1 &amp; 2\\
3 &amp; 4\\
5 &amp; 6
\end{pmatrix}^{\top} =
\begin{pmatrix}
1 &amp; 3 &amp; 5\\
2 &amp; 4 &amp; 6
\end{pmatrix}.
\]</span></p>
<p>Além disso, é claro que <span class="math inline">\((\mathbf{A}^{\top})^{\top} = \mathbf{A}\)</span>, ou seja, a transposta da transposta de uma matriz é a matriz original. Para definir uma matriz em <code>R</code> usamos o comando <code>matrix()</code> que permite rearranjar um vetor em uma matriz. O Código 2.2 define uma matriz <span class="math inline">\(3 \times 2\)</span> em <code>R</code>.</p>
<p><strong>Código 2.2</strong> Inicialização de uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(a, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6</code></pre>
</div>
</div>
<p>Por <em>default </em> o <code>R</code> vai preencher a matriz por coluna. Assim, os primeiros três valores do vetor formam a primeira coluna, enquanto que os três últimos formam a segunda coluna. Os argumentos <code>nrow</code> e <code>ncol</code> definem o número de linhas e colunas da matriz resultante. É possível também preencher a matriz por linhas, caso seja de interesse. Neste caso usamos o argumento <code>byrow = TRUE</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(a, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6</code></pre>
</div>
</div>
<p>A transposição de uma matriz ou vetor é realizada pela função <code>t()</code>, conforme ilustrado no Código 2.3.</p>
<p><strong>Código 2.3</strong> Transposta de uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Transposta de uma matriz</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6</code></pre>
</div>
</div>
<section id="operações-com-matrizes" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="operações-com-matrizes"><span class="header-section-number">2.2.1</span> Operações com matrizes</h3>
<p>Algumas operações entre matrizes e vetores também são definidas. Qualquer escalar pode ser multiplicado por qualquer matriz da seguinte forma:</p>
<p><span class="math display">\[
\alpha \mathbf{A} = \begin{pmatrix}
\alpha a_{11} &amp; \alpha a_{12} &amp; \ldots &amp; \alpha a_{1m} \\
\alpha a_{21} &amp; \alpha a_{22} &amp; \ddots &amp; \alpha a_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp;  \vdots \\
\alpha a_{n1} &amp; \ldots &amp; \ldots &amp; \alpha a_{nm}
\end{pmatrix}.
\]</span></p>
<p>Em palavras, multiplicar um escalar por uma matriz é simplesmente multiplicar cada entrada da matriz pelo escalar de interesse. O resultado é uma matriz de mesma dimensão da matriz original. Note ainda que <span class="math inline">\(\alpha \mathbf{A} = \mathbf{A} \alpha\)</span>. O código 2.4 ilustra tal operação em <code>R</code>.</p>
<p><strong>Código 2.4</strong> Multiplicação de escalar por matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>alpha<span class="sc">*</span>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]   10   40
[2,]   20   50
[3,]   30   60</code></pre>
</div>
</div>
<p>Duas matrizes podem ser somadas ou subtraídas somente se tiverem o mesmo tamanho. O resultado da soma ou subtração de duas matrizes <span class="math inline">\(\mathbf{A}\)</span> e <span class="math inline">\(\mathbf{B}\)</span> ambas <span class="math inline">\((n \times m)\)</span> é uma matriz <span class="math inline">\(\mathbf{C}\)</span> de mesmo tamanho cujos elementos são dados por:</p>
<ol type="1">
<li>Soma <span class="math inline">\(c_{ij} = a_{ij} + b_{ij}.\)</span></li>
<li>Subtração <span class="math inline">\(c_{ij} = a_{ij} - b_{ij}.\)</span></li>
</ol>
<p>Por exemplo,</p>
<p><span class="math display">\[
\begin{pmatrix}
1 &amp; 2\\
3 &amp; 4\\
5 &amp; 6
\end{pmatrix} + \begin{pmatrix}
10 &amp; 20\\
30 &amp; 40 \\
50 &amp; 60
\end{pmatrix} =
\begin{pmatrix}
11 &amp; 22\\
33 &amp; 44\\
55 &amp; 66
\end{pmatrix}.
\]</span></p>
<p>O Código 2.5 ilustra a soma de matrizes em <code>R</code>.</p>
<p><strong>Código 2.5</strong> Soma de matrizes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>,<span class="dv">50</span>,<span class="dv">60</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>C <span class="ot">=</span> A <span class="sc">+</span> B</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]   11   44
[2,]   22   55
[3,]   33   66</code></pre>
</div>
</div>
<p>A multiplicação <span class="math inline">\(\mathbf{C} = \mathbf{A} \mathbf{B}\)</span> é definida apenas quando o número de colunas de <span class="math inline">\(\mathbf{A}\)</span> é igual ao número de linhas de <span class="math inline">\(\mathbf{B}\)</span>. <span class="math inline">\(\underset{m \times n}{\mathbf{C}} = \underset{m \times q}{\mathbf{A}} \underset{q \times n}{\mathbf{B}}\)</span>. Cada elemento <span class="math inline">\(c_{ij} = \sum_{k = 1}^q a_{ik} b_{kj}.\)</span></p>
<p>Por exemplo,</p>
<p><span class="math display">\[
\begin{pmatrix}
2 &amp; -1\\
8 &amp; 3\\
6 &amp; 7
\end{pmatrix} \begin{pmatrix}
4 &amp; 9 &amp; 1 &amp; -3\\
-5 &amp; 2 &amp; 4 &amp; 6
\end{pmatrix} =
\]</span></p>
<p><span class="math display">\[
\begin{pmatrix}
(2 \cdot 4 + -1 \cdot-5) &amp; (2\cdot 9 + -1 \cdot 2) &amp; (2\cdot1 + -1 \cdot 4) &amp; (2 \cdot -3 + -1 \cdot 6) \\
(8\cdot 4 + 3 \cdot -5) &amp; (8\cdot 9 + 3 \cdot 2)  &amp; (8 \cdot 1 + 3 \cdot 4) &amp; (8 \cdot -3 + 3 \cdot 6) \\
(6\cdot4 + 7\cdot -5) &amp; (6 \cdot 9 + 7 \cdot 2)  &amp; (6 \cdot 1 + 7 \cdot 4) &amp; (6 \cdot - 3 + 7 \cdot 6)
\end{pmatrix} =
\]</span></p>
<p><span class="math display">\[
\begin{pmatrix}
13 &amp; 16 &amp; -2 &amp; -12\\
17 &amp; 78 &amp; 20 &amp; -6\\
-11 &amp; 68 &amp; 34 &amp; 24
\end{pmatrix}.
\]</span></p>
<p>O Código 2.6 ilustra a multiplicação de matrizes em <code>R</code>. Novamente note o uso do operador especial <code>%*%</code> ao invés do símbolo usual de multiplicação <code>*</code>.</p>
<p><strong>Código 2.6</strong> Multiplicação de matrizes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">8</span>,<span class="dv">6</span>,<span class="sc">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">7</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">4</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="dv">6</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">4</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>C <span class="ot">=</span> A<span class="sc">%*%</span>B</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]   13   16   -2  -12
[2,]   17   78   20   -6
[3,]  -11   68   34   24</code></pre>
</div>
</div>
<p>Em geral <span class="math inline">\(\mathbf{A} \mathbf{B} \neq \mathbf{B} \mathbf{A}\)</span>. Veja que no caso das matrizes do exemplo anterior <span class="math inline">\(\mathbf{B}\)</span> tem dimensão <span class="math inline">\(2\times 4\)</span>, enquanto <span class="math inline">\(\mathbf{A}\)</span> tem dimensão <span class="math inline">\(3 \times 2\)</span>, e portanto o produto não pode ser feito. Apenas como ilustração o Código 2.7 tenta realizar a multiplicação entre duas matrizes não compatíveis.</p>
<p><strong>Código 2.7</strong> Multiplicação de matrizes não compatíveis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>B <span class="sc">%*%</span> A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>Error in B %*% A: argumentos não compatíveis</code></pre>
</div>
</div>
<p>Neste caso o <code>R</code> retorna uma mensagem de erro indicando que as matrizes não são compatíveis para multiplicação. Algumas propriedades da multiplicação de matrizes são apresentadas a seguir. Sendo <span class="math inline">\(\mathbf{A}, \mathbf{B}, \mathbf{C}\)</span> e <span class="math inline">\(\mathbf{D}\)</span> compatíveis temos,</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{A} + \mathbf{B} = \mathbf{B} + \mathbf{A}\)</span>.</li>
<li><span class="math inline">\((\mathbf{A} + \mathbf{B}) + \mathbf{C} = \mathbf{A} + (\mathbf{B} + \mathbf{C}).\)</span></li>
<li><span class="math inline">\(\alpha (\mathbf{A} + \mathbf{B}) = \alpha \mathbf{A} + \alpha \mathbf{B}.\)</span></li>
<li><span class="math inline">\((\alpha + \beta) \mathbf{A} = \alpha \mathbf{A} + \beta \mathbf{A}.\)</span></li>
<li><span class="math inline">\(\alpha(\mathbf{A}\mathbf{B}) = (\alpha \mathbf{A})\mathbf{B} = \mathbf{A}(\alpha \mathbf{B}).\)</span></li>
<li><span class="math inline">\(\mathbf{A}(\mathbf{B} \pm \mathbf{C}) = \mathbf{A}\mathbf{B} \pm \mathbf{A}\mathbf{C}.\)</span></li>
<li><span class="math inline">\((\mathbf{A} \pm \mathbf{B})\mathbf{C} = \mathbf{A}\mathbf{C} \pm \mathbf{B}\mathbf{C}.\)</span></li>
<li><span class="math inline">\((\mathbf{A} - \mathbf{B})(\mathbf{C} - \mathbf{D}) = \mathbf{A}\mathbf{C} - \mathbf{B}\mathbf{C} - \mathbf{A}\mathbf{D} + \mathbf{B}\mathbf{D}.\)</span></li>
</ol>
<p>Duas propriedades interessantes envolvendo transposta e multiplicação de matrizes são:</p>
<ol type="1">
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times m\)</span> e <span class="math inline">\(\mathbf{B}\)</span> é <span class="math inline">\(m \times n\)</span>, então</li>
</ol>
<p><span class="math display">\[
(\mathbf{A} \mathbf{B})^{\top} = \mathbf{B}^{\top} \mathbf{A}^{\top}.
\]</span></p>
<ol start="2" type="1">
<li>De maneira similar, se <span class="math inline">\(\mathbf{A}, \mathbf{B}\)</span> e <span class="math inline">\(\mathbf{C}\)</span> são compatíveis</li>
</ol>
<p><span class="math display">\[
(\mathbf{A} \mathbf{B} \mathbf{C} )^{\top} = \mathbf{C}^{\top} \mathbf{B}^{\top} \mathbf{A}^{\top}.
\]</span></p>
<p>Neste momento estamos aptos a fazer a distinção entre escalar e uma matriz <span class="math inline">\(1 \times 1\)</span>. Considere que <span class="math inline">\(\mathbf{a}\)</span> é uma matriz <span class="math inline">\(1 \times 1\)</span>. O produto de um escalar (<span class="math inline">\(\alpha\)</span>) por uma matriz está definido para qualquer matriz. Entretanto, uma matriz <span class="math inline">\(1 \times 1\)</span> só pode ser multiplicada por um vetor <span class="math inline">\(\mathbf{b}\)</span> (<span class="math inline">\(1 \times n\)</span>, vetor linha) pela direita, ou seja, <span class="math inline">\(\mathbf{a} \mathbf{b}\)</span> ou pela esquerda por um vetor <span class="math inline">\(\mathbf{b}\)</span> (<span class="math inline">\(n \times 1\)</span>, vetor coluna) pela esquerda <span class="math inline">\(\mathbf{b} \mathbf{a}\)</span>. O Código 2.8 ilustra esta situação.</p>
<p><strong>Código 2.8</strong> Ilustração da diferença entre escalar e matriz <span class="math inline">\(1 \times 1\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">10</span>, <span class="at">nrow =</span> <span class="dv">1</span>, <span class="at">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>), <span class="at">nrow =</span> <span class="dv">1</span>, <span class="at">ncol =</span> <span class="dv">4</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(a) <span class="co"># Dimensão de a</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1 1</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(b) <span class="do">## Dimensão de b</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1 4</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>a<span class="sc">%*%</span>b <span class="co"># Compatível</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]   10   20   30   40</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>b<span class="sc">%*%</span>a <span class="do">## Não compatível</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>Error in b %*% a: argumentos não compatíveis</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(b)<span class="sc">%*%</span>a <span class="do">## Compatível</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]   10
[2,]   20
[3,]   30
[4,]   40</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>alpha<span class="sc">*</span>b <span class="co"># Escalar com matriz</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]   10   20   30   40</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>b<span class="sc">*</span>alpha <span class="co"># Escalar com matriz</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]   10   20   30   40</code></pre>
</div>
</div>
<p>Um outro tipo de produto entre vetores ou matrizes é o chamado <strong>produto de Hadamard</strong>. Sendo duas matrizes ou dois vetores de mesmo tamanho o produto de Hadamard é simplesmente o resultado da multiplicação direta dos elementos correspondentes:</p>
<p><span class="math display">\[
\mathbf{A} \odot  \mathbf{B} = \begin{pmatrix}
a_{11} b_{11} &amp; a_{12} b_{12} &amp; \cdots &amp; a_{1m}b_{1m} \\
a_{21} b_{21} &amp; a_{22} b_{22} &amp; \cdots &amp; a_{2m} b_{2m} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
a_{n1} b_{n1} &amp; a_{n2} b_{n2} &amp; \cdots &amp; a_{nm} b_{nm}
\end{pmatrix}.
\]</span></p>
<p>Estamos usando a notação <span class="math inline">\(\odot\)</span> para diferenciar o produto de Hadamard do produto matricial usual. Em <code>R</code> este produto é obtido usando o operador <code>*</code> usual, conforme ilustrado no Código 2.9.</p>
<p><strong>Código 2.9</strong> Produto de Hadamard.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>A<span class="sc">*</span>B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]   10   90
[2,]   40  160</code></pre>
</div>
</div>
</section>
<section id="matrizes-de-formas-especiais" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="matrizes-de-formas-especiais"><span class="header-section-number">2.2.2</span> Matrizes de formas especiais</h3>
<p>Nesta subseção veremos algumas matrizes com formas especiais.</p>
<p>Dizemos que uma matriz é quadrada quando tem o mesmo número de linhas e colunas. Por exemplo,</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44}
\end{pmatrix}.
\]</span></p>
<p>Chamamos os elementos <span class="math inline">\(a_{ii}\)</span> de elementos <strong>diagonais</strong> ou da diagonal. Já os elementos <span class="math inline">\(a_{ij}\)</span> para <span class="math inline">\(i \neq j\)</span> são chamados de elementos <strong>fora da diagonal</strong>. Os elementos <span class="math inline">\(a_{ij}\)</span> para <span class="math inline">\(j &gt; i\)</span> são os elementos <strong>acima da diagonal</strong> e os elementos <span class="math inline">\(a_{ij}\)</span> para <span class="math inline">\(i &gt; j\)</span> são os elementos <strong>abaixo da diagonal</strong>.</p>
<p>Uma matriz é diagonal se apenas os elementos diagonais são diferentes de zero. Por exemplo,</p>
<p><span class="math display">\[
\mathbf{D} = \begin{pmatrix}
a_{11} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; a_{22} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; a_{33} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; a_{44}
\end{pmatrix}.
\]</span></p>
<p>Uma matriz é triangular superior se os elementos abaixo da diagonal são todos iguais a zero. É comum denotar uma matriz triangular superior por <span class="math inline">\(\mathbf{U}\)</span> do Inglês <em>upper </em>.</p>
<p><span class="math display">\[
\mathbf{U} = \begin{pmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
0 &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
0 &amp; 0 &amp; a_{33} &amp; a_{34} \\
0 &amp; 0 &amp; 0 &amp; a_{44}
\end{pmatrix}.
\]</span></p>
<p>Por outro lado, uma matriz é triangular inferior se os elementos acima da diagonal são todos iguais a zero. Neste caso a notação usual é <span class="math inline">\(\mathbf{L}\)</span> do Inglês <em>lower </em>.</p>
<p><span class="math display">\[
\mathbf{L} = \begin{pmatrix}
a_{11} &amp; 0 &amp; 0 &amp; 0 \\
a_{21} &amp; a_{22} &amp; 0 &amp; 0 \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; 0 \\
a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44}
\end{pmatrix}.
\]</span></p>
<p>A matriz identidade é uma matriz diagonal onde os elementos diagonais são todos iguais a <span class="math inline">\(1\)</span>. A notação usual é <span class="math inline">\(\mathbf{I}\)</span> do Inglês <em>identity </em>.</p>
<p><span class="math display">\[
\mathbf{I} = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.
\]</span></p>
<p>A matriz zero ou nula é aquela cuja todas as entradas são iguais a zero, ou seja,</p>
<p><span class="math display">\[
\mathbf{0} = \begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}.
\]</span></p>
<p>Uma matriz quadrado é dita ser simétrica se <span class="math inline">\(a_{ij} = a_{ji}\)</span>. De forma equivalente, se <span class="math inline">\(\mathbf{A}^{\top} = \mathbf{A}\)</span>, então <span class="math inline">\(\mathbf{A}\)</span> é simétrica. Por exemplo,</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
1 &amp; 0.8 &amp; 0.6 &amp; 0.4 \\
0.8 &amp; 1 &amp; 0.2 &amp; 0.4 \\
0.6 &amp; 0.2 &amp; 1 &amp; 0.1 \\
0.4 &amp; 0.4 &amp; 0.1 &amp; 1
\end{pmatrix}.
\]</span></p>
</section>
<section id="rank-e-inversa-de-uma-matriz" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="rank-e-inversa-de-uma-matriz"><span class="header-section-number">2.2.3</span> <em>Rank </em> e inversa de uma matriz</h3>
<p>Na seção 2.2.1 vimos diversas operações com matrizes. Muitas destas operações são extensões das operações de soma, subtração e multiplicação de escalares. No entanto, a divisão entre matrizes não foi definida. De forma geral duas matrizes não podem ser divididas, porém existe um tipo especial de matriz que tenta de certa forma estender a operação de divisão entre escalares para matrizes. Essa matriz especial é chamada de <strong>matriz inversa</strong>. Porém, a sua obtenção está limitada a um certo conjunto de matrizes que são chamadas <strong>não singulares</strong>. Nesta seção nós vamos entender o que é uma matriz não singular e como avaliar se uma matriz qualquer é ou não singular por meio da avaliação do seu <em>rank </em>, também chamado de <strong>posto</strong>.</p>
<p>Para definir o que é o <em>rank </em> de uma matriz precisamos da noção de <strong>dependência</strong> e <strong>independência linear</strong>. Um conjunto de vetores <span class="math inline">\(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_n\)</span> é dito ser <strong>linearmente dependente</strong> se escalares <span class="math inline">\(c_1, c_2, \ldots, c_n\)</span> não todos iguais a zero puderem ser encontrados de tal forma que</p>
<p><span class="math display">\[
\begin{equation}
c_1 \mathbf{a}_1 + c_2 \mathbf{a}_2 + \ldots + c_n \mathbf{a}_n = 0.
\tag{2.1}
\end{equation}
\]</span></p>
<p>No caso em que os coeficientes <span class="math inline">\(c_1, c_2, \ldots, c_n\)</span> não puderem ser encontrados satisfazendo (2.1) o conjunto de vetores <span class="math inline">\(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_n\)</span> é dito ser <strong>linearmente independente</strong>. Note que a Equação (2.1) pode ser reescrita em formato matricial, onde os vetores <span class="math inline">\(\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_n\)</span> formam as colunas de uma matriz <span class="math inline">\(\mathbf{A}\)</span> e os escalares são empilhados em um vetor <span class="math inline">\(\mathbf{c}\)</span>. Assim,</p>
<p><span class="math display">\[
\mathbf{A} \mathbf{c} = \mathbf{0}.
\]</span></p>
<p>Neste caso as colunas de <span class="math inline">\(\mathbf{A}\)</span> são linearmente independentes se <span class="math inline">\(\mathbf{A} \mathbf{c} = \mathbf{0}\)</span> implicar que <span class="math inline">\(\mathbf{c} = 0\)</span>. Intuitivamente um conjunto de vetores linearmente dependentes é de alguma forma redundante, no sentido de que um dos vetores pode ser escrito como uma combinação linear dos outros.</p>
<p>Considere um exemplo trivial com os vetores <span class="math inline">\(\mathbf{a}_1 = (1,0)\)</span> e <span class="math inline">\(\mathbf{a}_2 = (0,1)\)</span>. Veja que qualquer outro vetor de tamanho dois pode ser escrito como uma combinação linear dos vetores <span class="math inline">\(\mathbf{a}_1\)</span> e <span class="math inline">\(\mathbf{a}_2\)</span>. Assim, qualquer outro vetor de tamanho dois concatenado com <span class="math inline">\(\mathbf{a}_1\)</span> e <span class="math inline">\(\mathbf{a}_2\)</span> em uma matriz <span class="math inline">\(\mathbf{A}\)</span> tornará as colunas de <span class="math inline">\(\mathbf{A}\)</span> linearmente dependentes. Porém, uma matriz <span class="math inline">\(\mathbf{A}\)</span> formada apenas por <span class="math inline">\(\mathbf{a}_1\)</span> e <span class="math inline">\(\mathbf{a}_2\)</span> tem colunas linearmente independentes.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.3</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>O <em>rank </em> ou <strong>posto</strong> de qualquer matriz quadrada ou retangular <span class="math inline">\(\mathbf{A}\)</span> é definido como</p>
<p><span class="math display">\[
\mathrm{rank}(\mathbf{A}) = \text{número de colunas ou linhas linearmente independentes em } \mathbf{A}.
\]</span></p>
</div>
</div>
<p>Pode ser provado que o número de linhas e colunas linearmente independentes em uma matriz qualquer é sempre o mesmo. Se uma matriz <span class="math inline">\(\mathbf{A}\)</span> tem apenas um elemento diferente de zero, então <span class="math inline">\(\mathrm{rank}(\mathbf{A}) = 1\)</span>. O <span class="math inline">\(\mathrm{rank}\)</span> da matriz nula é <span class="math inline">\(0\)</span>.</p>
<p>Sendo <span class="math inline">\(\mathbf{A}\)</span> uma matriz retangular <span class="math inline">\(n \times m\)</span> o maior <em>rank </em> possível para <span class="math inline">\(\mathbf{A}\)</span> é o <span class="math inline">\(\min(n,m)\)</span>. Quando o <em>rank </em> da matriz é o <span class="math inline">\(\min(n,m)\)</span> dizemos que a matriz tem <em>rank </em> completo ou é de posto completo. Importante salientar que qualquer matriz retangular terá colunas linearmente dependentes. Com os conceitos apresentados até aqui podemos finalmente definir o que entendemos por uma <strong>matriz não singular</strong> e <strong>matriz inversa</strong>.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.4</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Uma matriz quadrada de <strong>posto completo</strong> é chamada de <strong>não singular</strong>.</p>
</div>
</div>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.5</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dada uma matriz quadrada <span class="math inline">\(\mathbf{A}\)</span> de posto completo a <strong>matriz inversa</strong> de <span class="math inline">\(\mathbf{A}\)</span> denotada por <span class="math inline">\(\mathbf{A}^{-1}\)</span> é única tal que</p>
<p><span class="math display">\[
\mathbf{A}\mathbf{A}^{-1} = \mathbf{I}.
\]</span></p>
</div>
</div>
<p>Se a matriz <span class="math inline">\(\mathbf{A}\)</span> não for quadrada e de posto completo, então <span class="math inline">\(\mathbf{A}\)</span> não terá inversa e é dita ser <strong>singular</strong>. Baseado na Definição 2.5 é fácil ver que <span class="math inline">\((\mathbf{A}^{-1})^{-1} = \mathbf{A}.\)</span></p>
<p>Em aplicações reais obter a inversa de uma matriz é uma tarefa complexa e requer o uso de algoritmos numéricos. Nós vamos ver algumas opções na Seção 2.3 quando discutiremos algoritmos para a solução de sistemas de equações lineares.</p>
<p>A intuição da matriz inversa é poder fazer operações similares a que realizamos com escalares quando estamos resolvendo sistemas de equações lineares. Lembre-se do sistema de equações lineares representado nas Equações (1.14) e (1.15) no modelo de regressão linear simples.</p>
<p>No decorrer deste livro seremos frequentemente confrontados com sistemas lineares do tipo <span class="math inline">\(\mathbf{A} \mathbf{x} = \mathbf{c}\)</span> em que precisamos encontrar o vetor de incógnitas <span class="math inline">\(\mathbf{x}\)</span>. No caso em que <span class="math inline">\(\mathbf{A}\)</span> é não singular, o sistema de equações <span class="math inline">\(\mathbf{A} \mathbf{x} = \mathbf{c}\)</span> terá uma única solução dada por <span class="math inline">\(\mathbf{x} = \mathbf{A}^{-1} \mathbf{c}\)</span>. Veja como a inversa imita o que costumamos fazer com escalares quando resolvendo uma simples equação linear. É o equivalente ao que falamos grosseiramente de “passa pro outro lado.” O que realmente está sendo feito é que multiplicamos o sistema em ambos os lados por <span class="math inline">\(\mathbf{A}^{-1}\)</span> para obter a solução, ou seja,</p>
<p><span class="math display">\[
\begin{eqnarray}
\mathbf{A}^{-1} \mathbf{A} \mathbf{x} &amp;=&amp; \mathbf{A}^{-1} \mathbf{c} \\
\mathbf{I}\mathbf{x} &amp;=&amp; \mathbf{A}^{-1} \mathbf{c}.
\end{eqnarray}
\]</span></p>
<p>Em <code>R</code> podemos facilmente obter a inversa de uma matriz usando a função <code>solve()</code>. No entanto, como ficará claro quando discutirmos métodos para a solução de sistemas lineares, tal solução é cara computacionalmente e raramente necessária explicitamente. O Código 2.10 ilustra a obtenção da inversa.</p>
<p><strong>Código 2.10</strong> Inversa de uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">6</span>), <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>A_inv <span class="ot">&lt;-</span> <span class="fu">solve</span>(A)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Conferindo: deve resultar na matriz identidade</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>A_inv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    1    0
[2,]    0    1</code></pre>
</div>
</div>
<p>Duas propriedades importantes envolvendo multiplicação e inversão de matrizes são:</p>
<ol type="1">
<li><p>Se <span class="math inline">\(\mathbf{A}\)</span> é não singular, então <span class="math inline">\(\mathbf{A}^{\top}\)</span> é não singular e sua inversa é dada por <span class="math display">\[
(\mathbf{A}^{\top})^{-1} = (\mathbf{A}^{-1})^{\top}.
\]</span></p></li>
<li><p>Se <span class="math inline">\(\mathbf{A}\)</span> e <span class="math inline">\(\mathbf{B}\)</span> são matrizes não singulares de mesmo tamanho, então o produto <span class="math inline">\(\mathbf{A} \mathbf{B}\)</span> é não singular e <span class="math display">\[
(\mathbf{A} \mathbf{B})^{-1} =  \mathbf{B}^{-1} \mathbf{A}^{-1}.
\]</span></p></li>
</ol>
<p>No caso em que uma matriz é retangular não podemos obter a inversa. Nestes casos podemos recorrer a matriz <strong>inversa generalizada</strong>.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.6</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>inversa generalizada</strong> de uma matriz <span class="math inline">\(\mathbf{A}\)</span> <span class="math inline">\(n \times p\)</span> é qualquer matriz <span class="math inline">\(\mathbf{A}^{-}\)</span> que satisfaça</p>
<p><span class="math display">\[
\mathbf{A}\mathbf{A}^{-}\mathbf{A} = \mathbf{A}.
\]</span></p>
</div>
</div>
<p>A inversa generalizada não é única exceto quando <span class="math inline">\(\mathbf{A}\)</span> é não-singular, e neste caso coincide com a inversa. Toda matriz, seja quadrada ou retangular tem uma inversa generalizada, isto inclui vetores. Como um exemplo ilustrativo, considere o vetor</p>
<p><span class="math display">\[
\mathbf{a} = \begin{pmatrix}
1\\
2\\
3\\
4
\end{pmatrix}.
\]</span></p>
<p>Neste caso o vetor <span class="math inline">\(\mathbf{a}^{-} = (1, 0, 0, 0)\)</span> é a inversa generalizada de <span class="math inline">\(\mathbf{a}\)</span>. Para verificar basta fazer a multiplicação matricial.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>), <span class="dv">4</span>, <span class="dv">1</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>a_invg <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="dv">1</span>, <span class="dv">4</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>a<span class="sc">%*%</span>a_invg<span class="sc">%*%</span>a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]    1
[2,]    2
[3,]    3
[4,]    4</code></pre>
</div>
</div>
<p>Importante notar que se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times p\)</span>, então qualquer inversa generalizada de <span class="math inline">\(\mathbf{A}\)</span> terá dimensão <span class="math inline">\(p \times n\)</span>.</p>
<p>Como dito, a inversa generalizada não é única. Em particular a inversa generalizada chamada de Moore-Penrose (<em>Moore-Penrose Genereralized Inverse </em>) está implementada em <code>R</code> por meio do pacote <code>MASS</code>. O Código 2.11 ilustra a obtenção da inversa generalizada de Moore-Penrose para uma matriz quadrada, porém singular.</p>
<p><strong>Código 2.11</strong> Inversa generalizada de Moore-Penrose.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Matriz singular (a terceira coluna é a soma da primeira com a segunda)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>), <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Carregando o pacote MASS</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>A_ginv <span class="ot">&lt;-</span> <span class="fu">ginv</span>(A)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="do">## Conferindo</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>A_ginv<span class="sc">%*%</span>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]         [,2] [,3]
[1,]    2 2.000000e+00    3
[2,]    1 2.220446e-16    1
[3,]    3 2.000000e+00    4</code></pre>
</div>
</div>
</section>
<section id="matrizes-positivas-definidas" class="level3" data-number="2.2.4">
<h3 data-number="2.2.4" class="anchored" data-anchor-id="matrizes-positivas-definidas"><span class="header-section-number">2.2.4</span> Matrizes positivas definidas</h3>
<p>No decorrer deste livro vamos encontrar frequentemente as chamadas somas de quadrados. Nós já discutimos sobre soma de quadrados nas seções 1.2.5 e 1.2.9 quando encontramos a média e os coeficientes de regressão do modelo de regressão linear simples. De forma matricial, a soma de quadrados pode ser reescritas usando <strong>formas quadráticas</strong>.</p>
<p>Considere uma matriz <span class="math inline">\(\mathbf{A}\)</span> simétrica e <span class="math inline">\(\mathbf{y}\)</span> um vetor, o produto</p>
<p><span class="math display">\[
\mathbf{y}^{\top} \mathbf{A} \mathbf{y} = \sum_{i} a_{ij} y_i^2 + \sum_{i \neq j} a_{ij} y_i y_j,
\]</span></p>
<p>é chamado de <strong>forma quadrática</strong>.</p>
<p>Para uma matriz <span class="math inline">\(\mathbf{y}\)</span> de dimensão <span class="math inline">\(n \times 1\)</span>, ou seja, um vetor coluna o produto matricial <span class="math inline">\(\mathbf{y}^{\top}\mathbf{I} \mathbf{y} = y_1^2 + y_2^2 + \ldots, y_n^2\)</span>. Assim, <span class="math inline">\(\mathbf{y}^{\top} \mathbf{y}\)</span> é a soma de quadrados dos elementos do vetor <span class="math inline">\(\mathbf{y}\)</span>. A raiz quadrado da soma de quadrados é a distância do ponto <span class="math inline">\(\mathbf{y}\)</span> até a origem, também chamada de comprimento de <span class="math inline">\(\mathbf{y}\)</span>. As somas de quadrados permanecem positivas, ou ao menos não negativas para todos os valores de <span class="math inline">\(\mathbf{y}\)</span> exceto no caso em que <span class="math inline">\(\mathbf{y} = 0\)</span>.</p>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.7</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Sendo <span class="math inline">\(\mathbf{A}\)</span> uma matriz simétrica com a propriedade <span class="math inline">\(\mathbf{y}^{\top} \mathbf{A} \mathbf{y} &gt; 0\)</span> para todos os possíveis <span class="math inline">\(\mathbf{y}\)</span> exceto para quando <span class="math inline">\(\mathbf{y} = 0\)</span>, então a forma quadrática <span class="math inline">\(\mathbf{y}^{\top} \mathbf{A} \mathbf{y}\)</span> é chamada <strong>positiva definida</strong>, e <span class="math inline">\(\mathbf{A}\)</span> é dita ser uma <strong>matriz positiva definida</strong>. No caso de <span class="math inline">\(\mathbf{y}^{\top} \mathbf{A} \mathbf{y} \geq 0\)</span> e existir ao menos um <span class="math inline">\(\mathbf{y} \neq 0\)</span> tal que <span class="math inline">\(\mathbf{y}^{\top} \mathbf{A} \mathbf{y} = 0\)</span>, então <span class="math inline">\(\mathbf{y}^{\top} \mathbf{A} \mathbf{y}\)</span> é dita ser <strong>positiva semi-definida</strong> e <span class="math inline">\(\mathbf{A}\)</span> é uma matriz <strong>positiva semi-definida</strong>.</p>
</div>
</div>
<p>Para ilustração considere a seguinte matriz</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
2 &amp; -1\\
-1 &amp; 3
\end{pmatrix}.
\]</span></p>
<p>A forma quadrática associada é dada por</p>
<p><span class="math display">\[
\mathbf{y}^{\top} \mathbf{A} \mathbf{y} = \begin{pmatrix}
y_1 &amp; y_2
\end{pmatrix}
\begin{pmatrix}
2 &amp; -1\\
-1 &amp; 3
\end{pmatrix}
\begin{pmatrix}
y_1 \\
y_2
\end{pmatrix} = 2 y_1^2 - 2 y_1 y_2 + 3 y_2^2,
\]</span></p>
<p>que é claramente positiva, desde que <span class="math inline">\(y_1\)</span> e <span class="math inline">\(y_2\)</span> sejam diferentes de zero. Algumas propriedades interessantes sobre matrizes positivas definidas ou semi-definidas são:</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{A}\)</span> é positiva definida, então todos os valores da diagonal de <span class="math inline">\(\mathbf{A}\)</span> são positivos.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é positiva semi-definida, então os elementos da diagonal de <span class="math inline">\(\mathbf{A}\)</span> são maiores ou iguais a zero.</li>
<li>Sendo <span class="math inline">\(\mathbf{P}\)</span> uma matriz não-singular e <span class="math inline">\(\mathbf{A}\)</span> uma matriz positiva definida, o produto <span class="math inline">\(\mathbf{P}^{\top} \mathbf{A} \mathbf{P}\)</span> é uma matriz positiva definida.</li>
<li>Sendo <span class="math inline">\(\mathbf{P}\)</span> uma matriz não-singular e <span class="math inline">\(\mathbf{A}\)</span> uma matriz positiva semi-definida, o produto <span class="math inline">\(\mathbf{P}^{\top} \mathbf{A} \mathbf{P}\)</span> é uma matriz positiva semi-definida.</li>
<li>Uma matriz positiva definida é não-singular.</li>
</ol>
<p>Matrizes positivas definidas são fundamentais em estatística pois representam a matriz de variância e covariância de vetores aleatórios.</p>
</section>
<section id="determinante-e-traço-de-uma-matriz" class="level3" data-number="2.2.5">
<h3 data-number="2.2.5" class="anchored" data-anchor-id="determinante-e-traço-de-uma-matriz"><span class="header-section-number">2.2.5</span> Determinante e traço de uma matriz</h3>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.8</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>O <strong>determinante</strong> de uma matriz <span class="math inline">\(\mathbf{A}\)</span> é o escalar</p>
<p><span class="math display">\[
|\mathbf{A}| = \sum_j (-1)^k a_{1 j_1} a_{2 j_2}, \ldots, a_{n j_n},
\]</span></p>
<p>onde a soma é realizada para todas as <span class="math inline">\(n!\)</span> permutações de grau <span class="math inline">\(n\)</span>, e <span class="math inline">\(k\)</span> é o número de mudanças necessárias para que os segundos subscritos sejam colocados na ordem <span class="math inline">\(1,2, \ldots, n.\)</span></p>
</div>
</div>
<p>Em termos de notação vamos usar <span class="math inline">\(|\mathbf{A}|\)</span> ou <span class="math inline">\(\det{(A)}\)</span>. A Definição 2.8 é difícil de entender e pouco útil para avaliar determinantes de matrizes de grande dimensão. Entretanto, nestes casos temos sempre que recorrer a métodos computacionais. Para matrizes pequenas é fácil obter o determinante. Vamos fazer um exemplo simples com uma matriz <span class="math inline">\(2 \times 2\)</span> apenas como ilustração.</p>
<p>Considere a matriz</p>
<p><span class="math display">\[
\mathbf{A} = \begin{pmatrix}
3 &amp; -2\\
-2 &amp; 4
\end{pmatrix}.
\]</span></p>
<p>Usando a definição precisamos encontrar todas as <span class="math inline">\(n!\)</span> combinações de produtos contendo um elemento de cada linha e coluna. Neste caso <span class="math inline">\(n = 2\)</span> e <span class="math inline">\(n! = 2 \cdot 1 = 2\)</span>. Teremos apenas duas combinações. Na primeira combinação vamos pegar o elemento <span class="math inline">\(a_{11} = 3\)</span> e multiplicar pelo elemento <span class="math inline">\(a_{22} = 4\)</span>. Neste caso os índices de coluna já estão na ordem crescente, então o número de trocas foi <span class="math inline">\(0\)</span>. O segundo termo será o elemento <span class="math inline">\(a_{12} = -2\)</span> multiplicado pelo elemento <span class="math inline">\(a_{21} = -2\)</span>. Neste caso, para que os índices de coluna fiquem em ordem crescente, precisamos fazer uma mudança, então <span class="math inline">\(k = 1\)</span>.</p>
<p><span class="math display">\[
|\mathbf{A}| = (-1)^0 a_{11} a_{22} + (-1)^1 a_{12} a_{21} = 1 \cdot (3 \cdot 4) - (-2 \cdot -2) =  12 - 4 = 8.
\]</span></p>
<p>Em <code>R</code> o determinante de uma matriz pode ser obtido por meio da função <code>determinant()</code>, conforme ilustrado no Código 2.12.</p>
<p><strong>Código 2.12</strong> Determinante de uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">4</span>),<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="fu">determinant</span>(A, <span class="at">logarithm =</span> <span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$modulus
[1] 8
attr(,"logarithm")
[1] FALSE

$sign
[1] 1

attr(,"class")
[1] "det"</code></pre>
</div>
</div>
<p>É muito comum precisarmos do logaritmo do determinante, assim a função <code>determinant()</code> traz essa opção como <em>default </em>. Por isso, para obter o determinante de <span class="math inline">\(\mathbf{A}\)</span> precisamos incluir o argumento <code>logarithm = FALSE</code>. Caso contrário o determinante seria obtido em escala logarítmica.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">determinant</span>(A, <span class="at">logarithm =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$modulus
[1] 2.079442
attr(,"logarithm")
[1] TRUE

$sign
[1] 1

attr(,"class")
[1] "det"</code></pre>
</div>
</div>
<p>Alguns aspectos interessantes sobre determinantes são:</p>
<ol type="1">
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é singular, <span class="math inline">\(|\mathbf{A}| = 0\)</span>.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é não singular, <span class="math inline">\(|\mathbf{A}| \neq 0\)</span>.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é positiva definida, <span class="math inline">\(|\mathbf{A}| &gt; 0\)</span>.</li>
<li><span class="math inline">\(|\mathbf{A}^{\top}| = |\mathbf{A}|\)</span>.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é não singular, <span class="math inline">\(|\mathbf{A}^{-1}| = \frac{1}{|\mathbf{A}|}\)</span>.</li>
</ol>
<div class="callout callout-style-simple callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Definição 2.9</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>O <strong>traço</strong> de uma matriz <span class="math inline">\(\mathbf{A}\)</span> <span class="math inline">\(n \times n\)</span> é um escalar definido como a soma dos elementos da diagonal, <span class="math inline">\(\mathrm{tr}(\mathbf{A}) = \sum_{i=1}^n a_{ii}\)</span>.</p>
</div>
</div>
<p>Algumas propriedades do traço:</p>
<ol type="1">
<li>Se <span class="math inline">\(\mathbf{A}\)</span> e <span class="math inline">\(\mathbf{B}\)</span> são <span class="math inline">\(n \times n\)</span>, então</li>
</ol>
<p><span class="math display">\[
\mathrm{tr}(\mathbf{A} + \mathbf{B}) = \mathrm{tr}(\mathbf{A}) + \mathrm{tr}(\mathbf{B}).
\]</span></p>
<ol start="2" type="1">
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times p\)</span> e <span class="math inline">\(\mathbf{B}\)</span> e <span class="math inline">\(p \times n\)</span>, então</li>
</ol>
<p><span class="math display">\[
\mathrm{tr}(\mathbf{AB}) = \mathrm{tr}(\mathbf{BA}).
\]</span></p>
<p>Em <code>R</code> não temos uma função explícita para a obtenção do traço devido a sua simplicidade. Assim, podemos obter o traço simplesmente acessando os elementos da diagonal da matriz com a função <code>diag()</code> e somar com a função <code>sum()</code>, conforme ilustrado no Código 2.13.</p>
<p><strong>Código 2.13</strong> Traço de uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">4</span>),<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">diag</span>(A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7</code></pre>
</div>
</div>
</section>
<section id="cálculo-vetorial-e-matricial" class="level3" data-number="2.2.6">
<h3 data-number="2.2.6" class="anchored" data-anchor-id="cálculo-vetorial-e-matricial"><span class="header-section-number">2.2.6</span> Cálculo vetorial e matricial</h3>
<p>No Capítulo <span class="math inline">\(1\)</span> vimos como obter a derivada de funções com até duas variáveis independentes. Usando as ferramentas de Cálculo vetorial e matricial podemos obter derivadas de funções com um número arbitrário de variáveis independentes. Seja <span class="math inline">\(y = f(\mathbf{x})\)</span> uma função das variáveis <span class="math inline">\(x_1, x_2, \ldots, x_p\)</span> e <span class="math inline">\(\frac{\partial y}{\partial x_1}, \frac{\partial y}{\partial x_2}, \ldots, \frac{\partial y}{\partial x_p}\)</span> as respectivas derivadas parciais. Assim,</p>
<p><span class="math display">\[
\frac{\partial y}{\partial \mathbf{x}} = \begin{pmatrix}
\frac{\partial y}{\partial x_1}\\
\frac{\partial y}{\partial x_2}\\
\vdots\\
\frac{\partial y}{\partial x_p}
\end{pmatrix}.
\]</span></p>
<p>Basicamente, a ideia é derivar em cada uma das variáveis independentes e arranjar as derivadas parciais em um vetor de tamanho adequado. Usando esta ideia simples é possível calcular a derivada de funções mais complicadas. Vejamos algumas derivadas vetoriais e matriciais úteis em ciência de dados.</p>
<p>Sendo <span class="math inline">\(\mathbf{a}^{\top} = (a_1, a_2, \ldots, a_p)\)</span> um vetor de constantes e <span class="math inline">\(\mathbf{A}\)</span> uma matriz simétrica de constantes.</p>
<ol type="1">
<li>Seja <span class="math inline">\(y = \mathbf{a}^{\top} \mathbf{x} = \mathbf{x}^{\top} \mathbf{a}\)</span>. Então,</li>
</ol>
<p><span class="math display">\[
\frac{\partial y}{\partial \mathbf{x}} = \frac{\partial (\mathbf{x}^{\top} \mathbf{a})}{\partial \mathbf{x}} = \mathbf{a}.
\]</span></p>
<ol start="2" type="1">
<li>Seja <span class="math inline">\(y = \mathbf{x}^{\top} \mathbf{A} \mathbf{x}\)</span>. Então,</li>
</ol>
<p><span class="math display">\[
\frac{\partial y}{\partial \mathbf{x}} = \frac{\partial (\mathbf{x}^{\top} \mathbf{A} \mathbf{x}) }{\partial \mathbf{x}} = 2 \mathbf{A} \mathbf{x}.
\]</span></p>
<p>De forma similar, se <span class="math inline">\(y = f(\mathbf{X})\)</span> onde <span class="math inline">\(\mathbf{X}\)</span> é uma matriz <span class="math inline">\(p \times p\)</span>. As derivadas parciais de <span class="math inline">\(y\)</span> em relação a cada <span class="math inline">\(x_{ij}\)</span> são organizadas em uma matriz.</p>
<p><span class="math display">\[
\frac{\partial y}{\partial \mathbf{X}} = \begin{pmatrix}
\frac{\partial y}{\partial x_{11}} &amp; \ldots &amp; \frac{\partial y}{\partial x_{1p}}\\
\vdots &amp; \ddots  &amp; \vdots\\
\frac{\partial y}{\partial x_{p1}} &amp; \ldots &amp; \frac{\partial y}{\partial x_{pp}}
\end{pmatrix}.
\]</span></p>
<p>Algumas derivadas importantes envolvendo matrizes são apresentadas abaixo.</p>
<ol type="1">
<li>Seja <span class="math inline">\(y = \mathrm{tr}(\mathbf{X}\mathbf{A})\)</span> sendo <span class="math inline">\(\mathbf{X}\)</span> <span class="math inline">\(p \times p\)</span> e definida positiva e <span class="math inline">\(\mathbf{A}\)</span> <span class="math inline">\(p \times p\)</span> constantes. Então,</li>
</ol>
<p><span class="math display">\[
\frac{\partial y}{\partial \mathbf{X}} = \frac{\partial \mathrm{tr}(\mathbf{X}\mathbf{A})}{\partial \mathbf{X}} =  \mathbf{A} + \mathbf{A}^{\top} - \mathrm{diag}(\mathbf{A}).
\]</span></p>
<ol start="2" type="1">
<li>Sendo <span class="math inline">\(\mathbf{A}\)</span> não singular com derivadas <span class="math inline">\(\frac{\partial \mathbf{A}}{\partial x}\)</span>. Então,</li>
</ol>
<p><span class="math display">\[
\frac{\partial \mathbf{A}^{-1}}{\partial x} = - \mathbf{A}^{-1} \frac{\partial \mathbf{A}}{\partial x} \mathbf{A}^{-1}.
\]</span></p>
<ol start="3" type="1">
<li>Sendo <span class="math inline">\(\mathbf{A}\)</span> <span class="math inline">\(n \times n\)</span> positiva definida. Então,</li>
</ol>
<p><span class="math display">\[
\frac{\partial \log |\mathbf{A}|}{\partial x} = \mathrm{tr} \left( \mathbf{A}^{-1} \frac{\partial \mathbf{A}}{\partial x} \right).
\]</span></p>
</section>
<section id="regressão-linear-múltipla" class="level3" data-number="2.2.7">
<h3 data-number="2.2.7" class="anchored" data-anchor-id="regressão-linear-múltipla"><span class="header-section-number">2.2.7</span> Regressão linear múltipla</h3>
<p>Na seção 1.2.9 construímos o modelo de regressão linear simples, onde apenas uma covariável <span class="math inline">\(x\)</span> descreve o comportamento da variável dependente <span class="math inline">\(y\)</span>, por meio de uma reta, ou seja,</p>
<p><span class="math display">\[
y_i = \beta_0 + \beta_1 x_i + \epsilon_i.
\]</span></p>
<p>No modelo de regressão linear múltipla estendemos este modelo para levar em consideração um número arbitrário <span class="math inline">\(p\)</span> de covariáveis <span class="math inline">\(x_{ip}\)</span>. Nesta notação <span class="math inline">\(x_{ip}\)</span> é o valor da <span class="math inline">\(p-\)</span>ésima covariável associada a observação <span class="math inline">\(i\)</span> para <span class="math inline">\(i = 1, \ldots, n\)</span>, sendo <span class="math inline">\(n\)</span> o número de observações. Note que a primeira covariável é assumida como <span class="math inline">\(1\)</span> para representar o intercepto.</p>
<p>O modelo de regressão linear múltipla é então escrito como</p>
<p><span class="math display">\[
y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \ldots + \beta_p x_{ip} + \epsilon_i.
\]</span></p>
<p>Podemos escrever o modelo para cada uma das <span class="math inline">\(n\)</span> observações, como segue</p>
<p><span class="math display">\[
\begin{matrix}
y_1 = \beta_0 + \beta_1 x_{11} + \beta_2 x_{12} + \ldots \beta_{p} x_{1p} + \epsilon_1 \\
y_2 = \beta_0 + \beta_1 x_{21} + \beta_2 x_{22} + \ldots \beta_{p} x_{2p} + \epsilon_2\\
\vdots \\
y_n = \beta_0 + \beta_1 x_{n1} + \beta_2 x_{n2} + \ldots \beta_{p} x_{np} + \epsilon_p.\\
\end{matrix}
\]</span></p>
<p>Agora organizamos os termos em formato matricial</p>
<p><span class="math display">\[
\underset{n\times 1}{\begin{bmatrix}
y_1\\
y_2\\
\vdots \\
y_n
\end{bmatrix}} =
\underset{n\times p}{\begin{bmatrix}
1 &amp; x_{11} &amp; \ldots &amp; x_{p1} \\
1 &amp; x_{12} &amp; \ldots &amp; x_{p1} \\
\vdots &amp; \vdots  &amp; \ddots &amp; \vdots \\
1&amp; x_{1n} &amp; \ldots &amp; x_{pn}
\end{bmatrix} }
\underset{p \times 1}{
\begin{bmatrix}
\beta_0 \\
\vdots \\
\beta_p
\end{bmatrix}
} + \underset{n\times 1}{\begin{bmatrix}
\epsilon_1\\
\epsilon_2\\
\vdots \\
\epsilon_n
\end{bmatrix}}
\]</span></p>
<p>Por fim, usamos uma notação mais compacta para representar o modelo</p>
<p><span class="math display">\[
\underset{n \times 1}{\mathbf{y}} = \underset{n \times p }{\mathbf{X}} \underset{p\times 1}{\boldsymbol{\beta}} + \underset{n \times 1}{\mathbf{\epsilon}}.
\]</span></p>
<p>Note como todas as multiplicações envolvidas no modelo são compatíveis respeitando as regras dos produtos de matrizes.</p>
<p>Nosso objetivo é encontrar o vetor <span class="math inline">\(\boldsymbol{\hat{\beta}}\)</span>, tal que</p>
<p><span class="math display">\[
SQ(\boldsymbol{\beta}) = (\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^{\top} (\mathbf{y} - \mathbf{X}\boldsymbol{\beta}),
\]</span></p>
<p>seja a menor possível.</p>
<p>Esse processo é o que chamamos de estimação dos parâmetros de regressão ou de treinamento do modelo, a segunda nomenclatura é comum na literatura de aprendizado de máquina. Note que novamente temos um processo de minimização, porém agora de uma função com muitas variáveis independentes. Usando as ferramentas de Álgebra Linear podemos facilmente proceder com esse problema de minimização.</p>
<p>O primeiro passo é derivar a soma de quadrados em <span class="math inline">\(\boldsymbol{\beta}\)</span>, usando Cálculo vetorial (ver Seção 2.2.6).</p>
<p>Derivando em <span class="math inline">\(\boldsymbol{\beta}\)</span>, temos</p>
<p><span class="math display">\[
\begin{eqnarray*}
\frac{\partial SQ(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}} &amp;=&amp; \frac{\partial}{\partial \boldsymbol{\beta}} (\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^{\top} (\mathbf{y} - \mathbf{X}\boldsymbol{\beta}) \\
&amp;=&amp; \frac{\partial}{\partial \boldsymbol{\beta}} \left ( (\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^{\top}  \right ) (\mathbf{y} - \mathbf{X}\boldsymbol{\beta}) + (\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^{\top} \frac{\partial}{\partial \boldsymbol{\beta}}  (\mathbf{y} - \mathbf{X}\boldsymbol{\beta}) \\
&amp;=&amp; -\mathbf{X}^{\top}(\mathbf{y} - \mathbf{X}\boldsymbol{\beta}) + (\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^{\top} (-\mathbf{X}) \\
&amp;=&amp; -2\mathbf{X}^{\top}(\mathbf{y} - \mathbf{X}\boldsymbol{\beta}).
\end{eqnarray*}
\]</span></p>
<p>O segundo passo é resolver o sistema de equações lineares resultantes</p>
<p><span class="math display">\[
\begin{eqnarray}
\mathbf{X}^{\top}(\mathbf{y} - \mathbf{X}\boldsymbol{\hat{\beta}}) &amp;=&amp; \boldsymbol{0} \\
\mathbf{X}^{\top}\mathbf{y} - \mathbf{X}^{\top}\mathbf{X}\boldsymbol{\hat{\beta}} &amp;=&amp; 0 \\
\mathbf{X}^{\top}\mathbf{X}\boldsymbol{\hat{\beta}} &amp;=&amp; \mathbf{X}^{\top}\mathbf{y} \tag{2.2} \\
\boldsymbol{\hat{\beta}} &amp;=&amp; (\mathbf{X}^{\top}\mathbf{X})^{-1}\mathbf{X}^{\top}\mathbf{y}. \tag{2.3}
\end{eqnarray}
\]</span></p>
<p>Note que a Equação (2.2) foi multiplicada em ambos os lados por <span class="math inline">\((\mathbf{X}^{\top}\mathbf{X})^{-1}\)</span> para encontrar (2.3). Essa operação corresponde a resolver o sistema de equações lineares. Nós vimos na Seção 2.2.3 como obter a inversa de uma matriz usando o <code>R</code>. Assim, estamos aptos a implementar tais operações em <code>R</code>.</p>
<p>Para exemplificar a implementação do modelo de regressão linear múltipla, vamos usar um conjunto de dados muito famoso sobre o preço de imóveis na cidade de Boston. O conjunto de dados está disponível no pacote <code>MASS</code> e contém além da variável resposta <span class="math inline">\(13\)</span> covariáveis e <span class="math inline">\(506\)</span> observações. As primeiras seis observações do conjunto de dados são apresentadas abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(MASS)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(Boston)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(Boston)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     crim zn indus chas   nox    rm  age    dis rad tax ptratio  black lstat
1 0.00632 18  2.31    0 0.538 6.575 65.2 4.0900   1 296    15.3 396.90  4.98
2 0.02731  0  7.07    0 0.469 6.421 78.9 4.9671   2 242    17.8 396.90  9.14
3 0.02729  0  7.07    0 0.469 7.185 61.1 4.9671   2 242    17.8 392.83  4.03
4 0.03237  0  2.18    0 0.458 6.998 45.8 6.0622   3 222    18.7 394.63  2.94
5 0.06905  0  2.18    0 0.458 7.147 54.2 6.0622   3 222    18.7 396.90  5.33
6 0.02985  0  2.18    0 0.458 6.430 58.7 6.0622   3 222    18.7 394.12  5.21
  medv
1 24.0
2 21.6
3 34.7
4 33.4
5 36.2
6 28.7</code></pre>
</div>
</div>
<p>As covariáveis disponíveis são</p>
<ul>
<li>crim: taxa de crimes per capita.</li>
<li>zn: proporção de terrenos residenciais zoneados para lotes com mais de 25.000 pés quadrados.</li>
<li>indus: proporção de acres de negócios não varejistas por cidade.</li>
<li>chas: variável dummy de Charles River (1 se a área limita o rio; 0 caso contrário).</li>
<li>nox: concentração de óxido de nitrogênio (parte por 10 milhões).</li>
<li>rm: número médio de quartos por habitação.</li>
<li>age: proporção de unidades ocupadas pelo proprietário construídas antes de 1940.</li>
<li>dis: média ponderada das distâncias a cinco centros de empregos de Boston.</li>
<li>rad: índice de acessibilidade às rodovias radiais.</li>
<li>tax: taxa de imposto sobre a propriedade de valor total por $10.000.</li>
<li>ptratio: proporção aluno-professor por cidade.</li>
<li>black: <span class="math inline">\(1000 (Bk - 0,63)^2\)</span> onde <span class="math inline">\(Bk\)</span> é a proporção de negros por cidade.</li>
<li>lstat: Porcentagem da população em pobreza.</li>
</ul>
<p>A variável resposta é o valor mediano das casas ocupadas pelos proprietários em <span class="math inline">\(\$1000\)</span>, codificada como <code>medv</code>. O primeiro passo para implementar o modelo de regressão linear múltipla para este problema é montar a matriz <span class="math inline">\(\mathbf{X}\)</span>, também chamada de matriz de delineamento. Ela vai conter os valores de todas as covariáveis de interesse. Em <code>R</code> podemos usar a função <code>model.matrix()</code> para construir tal matriz. Para este exemplo, vamos usar apenas as primeiras cinco covariáveis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span> crim <span class="sc">+</span> zn <span class="sc">+</span> indus <span class="sc">+</span> chas <span class="sc">+</span> nox, <span class="at">data =</span> Boston)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)    crim zn indus chas   nox
1           1 0.00632 18  2.31    0 0.538
2           1 0.02731  0  7.07    0 0.469
3           1 0.02729  0  7.07    0 0.469
4           1 0.03237  0  2.18    0 0.458
5           1 0.06905  0  2.18    0 0.458
6           1 0.02985  0  2.18    0 0.458</code></pre>
</div>
</div>
<p>Note que a função <code>model.matrix()</code> automaticamente inclui uma coluna de <span class="math inline">\(1\)</span>’s para representar o intercepto. O vetor <span class="math inline">\(y\)</span> neste caso é a coluna <code>medv</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> Boston<span class="sc">$</span>medv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por fim, implementamos a Equação (2.3) de duas formas distintas. Convido o leitor a tentar entender qual a diferença computacional entre elas. Tal diferença ficará clara quando discutirmos algoritmos para a solução de sistemas de equações lineares e obtenção da matriz inversa.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Forma ingênua</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X)<span class="sc">%*%</span><span class="fu">t</span>(X)<span class="sc">%*%</span>y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                   [,1]
(Intercept) 29.48994059
crim        -0.21851904
zn           0.05511047
indus       -0.38348055
chas         7.02622266
nox         -5.42465902</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Forma eficiente</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X, <span class="fu">t</span>(X)<span class="sc">%*%</span>y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                   [,1]
(Intercept) 29.48994059
crim        -0.21851904
zn           0.05511047
indus       -0.38348055
chas         7.02622266
nox         -5.42465902</code></pre>
</div>
</div>
<p>Podemos usar a função <code>lm()</code> para conferir a nossa implementação.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(<span class="fu">lm</span>(medv <span class="sc">~</span> crim <span class="sc">+</span> zn <span class="sc">+</span> indus <span class="sc">+</span> chas <span class="sc">+</span> nox, <span class="at">data =</span> Boston))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(Intercept)        crim          zn       indus        chas         nox 
29.48994059 -0.21851904  0.05511047 -0.38348055  7.02622266 -5.42465902 </code></pre>
</div>
</div>
<p>Os resultados são idênticos. Podemos usar o modelo para predizer o valor de um imóvel dado os valores de suas covariáveis. Basicamente, tudo o que foi discutido no caso do modelo de regressão linear simples se adapta naturalmente para o modelo de regressão linear múltipla.</p>
</section>
</section>
<section id="sistemas-de-equações-lineares" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sistemas-de-equações-lineares"><span class="header-section-number">2.3</span> Sistemas de equações lineares</h2>
<p>Um sistema de equações de duas incógnitas pode ser escrito da seguinte forma</p>
<p><span class="math display">\[
\begin{eqnarray*}
f_1(x_1,x_2)  &amp; = &amp;  c_1 \\
f_2(x_1,x_2)  &amp; = &amp;  c_2.
\end{eqnarray*}
\]</span></p>
<p>De forma geral, desejamos encontrar a solução numérica do sistema que consiste em encontrar valores <span class="math inline">\(\hat{x}_1\)</span> e <span class="math inline">\(\hat{x}_2\)</span> que satisfaçam o sistema de equações, ou seja, que ao aplicar as funções <span class="math inline">\(f_1\)</span> e <span class="math inline">\(f_2\)</span> simultâneamente em <span class="math inline">\(\hat{x}_1\)</span> e <span class="math inline">\(\hat{x}_2\)</span>, resultem em <span class="math inline">\(c_1\)</span> e <span class="math inline">\(c_2\)</span>. Em termos de notação, desejamos que <span class="math inline">\(f_1(x_1 = \hat{x}_1, x_2 = \hat{x}_2) = c_1\)</span> e <span class="math inline">\(f_2(x_1 = \hat{x}_1, x_2 = \hat{x}_2) = c_2\)</span>, simultâneamente.</p>
<p>A ideia é facilmente estendida para um sistema com <span class="math inline">\(n\)</span> equações com <span class="math inline">\(p\)</span> incógnitas</p>
<p><span class="math display">\[
\begin{eqnarray*}
f_1(x_1,\ldots, x_p)  &amp; = &amp;  c_1 \\
&amp; \vdots &amp;  \\
f_n(x_1,\ldots, x_p)  &amp; = &amp;  c_p.
\end{eqnarray*}
\]</span></p>
<p>Um sistema de equações é dito ser linear se as funções <span class="math inline">\(f_1, f_2, \ldots, f_n\)</span> são lineares e não-linear caso contrário. Nesta seção, nós vamos lidar apenas com sistemas lineares. Na Seção 3.1, nós vamos apresentar alguns métodos numéricos para sistemas de equações não-lineares. Quando as <span class="math inline">\(n\)</span> funções são lineares o sistema pode escrito da seguinte forma</p>
<p><span class="math display">\[
\begin{eqnarray*}
a_{11} x_1 + a_{12} x_2 + \ldots a_{1p} x_p  &amp; = &amp;  c_1 \\
a_{21} x_1 + a_{22} x_2 + \ldots a_{2p} x_p  &amp; = &amp;  c_2 \\
&amp; \vdots &amp;  \\
a_{n1} x_1 + a_{n2} x_2 + \ldots a_{np} x_p  &amp; = &amp;  c_p. \\
\end{eqnarray*}
\]</span></p>
<p>É mais fácil e compacto usar a notação matricial, neste caso o sistema toma a seguinte forma</p>
<p><span class="math display">\[
\mathbf{A} \mathbf{x} = \mathbf{c},
\]</span></p>
<p>onde <span class="math inline">\(\mathbf{A}\)</span> é uma matriz <span class="math inline">\(n \times p\)</span>, <span class="math inline">\(\mathbf{x}\)</span> é um vetor <span class="math inline">\(p \times 1\)</span>, e <span class="math inline">\(\mathbf{c}\)</span> é um vetor <span class="math inline">\(n \times 1\)</span>. Quando <span class="math inline">\(n = p\)</span> e <span class="math inline">\(\mathbf{A}\)</span> é não-singular é possível mostrar que o sistema tem uma solução <strong>única</strong> dada por <span class="math inline">\(\mathbf{\hat{x}} = \mathbf{A}^{-1} \mathbf{c}\)</span>. No caso em que <span class="math inline">\(n &gt; p\)</span>, <span class="math inline">\(\mathbf{A}\)</span> terá mais linhas do que colunas e o sistema tipicamente não terá solução. Por fim, se <span class="math inline">\(n &lt; p\)</span>, <span class="math inline">\(\mathbf{A}\)</span> terá menos linhas do que colunas e o sistema tipicamente terá um número infinito de soluções. Neste livro vamos considerar apenas o caso em que o sistema tem uma única solução, ou seja, <span class="math inline">\(n = p\)</span> e <span class="math inline">\(\mathbf{A}\)</span> é não-singular (admite inversa).</p>
<p>Como um exemplo ilustrativo, considere o seguinte sistema de duas equações</p>
<p><span class="math display">\[
\begin{eqnarray}
7 x_1 + 3x_2  &amp; = &amp;  45 \tag{2.4}\\
4 x_1 + 5x_2  &amp; = &amp;  29. \tag{2.5}
\end{eqnarray}
\]</span></p>
<p>A solução deste sistema consiste em encontrar valores <span class="math inline">\(\hat{x}_1\)</span> e <span class="math inline">\(\hat{x}_2\)</span>, que satisfaçam as Equações (2.4) e (2.5). Para começar vamos isolar o <span class="math inline">\(x_1\)</span> na Equação (2.4).</p>
<p><span class="math display">\[
\begin{eqnarray}
7x_1 + 3 x_2  &amp; = &amp;  45 \\
7x_1  &amp; = &amp;  45 - 3x_2 \\
x_1  &amp; = &amp;  \frac{45 - 3x_2}{7}. \tag{2.6}
\end{eqnarray}
\]</span></p>
<p>Agora substituímos a Equação (2.6) na Equação (2.5)</p>
<p><span class="math display">\[
\begin{eqnarray}
4x_1 + 5x_2  &amp; = &amp;  29 \\
4 \left( \frac{45 - 3x_2}{7} \right ) + 5x_2  &amp; = &amp;  29 \\
\frac{180 - 12 x_2}{7} + 5x_2  &amp; = &amp;  29 \\
\frac{180}{7} - \frac{12}{7} x_2 + 5 x_2  &amp; = &amp;  29 \\
5 x_2 - \frac{12}{7} x_2  &amp; = &amp;  29 - \frac{180}{7} \\
\frac{35x_2 - 12 x_2}{7}  &amp; = &amp;  29 - \frac{180}{7} \\
35x_2 - 12 x_2  &amp; = &amp;  7 \left(29 - \frac{180}{7} \right ) \\
23 x_2  &amp; = &amp;  203 - 180 \\
23 x_2  &amp; = &amp;  23 \\
\hat{x}_2  &amp; = &amp;  \frac{23}{23} = 1. \tag{2.7}
\end{eqnarray}
\]</span></p>
<p>Por fim, substituindo (2.7) em (2.6) obtemos <span class="math inline">\(\hat{x}_1\)</span></p>
<p><span class="math display">\[
\begin{eqnarray}
\hat{x}_1  &amp; = &amp;  \frac{45 - 3 \cdot 1}{7} \\
\hat{x}_1  &amp; = &amp;  6.
\end{eqnarray}
\]</span></p>
<p>Portanto, a solução é <span class="math inline">\(\hat{x}_1 = 6\)</span> e <span class="math inline">\(\hat{x}_2 = 1\)</span>.</p>
<p>Importante ressaltar que apesar de matematicamente simples o procedimento utilizado é bastante trabalhoso e impraticável em sistemas maiores, tais como os que vamos encontrar na prática em ciência de dados. Assim, fica claro que precisamos de algoritmos genéricos que possam ser adaptáveis para sistemas de qualquer tamanho.</p>
<p>Para resolver o sistema nós realizamos uma série de manipulações com as linhas do sistema até encontrar a solução. Estas operações são chamadas de <strong>operações com linhas</strong>. Sem qualquer alteração na relação linear é possível</p>
<ol type="1">
<li><p>Trocar a posição de linhas, por exemplo <span class="math display">\[
\begin{eqnarray*}
4 x_1 + 5 x_2  &amp; = &amp;  29 \\
7 x_1 + 3 x_2  &amp; = &amp;  45.
\end{eqnarray*}
\]</span></p></li>
<li><p>Multiplicar qualquer linha por uma constante, aqui <span class="math inline">\(4 x_1 + 5 x_2\)</span> por <span class="math inline">\(\frac{1}{4}\)</span>, obtendo <span class="math display">\[
\begin{eqnarray}
x_1 + \frac{5}{4} x_2  &amp; = &amp;  \frac{29}{4} \tag{2.8}\\
7 x_1 + 3 x_2  &amp; = &amp;  45. \tag{2.9}
\end{eqnarray}
\]</span></p></li>
<li><p>Subtrair um múltiplo de uma linha de uma outra, aqui 7 vezes a Equação (2.8) menos (2.9), obtendo <span class="math display">\[
\begin{eqnarray*}
x_1 + \frac{5}{4} x_2  &amp; = &amp;  \frac{29}{4} \\
0 x_1 + \left(\frac{35}{4} - 3\right) x_2  &amp; = &amp;  \frac{203}{4} - 45.
\end{eqnarray*}
\]</span></p></li>
</ol>
<p>Fazendo as contas, tem-se</p>
<p><span class="math display">\[
\begin{eqnarray*}
0 x_1 + \frac{23}{4} x_2  &amp; = &amp;  \frac{23}{4} \\
x_2  &amp; = &amp;  1.
\end{eqnarray*}
\]</span></p>
<p>Baseado em <strong>operações com linhas</strong> podemos estabelecer diferentes estratégias para transformar um sistema linear qualquer em um sistema equivalente, porém de fácil solução. Esta é a ideia subjacente a uma classe de métodos chamados de <strong>métodos diretos</strong> para a solução de sistemas lineares. Por outro lado, existem os chamados <strong>métodos iterativos</strong> cuja ideia principal é a partir de uma solução inicial ir melhorando esta solução até que um certo critério de parada seja satisfeito. Na subseção 2.3.1 nós vamos apresentar alguns dos métodos diretos mais famosos, enquanto que na subseção 2.3.2 serão apresentados alguns métodos iterativos.</p>
<section id="métodos-diretos" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="métodos-diretos"><span class="header-section-number">2.3.1</span> Métodos diretos</h3>
<p>Nos métodos diretos o sistema linear é manipulado usando <strong>operações com linhas</strong> até se transformar em um sistema equivalente de fácil solução. Por exemplo, o sistema pode ser manipulado até se tornar um sistema <strong>triangular superior</strong></p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  a_{12}  &amp;  a_{13}  &amp;  a_{14}\\
0  &amp;  a_{22}  &amp;  a_{23}  &amp;  a_{24}\\
0  &amp;  0  &amp;  a_{33}  &amp;  a_{34} \\
0  &amp;  0  &amp;  0  &amp;  a_{44}
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
x_4
\end{bmatrix} =
  \begin{bmatrix}
b_1 \\
b_2 \\
b_3 \\
b_4
\end{bmatrix}.
\]</span></p>
<p>Que é facilmente resolvido utilizando <strong>substituição regressiva</strong></p>
<p><span class="math display">\[
x_n = \frac{b_n}{a_{nn}} \quad x_i = \frac{b_i - \sum_{j = i+1 }^{j=n} a_{ij} x_j}{a_{ii}},
\quad i = n-1, n-2,\ldots, 1.
\]</span></p>
<p>Outra opção é manipular o sistema até obter um sistema triangular inferior, ou seja,</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  0  &amp;  0  &amp;  0 \\
a_{21}  &amp;  a_{22}  &amp;  0  &amp;  0 \\
a_{31}  &amp;  a_{32}  &amp;  a_{33}  &amp;  0 \\
a_{41}  &amp;  a_{42}  &amp;  a_{43}  &amp;  a_{44}
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
x_4
\end{bmatrix} =
  \begin{bmatrix}
b_1 \\
b_2 \\
b_3 \\
b_4
\end{bmatrix}.
\]</span></p>
<p>Neste caso usamos a <strong>substituição progressiva</strong> para obter a solução</p>
<p><span class="math display">\[
x_1 = \frac{b_1}{a_{11}} \quad x_i = \frac{b_i - \sum_{j = i}^{j=i-1} a_{ij} x_j}{a_{ii}}, \quad i = 2, 3,\ldots, n.
\]</span></p>
<p>Por fim, o mais óbvio porém mais caro computacionalmente é tornar o sistema diagonal</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  0  &amp;  0  &amp;  0 \\
0  &amp;  a_{22}  &amp;  0  &amp;  0 \\
0  &amp;  0  &amp;  a_{33}  &amp;  0 \\
0  &amp;  0  &amp;  0  &amp;  a_{44}
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
x_4
\end{bmatrix} =
  \begin{bmatrix}
b_1 \\
b_2 \\
b_3 \\
b_4
\end{bmatrix}.
\]</span></p>
<p>Um dos métodos diretos mais utilizados é o método de <strong>Eliminação de Gauss</strong>. Este método consiste em usar operações com linhas para obter um sistema triangular superior e depois usar substituição regressiva para obter a solução. Vamos fazer um exemplo para ilustrar como este método funciona.</p>
<p><strong>Example 2.1</strong> Resolva o seguinte sistema usando o método de eliminação de Gauss.</p>
<p><span class="math display">\[
\begin{bmatrix}
3  &amp;  2  &amp;  6 \\
2  &amp;  4  &amp;  3 \\
5  &amp;  3  &amp;  4  \\
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix} =
  \begin{bmatrix}
24 \\
23 \\
33
\end{bmatrix}
\]</span></p>
<p>O algoritmo pode ser descrito passo-a-passo</p>
<ul>
<li>Passo 1: Encontrar o primeiro <strong>pivô</strong> e eliminar os elementos abaixo dele usando operações com linhas.</li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
[3]  &amp;  2  &amp;  6 \\
2 - \frac{2}{3}3  &amp;  4 - \frac{2}{3}2  &amp;  3 - \frac{2}{3}6 \\
5 - \frac{5}{3}3  &amp;  3 - \frac{5}{3}2  &amp;  4 - \frac{5}{3}6 \\
\end{bmatrix}
\begin{bmatrix}
24 \\
23 - \frac{2}{3}24\\
33 - \frac{5}{3}24
\end{bmatrix} \to
\begin{bmatrix}
[3]  &amp;  2  &amp;  6 \\
0  &amp;  \frac{8}{3}  &amp;  -1 \\
0  &amp;  -\frac{1}{3}  &amp;  -6  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-7
\end{bmatrix}.
\]</span></p>
<p>Neste caso o primeiro <strong>pivô</strong> é o número <span class="math inline">\(3\)</span> (note entre colchetes) e precisamos tornar os elementos abaixo dele zero. Para isto multiplicamos a primeira linha por <span class="math inline">\(\frac{2}{3}\)</span>, ou seja, o valor da posição a ser zerada dividida pelo valor do pivô. E depois subtraímos da segunda linha. Importante é que a operação <strong>deve ser feita em todos os elementos da linha</strong> para não modificar o sistema. A mesma ideia é usada para zerar o primeiro elemento da terceira linha.</p>
<ul>
<li>Passo 2: Encontrar o segundo <strong>pivô</strong> e eliminar os elementos abaixo dele usando operações com linhas.</li>
</ul>
<p><span class="math display">\[
  \begin{bmatrix}
3  &amp;  2  &amp;  6 \\
0  &amp;  [\frac{8}{3}]  &amp;  -1 \\
0  &amp;  -\frac{1}{3} - \left (-\frac{3}{24} \right ) \left (\frac{8}{3}\right )   &amp;  -6 - (-\frac{3}{24})(-1)  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-7 - (- \frac{3}{24})(7)
\end{bmatrix} \to \\
\begin{bmatrix}
3  &amp;  2  &amp;  6 \\
0  &amp;  [\frac{8}{3}]  &amp;  -1 \\
0  &amp;  0  &amp;  -\frac{147}{24}  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-\frac{147}{24}
\end{bmatrix}
\]</span></p>
<p>Neste caso o segundo pivô é <span class="math inline">\(\frac{8}{3}\)</span> e multiplicamos a segunda linha pelo pivô e subtraímos da terceira para zerar o elemento da segunda linha da terceira coluna. Com isso chegamos a um sistema triangular superior.</p>
<ul>
<li>Passo 3: Substituição regressiva.</li>
</ul>
<p><span class="math display">\[
\begin{eqnarray*}
\hat{x}_3  &amp; = &amp;  \frac{b_3}{a_{33}} \\
\hat{x}_3  &amp; = &amp;  \frac{-147/24}{-147/24} = 1. \\
\hat{x}_2  &amp; = &amp;  \frac{b_2 - a_{23}x_3}{a_{22}} \\
\hat{x}_2  &amp; = &amp;  \frac{7 - (-1) \cdot 1}{8/3} = 3. \\
\hat{x}_1  &amp; = &amp;  \frac{(b_1 - (a_{12}x_2 + a_{13}x_3) }{a_{11}} \\
\hat{x}_1  &amp; = &amp;  \frac{24 - (2 \cdot 3 + 6 \cdot 1)}{3} = 4.
\end{eqnarray*}
\]</span></p>
<p>Portanto, a solução do sistema é <span class="math inline">\(\hat{x}_1 = 4\)</span>, <span class="math inline">\(\hat{x}_2 = 3\)</span> e <span class="math inline">\(\hat{x}_3 = 1\)</span>.</p>
<p>Estender o procedimento para um sistema com <span class="math inline">\(n\)</span> equações é trivial. Basta transformar o sistema em triangular superior usando operações com linhas e resolver o novo sistema usando substituição regressiva.</p>
<p>Para ilustrar o procedimento de eliminação de Gauss o Código 2.14 implementa a estratégia para tornar um sistema triangular superior.</p>
<p><strong>Código 2.14</strong> Triangularização de um sistema.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>gauss <span class="ot">&lt;-</span> <span class="cf">function</span>(A, b) {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sistema aumentado</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  Ae <span class="ot">&lt;-</span> <span class="fu">cbind</span>(A, b)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(Ae) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"x"</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(b))</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  n_row <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Ae)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  n_col <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Ae)</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Matriz para receber os resultados</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  SOL <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, n_row, n_col)</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>  SOL[<span class="dv">1</span>,] <span class="ot">&lt;-</span> Ae[<span class="dv">1</span>,]</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>  pivo <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, n_col, n_row)</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(n_row<span class="dv">-1</span>)) {</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">c</span>(j<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">c</span>(n_row)) {</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>      pivo[i,j] <span class="ot">&lt;-</span> Ae[i,j]<span class="sc">/</span>SOL[j,j]</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>      SOL[i,] <span class="ot">&lt;-</span> Ae[i,] <span class="sc">-</span> pivo[i,j]<span class="sc">*</span>SOL[j,]</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>      Ae[i,] <span class="ot">&lt;-</span> SOL[i,]</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(SOL)</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Precisamos também de uma função genérica para o passo de substituição regressiva, conforme apresentado no Código 2.15.</p>
<p><strong>Código 2.15</strong> Substituição regressiva.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>sub_reg <span class="ot">&lt;-</span> <span class="cf">function</span>(SOL) {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  n_row <span class="ot">&lt;-</span> <span class="fu">nrow</span>(SOL)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  n_col <span class="ot">&lt;-</span> <span class="fu">ncol</span>(SOL)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  A <span class="ot">&lt;-</span> SOL[<span class="dv">1</span><span class="sc">:</span>n_row,<span class="dv">1</span><span class="sc">:</span>n_row]</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> SOL[,n_col]</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(b)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>  x[n] <span class="ot">&lt;-</span> b[n]<span class="sc">/</span>A[n,n]</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> (n<span class="dv">-1</span>)<span class="sc">:</span><span class="dv">1</span>) {</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    x[i] <span class="ot">&lt;-</span> (b[i] <span class="sc">-</span> <span class="fu">sum</span>(A[i,<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>n]<span class="sc">*</span>x[<span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>n] ))<span class="sc">/</span>A[i,i]</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por fim, vamos resolver o sistema apresentado no Exemplo 2.1 utilizando as funções criadas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Entrando com o sistema na forma matricial</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">4</span>),<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">24</span>,<span class="dv">23</span>,<span class="dv">33</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Passo 1: Triangularização</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">gauss</span>(A, b)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>S</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]          [,2]   [,3]   [,4]
[1,]    3  2.000000e+00  6.000 24.000
[2,]    0  2.666667e+00 -1.000  7.000
[3,]    0 -5.551115e-17 -6.125 -6.125</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Passo 2: Substituição regressiva</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">=</span> <span class="fu">sub_reg</span>(<span class="at">SOL =</span> S)</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>sol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4 3 1</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verificando a solução</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>sol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]   24
[2,]   23
[3,]   33</code></pre>
</div>
</div>
<p>O método de eliminação de Gauss pode apresentar dois problemas:</p>
<ol type="i">
<li>o elemento pivô é zero e neste caso não podemos dividir por zero e</li>
<li>o elemento pivô é pequeno em magnitude em relação aos demais. Isso pode levar a problemas numéricos por fazer uma divisão por um número muito próximo de zero.</li>
</ol>
<p>Para resolver estes problemas é usual combinar o método de eliminação de Gauss com o procedimento de <strong>pivotação</strong>. O procedimento de <strong>pivotação</strong> nada mais é do que trocar a ordem das linhas para evitar pivôs iguais a zero ou muito pequenos. Além disso, a pivotação também pode ajudar a diminuir o número de operações para resolver o sistema.</p>
<p>Se durante o procedimento uma equação pivô tiver um elemento nulo e o sistema tiver solução, uma equação com um elemento pivô diferente de zero sempre existirá. Uma recomendação é ordenar as linhas para que o maior valor seja o primeiro pivô.</p>
<p><strong>Example 2.2</strong> Resolva o seguinte sistema usando eliminação de Gauss com pivotação.</p>
<p><span class="math display">\[
\begin{eqnarray*}
0x_1 + 2x_2 + 3x_2  &amp; = &amp;  46\\
4 x_1 -3x_2 + 2x_3  &amp; = &amp;  16 \\
2x_1 + 4x_2 -3x_3  &amp; = &amp;  12
\end{eqnarray*}
\]</span></p>
<p>Note que neste caso o primeiro pivô é zero o procedimento não pode ser iniciado da maneira usual. A estratégia de pivotação é simplesmente trocar a ordem das linhas de forma que valores maiores apareçam primeiro como pivôs. Por exemplo,</p>
<p><span class="math display">\[
\begin{eqnarray*}
4 x_1 -3x_2 + 2x_3  &amp; = &amp;  16 \\
2x_1 + 4x_2 -3x_3  &amp; = &amp;  12 \\
0x_1 + 2x_2 + 3x_2  &amp; = &amp;  46.
\end{eqnarray*}
\]</span></p>
<p>Importante notar que ao trocar a ordem das linhas a ordem da solução também será alterada. Vejamos como resolver este sistema usando as funções que criamos nesta seção.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Entrando com o sistema original</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="sc">-</span><span class="dv">3</span>), <span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">46</span>,<span class="dv">16</span>,<span class="dv">12</span>)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Pivoteamento</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>A_order <span class="ot">&lt;-</span> A[<span class="fu">order</span>(A[,<span class="dv">1</span>], <span class="at">decreasing =</span> <span class="cn">TRUE</span>),]</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>b_order <span class="ot">&lt;-</span> b[<span class="fu">order</span>(A[,<span class="dv">1</span>], <span class="at">decreasing =</span> <span class="cn">TRUE</span>)]</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Triangulação</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">gauss</span>(A_order, b_order)</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>S</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]      [,3]     [,4]
[1,]    4 -3.0  2.000000 16.00000
[2,]    0  5.5 -4.000000  4.00000
[3,]    0  0.0  4.454545 44.54545</code></pre>
</div>
</div>
<pre><code>## Substituição regressiva
sol &lt;- sub_reg(SOL = S)
sol</code></pre>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Solução</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>A_order<span class="sc">%*%</span>sol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]
[1,]    9
[2,]   17
[3,]    9</code></pre>
</div>
</div>
<p>Um segundo método direto muito popular é o método de Gauss-Jordan. Este método é similar ao método de eliminação de Gauss, porém busca transformar o sistema original em um sistema diagonal usando operações com linhas. O algoritmo pode ser resumido em dois passos:</p>
<ol type="1">
<li>Normalize a equação pivô com a divisão de todos os seus termos pelo coeficiente pivô.</li>
<li>Elimine os elementos fora da diagonal principal em TODAS as demais equações usando operações com linhas.</li>
</ol>
</section>
<section id="métodos-iterativos" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="métodos-iterativos"><span class="header-section-number">2.3.2</span> Métodos iterativos</h3>
<p>Os métodos iterativos trabalham de forma ligeiramente diferente. Neste caso, as equações são colocadas em uma forma explícita onde cada incógnita é escrita em termos das demais, ou seja,</p>
<p><span class="math display">\[
  \begin{matrix}
a_{11} x_1 + a_{12} x_2 + a_{13} x_3 = b_1 \\
a_{21} x_1 + a_{22} x_2 + a_{23} x_3 = b_2 \\
a_{31} x_1 + a_{32} x_2 + a_{33} x_3 = b_3
\end{matrix} \to
\begin{matrix}
x_1 = [b_1 - (a_{12} x_2 + a_{13}x_3)]/a_{11} \\
x_2 = [b_2 - (a_{21} x_1 + a_{23}x_3)]/a_{22} \\
x_3 = [b_3 - (a_{31} x_1 + a_{32}x_2)]/a_{33}
\end{matrix}.
\]</span></p>
<p>Dado um valor inicial para as incógnitas estas são atualizadas até a convergência. Em um sistema com <span class="math inline">\(n\)</span> equações, as equações explícitas para as incógnitas <span class="math inline">\(x_i\)</span> são</p>
<p><span class="math display">\[
x_i = \frac{1}{a_{ii}} \left [ b_i - \left ( \sum_{j=1;j \neq i}^{j=n} a_{ij} x_j \right ) \right ] \quad i = 1, \ldots, n.
\]</span></p>
<p>Dentro da classe dos métodos iterativos os métodos de Jacobi e Gauss-Seidel são muito populares. A diferença básica entre os dois é que no método de Jacobi os valores das incógnitas são atualizados todos de uma vez no final de cada iteração. Por outro lado, no método de Gauss-Seidel, o valor de cada incógnita é atualizado e usado no cálculo da nova estimativa das demais incógnitas dentro da mesma iteração.</p>
<p>Dado um valor inicial para cada uma das incógnitas, <span class="math inline">\(x_1^{(1)}, x_2^{(1)}, \ldots, x_n^{(1)}\)</span> o <strong>método de Jacobi</strong> atualiza a solução usando a seguinte equação de atualização:</p>
<p><span class="math display">\[
\begin{equation}
x_i^{k+1} = \frac{1}{a_{ii}} \left[b_i - \left(\sum_{j=1, j \neq i}^{j=n} a_{ij} x_j^{(k)}  \right)   \right] \quad i = 1, 2, \ldots, n.
\end{equation}
\]</span></p>
<p>No <strong>método de Gauss-Seidel</strong> as equações de atualização são as seguintes:</p>
<p><span class="math display">\[
\begin{equation}
x_1^{k+1} = \frac{1}{a_{11}} \left[b_1 - \sum_{j=2}^{j=n} a_{1j} x_j^{(k)}  \right],
\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}
x_i^{(k+1)} = \frac{1}{a_{ii}} \left[ b_i - \left( \sum_{j=1}^{j = i-1} a_{ij} x_j^{(k+1)} + \sum_{j = i+1}^{j = n} a_{ij} x_j^{(k)} \right)  \right] \quad i = 2, 3, \ldots, n-1 \quad \text{e}
\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}
x_n^{(k+1)} = \frac{1}{a_{nn}} \left[b_n - \sum_{j = 1}^{j=n-1} a_{nj} x_j^{(k+1)}  \right].
\end{equation}
\]</span></p>
<p>Em ambos os métodos as iterações continuam até que algum critério de parada seja atingido. Por exemplo, as iterações podem ser interrompidas quando o valor absoluto do erro relativo estimado de todas as incógnitas for menor que algum valor especificado:</p>
<p><span class="math display">\[
\begin{equation}
\left| \frac{x_i^{k+1} - x_i^{(k)} }{x_i^{(k)}}   \right| &lt; \epsilon.
\end{equation}
\]</span></p>
<p>A escolha de valores iniciais é sempre um problema a ser considerado caso a caso. Uma estratégia simples é inicializar com zeros, porém obviamente esses valores nem sempre serão razoáveis e a convergência do método pode ficar muito lenta devido a valores iniciais ruins.</p>
<p>Para exemplificar o uso e implementação computacional dos métodos iterativos o Código 2.16 implementa o método de Jacobi.</p>
<p><strong>Código 2.16</strong> Método de Jacobi.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>jacobi <span class="ot">&lt;-</span> <span class="cf">function</span>(A, b, inicial, <span class="at">max_iter =</span> <span class="dv">10</span>, <span class="at">tol =</span> <span class="fl">1e-04</span>) {</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(b)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  x_temp <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> n, <span class="at">nrow =</span> max_iter)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  x_temp[<span class="dv">1</span>,] <span class="ot">&lt;-</span> inicial</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> x_temp[<span class="dv">1</span>,]</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Equação de atualização</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>max_iter) {</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>      x_temp[j,i] <span class="ot">&lt;-</span> (b[i] <span class="sc">-</span> <span class="fu">sum</span>(A[i,<span class="dv">1</span><span class="sc">:</span>n][<span class="sc">-</span>i]<span class="sc">*</span>x[<span class="sc">-</span>i]))<span class="sc">/</span>A[i,i]</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> x_temp[j,]</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="do">## Critério de parada</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(x_temp[j,] <span class="sc">-</span> x_temp[<span class="fu">c</span>(j<span class="dv">-1</span>),])) <span class="sc">&lt;</span> tol) <span class="cf">break</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="st">"Solucao"</span> <span class="ot">=</span> x, <span class="st">"Iteracoes"</span> <span class="ot">=</span> x_temp))</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Example 2.3</strong> Resolva o seguinte sistema de equações lineares usando o método de Jacobi.</p>
<p><span class="math display">\[
\begin{eqnarray*}
9x_1 - 2x_2 + 3x_3 + 2x_4  &amp; = &amp;  54.5\\
2x_1 + 8x_2 - 2x_3 + 3x_4  &amp; = &amp;  -14 \\
-3x_1 + 2x_2 + 11x_3 - 4x_4   &amp; = &amp;  12.5 \\
-2x_1 + 3x_2 + 2x_3 - 10x_4   &amp; = &amp;  -21 \\
\end{eqnarray*}
\]</span></p>
<p>Vamos começar entrando com a matriz do sistema.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Matriz do sistema</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">9</span>,<span class="dv">2</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">11</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="sc">-</span><span class="dv">4</span>,<span class="dv">10</span>), <span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Vetor de solução</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">54.5</span>, <span class="sc">-</span><span class="dv">14</span>, <span class="fl">12.5</span>, <span class="sc">-</span><span class="dv">21</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Agora usamos a função implementada no Código 2.16.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">&lt;-</span> <span class="fu">jacobi</span>(<span class="at">A =</span> A, <span class="at">b =</span> b, <span class="at">inicial =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>sol<span class="sc">$</span>Solucao</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  4.988102 -1.997265  2.503982 -1.001923</code></pre>
</div>
</div>
<p>Note que a solução fornecida é uma aproximação para a solução exata. A solução exata pode ser obtida, por exemplo usando o método de eliminação de Gauss.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">gauss</span>(<span class="at">A =</span> A, <span class="at">b =</span> b)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>sol_ex <span class="ot">&lt;-</span> <span class="fu">sub_reg</span>(<span class="at">SOL =</span> S)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>sol_ex</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  5.0 -2.0  2.5 -1.0</code></pre>
</div>
</div>
<p>Uma questão importante sobre a implementação dos métodos iterativos é o uso do duplo <code>for()</code>. Isso torna a implementação computacional destes métodos diretamente em <code>R</code> conforme feito no Código 2.16 lento. Uma implementação eficiente dos métodos de Jacobi e Gauss-Seidel está disponível em <code>R</code> através do pacote <code>Rlinsolve</code>. Este pacote implementa os métodos utilizando a linguagem <code>C++</code> o que torna a implementação bastante rápida computacionalmente. O uso do pacote <code>Rlinsolve</code> é ilustrado no Código Rlinsolve2.17.</p>
<p><strong>Código 2.17</strong> Utilização do pacote <code>Rlinsolve</code> para resolver sistemas lineares via métodos iterativos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Carregando o pacote</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(Rlinsolve)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: Rlinsolve</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** ------------------------------------------------------- **</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** Rlinsolve</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>**  - Solving (Sparse) System of Linear Equations</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>**</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** Version    : 0.3.2      (2024)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** Maintainer : Kisung You (kisungyou@outlook.com)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>**</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** Please share any bugs or suggestions to the maintainer.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>** ------------------------------------------------------- **</code></pre>
</div>
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Método de Jacobi </span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lsolve.jacobi</span>(A, b)<span class="sc">$</span>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.jacobi : Initialiszed.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.jacobi : A may not be symmetric.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.jacobi : making it normal equation form via 'adjsym' flag.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.jacobi : computations finished.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]
[1,]  4.999971
[2,] -2.000064
[3,]  2.500017
[4,] -0.999947</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Método de Gauss-Seidel</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lsolve.gs</span>(A, b)<span class="sc">$</span>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.gs : Initialiszed.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.gs : A may not be symmetric.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.gs : making it normal equation form via 'adjsym' flag.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>* lsolve.gs : computations finished.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>           [,1]
[1,]  4.9999633
[2,] -2.0000580
[3,]  2.5000148
[4,] -0.9999738</code></pre>
</div>
</div>
</section>
<section id="decomposição-lu" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="decomposição-lu"><span class="header-section-number">2.3.3</span> Decomposição LU</h3>
<p>Para motivar o uso de decomposições matriciais considere que precisamos resolver vários sistemas lineares do tipo</p>
<p><span class="math display">\[
\mathbf{A} \boldsymbol{x} = \boldsymbol{b}
\]</span></p>
<p>para diferentes <span class="math inline">\(\boldsymbol{b}\)</span>’s.</p>
<p>A ideia é manipular apenas a matriz <span class="math inline">\(\mathbf{A}\)</span> de modo que as operações feitas em <span class="math inline">\(\mathbf{A}\)</span> possam ser aproveitadas para resolver os diversos sistemas lineares.</p>
<p>A decomposição LU é uma das decomposições mais populares e comumente implementada em diversos softwares. Em <code>R</code> a função <code>solve()</code> que nós já usamos resolve um sistema linear usando a decomposição LU. O procedimento consiste em decompor ou fatorar a matriz <span class="math inline">\(\mathbf{A}\)</span> em um produto de duas matrizes</p>
<p><span class="math display">\[
\mathbf{A} = \mathbf{L} \mathbf{U},
\]</span></p>
<p>onde <span class="math inline">\(\mathbf{L}\)</span> é triangular inferior e <span class="math inline">\(\mathbf{U}\)</span> é triangular superior.</p>
<p>Baseado na decomposição o sistema terá a forma:</p>
<p><span class="math display">\[
\begin{equation}
\mathbf{L} \mathbf{U} \boldsymbol{x} = \boldsymbol{b}.
  \tag{2.10}
\end{equation}
\]</span></p>
<p>Defina <span class="math inline">\(\mathbf{U} \boldsymbol{x} = \boldsymbol{y}.\)</span> Substituindo em (2.10) tem-se</p>
<p><span class="math display">\[
\begin{equation}
\mathbf{L} \boldsymbol{y} = \boldsymbol{b}.
  \tag{2.11}
\end{equation}
\]</span></p>
<p>Assim, a solução é obtida em dois passos</p>
<ul>
<li>Resolva Equação (2.11) para obter <span class="math inline">\(\boldsymbol{y}\)</span> usando substituição progressiva.</li>
<li>Resolva Equação (2.10) para obter <span class="math inline">\(\boldsymbol{x}\)</span> usando substituição regressiva.</li>
</ul>
<p>Um método para obter a decomposição <span class="math inline">\(\mathbf{LU}\)</span> é o próprio método de eliminação de Gauss. Dentro do processo de eliminação de Gauss as matrizes <span class="math inline">\(\mathbf{L}\)</span> e <span class="math inline">\(\mathbf{U}\)</span> são obtidas como um subproduto. Considere uma matriz <span class="math inline">\(4 \times 4\)</span>, a decomposição <span class="math inline">\(\mathbf{LU}\)</span> toma a seguinte forma</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  a_{12}  &amp;  a_{13}  &amp;  a_{14} \\
a_{21}  &amp;  a_{22}  &amp;  a_{23}  &amp;  a_{24} \\
a_{31}  &amp;  a_{32}  &amp;  a_{33}  &amp;  a_{34} \\
a_{41}  &amp;  a_{41}  &amp;  a_{43}  &amp;  a_{44}
\end{bmatrix} = \begin{bmatrix}
1  &amp;    &amp;    &amp;  \\
m_{21}  &amp;  1  &amp;    &amp;  \\
m_{31}  &amp;  m_{32}  &amp;  1  &amp;  \\
m_{41}  &amp;  m_{42}  &amp;  m_{43}  &amp;  1
\end{bmatrix}
\begin{bmatrix}
a_{11}  &amp;  a_{12}  &amp;  a_{13}  &amp;  a_{14} \\
0  &amp;  a′_{22}  &amp;  a′_{23}  &amp;  a′_{24} \\
0  &amp;  0  &amp;  a′_{33}  &amp;  a′_{34} \\
0  &amp;  0  &amp;  0  &amp;  a′_{44}
\end{bmatrix}.
\]</span></p>
<p>Os elementos <span class="math inline">\(m_{ij}′s\)</span> são os multiplicadores que multiplicam a equação pivô. Os elementos <span class="math inline">\(a′_{ij}\)</span> são os elementos usuais da triangular superior obtida pelo método de eliminação de Gauss.</p>
<p>Relembre o Exemplo 2.1</p>
<p><span class="math display">\[
\begin{bmatrix}
[3]  &amp;  2  &amp;  6 \\
2 - \boldsymbol{\frac{2}{3}}3  &amp;  4 - \frac{2}{3}2  &amp;  3 - \frac{2}{3}6 \\
5 - \boldsymbol{\frac{5}{3}}3  &amp;  3 - \frac{5}{3}2  &amp;  4 - \frac{5}{3}6 \\
\end{bmatrix}
\begin{bmatrix}
24 \\
23 - \frac{2}{3}24\\
33 - \frac{5}{3}24
\end{bmatrix} \to
\begin{bmatrix}
[3]  &amp;  2  &amp;  6 \\
0  &amp;  \frac{8}{3}  &amp;  -1 \\
0  &amp;  -\frac{1}{3}  &amp;  -6  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-7
\end{bmatrix}
\]</span> <span class="math display">\[
\begin{bmatrix}
3  &amp;  2  &amp;  6 \\
0  &amp;  [\frac{8}{3}]  &amp;  -1 \\
0  &amp;  -\frac{1}{3} - \left (-\frac{3}{24} \right ) \left (\frac{8}{3}\right )   &amp;  -6 - (\boldsymbol{-\frac{3}{24}})(-1)  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-7 - (- \frac{3}{24})(7)
\end{bmatrix} \to
\begin{bmatrix}
3  &amp;  2  &amp;  6 \\
0  &amp;  [\frac{8}{3}]  &amp;  -1 \\
0  &amp;  0  &amp;  [-\frac{147}{24}]  \\
\end{bmatrix}
\begin{bmatrix}
24 \\
7 \\
-\frac{147}{24}
\end{bmatrix}
\]</span></p>
<p>Assim, tem-se</p>
<p><span class="math display">\[
\mathbf{L} = \begin{bmatrix}
1  &amp;    &amp;  \\
\frac{2}{3}  &amp;  1  &amp;  \\
\frac{5}{3}  &amp;  -\frac{3}{24}  &amp;  1
\end{bmatrix} \quad \text{e} \quad
\mathbf{U} =
\begin{bmatrix}
3  &amp;  2  &amp;  6 \\
0  &amp;  \frac{8}{3}  &amp;  -1 \\
0  &amp;  0  &amp;  -\frac{147}{24}  \\
\end{bmatrix}.
\]</span></p>
<p>Neste caso, o método de eliminação de Gauss foi realizado sem pivotação. Porém, conforme já discutido a pivotação pode ser necessária. Quando realizada a pivotação, as mudanças feitas devem ser armazenadas, tal que</p>
<p><span class="math display">\[
\mathbf{P} \mathbf{A} = \mathbf{L}\mathbf{U},
\]</span></p>
<p>onde <span class="math inline">\(\mathbf{P}\)</span> é chamada de matriz de permutação. Se as matrizes <span class="math inline">\(\mathbf{L}\mathbf{U}\)</span> forem usadas para resolver o sistema</p>
<p><span class="math display">\[
\mathbf{A} \boldsymbol{x} = \boldsymbol{b},
\]</span></p>
<p>a ordem das linhas de <span class="math inline">\(\boldsymbol{b}\)</span> deve ser alterada de forma consistente com a pivotação, ou seja, <span class="math inline">\(\mathbf{P} \boldsymbol{b}\)</span>. Para ilustrar a implementação computacional da decomposição <span class="math inline">\(\mathbf{LU}\)</span> vamos implementá-la baseada no método de eliminação de Gauss sem pivotação e depois usar as funções nativas do <code>R</code> para exemplificar o uso da matriz de permutação. O Código 2.18 apresenta uma implementação ilustrativa da decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<p><strong>Código 2.18</strong> Decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>my_lu <span class="ot">&lt;-</span> <span class="cf">function</span>(A) {</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  n_row <span class="ot">&lt;-</span> <span class="fu">nrow</span>(A)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  n_col <span class="ot">&lt;-</span> <span class="fu">ncol</span>(A)</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Matriz para receber os resultados</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>  SOL <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, n_row, n_col)</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  SOL[<span class="dv">1</span>,] <span class="ot">&lt;-</span> A[<span class="dv">1</span>,]</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  pivo <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, n_col, n_row)</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">c</span>(n_row<span class="dv">-1</span>)) {</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">c</span>(j<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">c</span>(n_row)) {</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>      pivo[i,j] <span class="ot">&lt;-</span> A[i,j]<span class="sc">/</span>SOL[j,j]</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>      SOL[i,] <span class="ot">&lt;-</span> A[i,] <span class="sc">-</span> pivo[i,j]<span class="sc">*</span>SOL[j,]</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>      A[i,] <span class="ot">&lt;-</span> SOL[i,]</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">diag</span>(pivo) <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="st">"L"</span> <span class="ot">=</span> pivo, <span class="st">"U"</span> <span class="ot">=</span> SOL))</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para ilustrar o uso da decomposição <span class="math inline">\(\mathbf{LU}\)</span> considere a matriz <span class="math inline">\(\mathbf{A}\)</span> do Exemplo 2.3.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>LU <span class="ot">&lt;-</span> <span class="fu">my_lu</span>(A) <span class="co"># Decomposição</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>LU</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$L
           [,1]      [,2]     [,3] [,4]
[1,]  1.0000000 0.0000000 0.000000    0
[2,]  0.2222222 1.0000000 0.000000    0
[3,] -0.3333333 0.1578947 1.000000    0
[4,] -0.2222222 0.3026316 0.279661    1

$U
     [,1]          [,2]      [,3]      [,4]
[1,]    9 -2.000000e+00  3.000000  2.000000
[2,]    0  8.444444e+00 -2.666667  2.555556
[3,]    0  0.000000e+00 12.421053 -3.736842
[4,]    0 -4.440892e-16  0.000000 10.716102</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>LU<span class="sc">$</span>L <span class="sc">%*%</span> LU<span class="sc">$</span>U <span class="co"># Verificando a solução</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]    9   -2    3    2
[2,]    2    8   -2    3
[3,]   -3    2   11   -4
[4,]   -2    3    2   10</code></pre>
</div>
</div>
<p>Para resolver o sistema usamos a matriz decomposta combinada com os procedimentos de substituição progressiva e regressiva, respectivamente. Em <code>R</code> as funções <code>forwardsolve()</code> e <code>backsolve()</code> implementam os procedimentos de substituição progressiva e regressiva, respectivamente. O Código 2.19 ilustra como resolver o sistema baseado na decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<p><strong>Código 2.19</strong> Solução de um sistema linear usando a decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Passo 1: Substituição progressiva</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="fu">forwardsolve</span>(LU<span class="sc">$</span>L, b)</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Passo 2: Substituição regressiva</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">backsolve</span>(LU<span class="sc">$</span>U, y)</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  5.0 -2.0  2.5 -1.0</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>x <span class="co"># Verificando a solução</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1]
[1,]  54.5
[2,] -14.0
[3,]  12.5
[4,] -21.0</code></pre>
</div>
</div>
<p>O Código 2.18 é apenas para ilustrar a obtenção da decomposição <span class="math inline">\(\mathbf{LU}\)</span>. Em problemas reais devemos usar as implementações disponíveis no pacote <code>Matrix</code>. O Código 2.20 ilustra o uso da função <code>lu()</code> do pacote <code>Matrix</code> para obtenção da decomposição <span class="math inline">\(\mathbf{LU}\)</span> neste exemplo com pivotação.</p>
<p><strong>Código 2.20</strong> Decomposição <span class="math inline">\(\mathbf{LU}\)</span> com pivotação usando o pacote <code>Matrix</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(Matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Carregando pacotes exigidos: Matrix</code></pre>
</div>
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>LU_M <span class="ot">&lt;-</span> Matrix<span class="sc">::</span><span class="fu">lu</span>(A) <span class="co"># Calcula mas não retorna</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>LU_M <span class="ot">&lt;-</span> Matrix<span class="sc">::</span><span class="fu">expand</span>(LU_M) <span class="co"># Captura as matrizes L U e P</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Substituição progressiva. </span><span class="al">NOTE</span><span class="co"> MATRIZ DE PERMUTAÇÃO</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">forwardsolve</span>(LU_M<span class="sc">$</span>L, LU_M<span class="sc">$</span>P<span class="sc">%*%</span>b) </span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">backsolve</span>(LU_M<span class="sc">$</span>U, y) <span class="co"># Substituição regressiva</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  5.0 -2.0  2.5 -1.0</code></pre>
</div>
</div>
</section>
<section id="cálculo-da-inversa" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="cálculo-da-inversa"><span class="header-section-number">2.3.4</span> Cálculo da inversa</h3>
<p>A decomposição <span class="math inline">\(\mathbf{LU}\)</span> é especialmente adequada para o cálculo da inversa. Lembre-se que a inversa de <span class="math inline">\(\mathbf{A}\)</span> é tal que</p>
<p><span class="math display">\[
\mathbf{A} \mathbf{A}^{-1} = \mathbf{I}.
\]</span></p>
<p>O procedimento de cálculo da inversa é essencialmente o mesmo da solução de um sistema de equações lineares, porém com mais incógnitas.</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  a_{12}  &amp;  a_{13} \\
a_{21}  &amp;  a_{22}  &amp;  a_{23} \\
a_{31}  &amp;  a_{32}  &amp;  a_{33}
\end{bmatrix}
\begin{bmatrix}
x_{11}  &amp;  x_{12}  &amp;  x_{13} \\
x_{21}  &amp;  x_{22}  &amp;  x_{23} \\
x_{31}  &amp;  x_{32}  &amp;  x_{33}
\end{bmatrix} =
\begin{bmatrix}
1  &amp;  0  &amp;  0\\
0  &amp;  1  &amp;  0\\
0  &amp;  0  &amp;  1
\end{bmatrix}
\]</span></p>
<p>Neste exemplo simples, precisamos resolver três sistemas de equações diferentes. Em cada sistema, uma coluna da matriz <span class="math inline">\(\mathbf{X}\)</span> é a incógnita. A implementação computacional pode ser facilmente feita combinando a função 2.18 com as funções <code>forwardsolve()</code> e <code>backsolve()</code>. O Código 2.21 implementa o cálculo da inversa usando a decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<p><strong>Código 2.21</strong> Cálculo da matriz inversa usando decomposição <span class="math inline">\(\mathbf{LU}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Resolve um sistema de equações</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>solve_lu <span class="ot">&lt;-</span> <span class="cf">function</span>(LU, b) {</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">forwardsolve</span>(LU<span class="sc">$</span>L, b) </span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">backsolve</span>(LU<span class="sc">$</span>U, y)</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Cálculo da inversa</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>my_solve <span class="ot">&lt;-</span> <span class="cf">function</span>(LU, B) {</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>  n_col <span class="ot">&lt;-</span> <span class="fu">ncol</span>(B)</span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>  n_row <span class="ot">&lt;-</span> <span class="fu">nrow</span>(B)</span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>  inv <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, n_col, n_row)</span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_col) {</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    inv[,i] <span class="ot">&lt;-</span> <span class="fu">solve_lu</span>(LU, B[,i])</span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(inv)</span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A implementação foi feita em dois passos. Na primeira função <code>solve_lu()</code> resolve um sistema de equação usual. A função <code>my_solve()</code> usa uma instrução <code>for</code> para varrer todas as colunas da matriz de incógnitas e assim obter a inversa. É importante notar que ambas recebem a decomposição <span class="math inline">\(\mathbf{LU}\)</span> da matriz original.</p>
<p><strong>Example 2.4</strong> Obtenha a inversa de</p>
<p><span class="math display">\[
\mathbf{A} = \begin{bmatrix}
3  &amp;  2  &amp;  6\\
2  &amp;  4  &amp;  3\\
5  &amp;  3  &amp;  4
\end{bmatrix}
\]</span></p>
<p>Para resolver este exemplo, vamos usar as funções que criamos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Entrando com a matriz</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">4</span>),<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Criando a matriz de incógnitas</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>I <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Decomposição LU</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>LU <span class="ot">&lt;-</span> <span class="fu">my_lu</span>(A)</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Obtendo a inversa</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>inv_A <span class="ot">&lt;-</span> <span class="fu">my_solve</span>(<span class="at">LU =</span> LU, <span class="at">B =</span> I)</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>inv_A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>           [,1]        [,2]        [,3]
[1,] -0.1428571 -0.20408163  0.36734694
[2,] -0.1428571  0.36734694 -0.06122449
[3,]  0.2857143 -0.02040816 -0.16326531</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verificando o resultado</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>inv_A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             [,1]         [,2]          [,3]
[1,] 1.000000e+00 0.000000e+00 -1.110223e-16
[2,] 1.110223e-16 1.000000e+00  0.000000e+00
[3,] 0.000000e+00 6.938894e-17  1.000000e+00</code></pre>
</div>
</div>
<p>A função nativa do <code>R</code> recomendada para a solução tanto de sistemas lineares quanto para a obtenção da inversa é a função <code>solve()</code>. A função <code>solve()</code> implementa a decomposição <span class="math inline">\(\mathbf{LU}\)</span> com pivotação. O <code>R</code> usa uma implementação eficiente disponível na biblioteca <code>lapack</code> para mais detalhes veja <a href="http://www.netlib.org/lapack/lug/node38.html">lapack library</a>.</p>
<p>Existem diversas outras estratégias para o cálculo da inversa de uma matriz. Talvez o método mais simples seja usar o método de Gauss-Jordan. Neste método uma matriz aumentada é construída e a inversa é obtida usando operações com linhas. A matriz aumentada toma a seguinte forma:</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{11}  &amp;  a_{21}  &amp;  a_{31}  &amp;  1  &amp;  0  &amp;  0\\
a_{21}  &amp;  a_{22}  &amp;  a_{32}  &amp;  0  &amp;  1  &amp;  0\\
a_{31}  &amp;  a_{32}  &amp;  a_{33}  &amp;  0  &amp;  0  &amp;  1
\end{bmatrix} \to
\begin{bmatrix}
1  &amp;  0  &amp;  0  &amp;  a′_{11}  &amp;  a′_{21}  &amp;  a′_{31} \\
0  &amp;  1  &amp;  0  &amp;  a′_{21}  &amp;  a′_{22}  &amp;  a′_{32} \\
0  &amp;  0  &amp;  1  &amp;  a′_{31}  &amp;  a′_{32}  &amp;  a′_{33}
\end{bmatrix}.
\]</span></p>
<p>O método é bastante simples, porém computacionalmente caro. Para implementações de alto desempenho computacional de tópicos em álgebra linear eu recomendo ao leitor interessado consultar as bibliotecas <a href="https://eigen.tuxfamily.org">eigen</a> e <a href="http://arma.sourceforge.net/">armadillo</a>. Ambas podem ser utilizadas diretamente do <code>R</code> usando os pacotes <a href="https://github.com/RcppCore/RcppEigen">RcppEigen</a> e <a href="https://github.com/RcppCore/RcppArmadillo">RcppArmadillo</a>.</p>
</section>
</section>
<section id="autovalores-e-autovetores" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="autovalores-e-autovetores"><span class="header-section-number">2.4</span> Autovalores e autovetores</h2>
<p>Em ciência de dados é comum lidar com grandes matrizes de dados que apresentam um intrincado sistema de relações ou, em termos estatísticos, correlações. De forma intuitiva pode-se pensar em correlação como sendo uma forma de relacionamento entre duas variáveis de interesse. Por exemplo, o número de quartos em um apartamento pode estar associado com o seu preço. Porém, o número de quartos também pode estar associado com o tamanho total do imóvel, que por sua vez também está associado com o preço do imóvel. Neste exemplo simples com apenas três variáveis podemos notar como é complexo entender a estrutura de correlações em uma base de dados com muitas variáveis de interesse.</p>
<p>Neste tipo de situação é comum fazer uma redução de dimensionalidade. Este tipo de técnica busca reduzir o número de variáveis a serem analisadas facilitando a interpretação. Essa redução baseia-se em criar novas variáveis que são combinações (em particular combinações lineares) das variáveis originais. Talvez a técnica de redução de dimensionalidade mais popular em ciência de dados seja <strong>Análise de Componentes principais</strong> que por sua vez é baseada na decomposição em autovalores e autovetores da matriz de dados. Neste livro, nós vamos discutir apenas os aspectos práticos da obtenção da decomposição em autovalores e autovetores.</p>
<p>Autovalores e autovetores são definidos por uma simples igualdade</p>
<p><span class="math display">\[
\[\begin{equation}
\mathbf{A} \boldsymbol{v} = \boldsymbol{\lambda} \boldsymbol{v}.
\tag{2.12}
\end{equation}
\]</span></p>
<p>Qualquer vetor unitário <span class="math inline">\(\boldsymbol{v}\)</span> que satisfaz a Equação eigen(2.12) tem apenas o efeito de alongar ou encolher <span class="math inline">\(\boldsymbol{v}\)</span>, ou seja, o vetor não é rotacionado e a direção é preservada. Os vetores <span class="math inline">\(\boldsymbol{v}\)</span>’s que satisfazem Equação (2.12) são os autovetores. Enquanto que os valores <span class="math inline">\(\boldsymbol{\lambda}\)</span>’s que satisfazem Equação (2.12) são os autovalores. Neste livro, vamos considerar apenas o caso em que <span class="math inline">\(\mathbf{A}\)</span> é simétrica.</p>
<p>Sendo <span class="math inline">\(\mathbf{A}\)</span> uma matriz simétrica <span class="math inline">\(n \times n\)</span>, então existem exatamente <span class="math inline">\(n\)</span> pares <span class="math inline">\((\lambda_j, \boldsymbol{v}_j)\)</span> que satisfazem a equação</p>
<p><span class="math display">\[
\begin{equation*}
\mathbf{A} \boldsymbol{v} = \boldsymbol{\lambda} \boldsymbol{v}.
\end{equation*}
\]</span></p>
<p>Se <span class="math inline">\(\mathbf{A}\)</span> tem autovalores <span class="math inline">\(\lambda_1, \ldots, \lambda_n\)</span>, então:</p>
<ul>
<li><span class="math inline">\(\mathrm{tr}(\mathbf{A}) = \sum_{i=1}^n \lambda_i\)</span>.</li>
<li><span class="math inline">\(\mathrm{det}(\mathbf{A}) = \prod_{i=1}^n \lambda_i\)</span>.</li>
<li><span class="math inline">\(\mathbf{A}\)</span> é positiva definida, se e somente se todos <span class="math inline">\(\lambda_j &gt; 0\)</span>.</li>
<li><span class="math inline">\(\mathbf{A}\)</span> é semi-positiva definida, se e somente se todos <span class="math inline">\(\lambda_j \geq 0\)</span>.</li>
</ul>
<p>Qualquer matriz simétrica <span class="math inline">\(\mathbf{A}\)</span> pode ser fatorada em</p>
<p><span class="math display">\[
\mathbf{A} = \mathbf{Q} \boldsymbol{\Lambda}  \mathbf{Q}^{\top},
\]</span></p>
<p>onde <span class="math inline">\(\boldsymbol{\Lambda}\)</span> é diagonal contendo os autovalores de <span class="math inline">\(\mathbf{A}\)</span> e as colunas de <span class="math inline">\(\mathbf{Q}\)</span> contêm os autovetores ortonormais (ortogonais de comprimento unitário).</p>
<p>A obtenção da decomposição em autovalores e autovetores de uma matriz não é simples, e em geral é baseada em uma outra decomposição chamada de <strong>decomposição</strong> <span class="math inline">\(\mathbf{QR}\)</span>. Está fora do escopo deste livro descrever tal algoritmo, porém usando o <code>R</code> podemos facilmente obter a decomposição em autovalores e autovetores usando a função <code>eigen()</code>, conforme ilustrado no Código 2.22</p>
<p><strong>Código 2.22</strong> Decomposição em autovalores e autovetores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="fl">0.8</span>, <span class="fl">0.3</span>, <span class="fl">0.8</span>, <span class="dv">1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="dv">1</span>),<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="fu">isSymmetric.matrix</span>(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">eigen</span>(A)</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>Q <span class="ot">&lt;-</span> out<span class="sc">$</span>vectors</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>D <span class="ot">&lt;-</span> <span class="fu">diag</span>(out<span class="sc">$</span>values)</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Autovetores</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>           [,1]       [,2]        [,3]
[1,] -0.6712373 -0.1815663  0.71866142
[2,] -0.6507744 -0.3198152 -0.68862977
[3,] -0.3548708  0.9299204 -0.09651322</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Autovalores</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         [,1]      [,2]      [,3]
[1,] 1.934216 0.0000000 0.0000000
[2,] 0.000000 0.8726419 0.0000000
[3,] 0.000000 0.0000000 0.1931419</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verificando</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>Q<span class="sc">%*%</span>D<span class="sc">%*%</span><span class="fu">t</span>(Q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,]  1.0  0.8  0.3
[2,]  0.8  1.0  0.2
[3,]  0.3  0.2  1.0</code></pre>
</div>
</div>
<p>Uma aspecto interessante dos autovalores é que eles permitem lidar com matrizes da mesma forma que lidamos com números. A ideia é que se você deseja aplicar uma função em uma matriz, como por exemplo o inverso, você pode simplesmente aplicar a função na matriz diagonal <span class="math inline">\(\boldsymbol{\Lambda}\)</span> e fazer a multiplicação por <span class="math inline">\(\mathbf{Q}\)</span> para obter a matriz resultante da aplicação da função. Assim, a decomposição em autovalores e autovetores pode ser usada para obter a inversa de uma matriz. Se <span class="math inline">\(\mathbf{A}\)</span> tem autovetores <span class="math inline">\(\mathbf{Q}\)</span> e autovalores <span class="math inline">\(\lambda_j\)</span>. Então <span class="math inline">\(\mathbf{A}^{-1}\)</span> tem autovetores <span class="math inline">\(\mathbf{Q}\)</span> e autovalores <span class="math inline">\(\lambda_j^{-1}\)</span>. Isso implica que <span class="math inline">\(\mathbf{A}^{-1} = \mathbf{Q} \boldsymbol{\Lambda}^{-1} \mathbf{Q}^{\top}\)</span>. O Código 2.23 ilustra a obtenção da inversa usando a decomposição em autovalores e autovetores.</p>
<p><strong>Código 2.23</strong> Obtenção da inversa usando a decomposição em autovalores e autovetores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">eigen</span>(A)</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>Q <span class="ot">&lt;-</span> out<span class="sc">$</span>vectors</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>inv_D <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">1</span><span class="sc">/</span>out<span class="sc">$</span>values)</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>inv_A <span class="ot">&lt;-</span> Q<span class="sc">%*%</span>inv_D<span class="sc">%*%</span><span class="fu">t</span>(Q)</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Verificando</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>A<span class="sc">%*%</span>inv_A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              [,1]         [,2]          [,3]
[1,]  1.000000e+00 2.567391e-16 -3.330669e-16
[2,]  4.857226e-16 1.000000e+00  3.330669e-16
[3,] -1.776357e-15 1.665335e-15  1.000000e+00</code></pre>
</div>
</div>
</section>
<section id="decomposição-em-valores-singulares" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="decomposição-em-valores-singulares"><span class="header-section-number">2.5</span> Decomposição em valores singulares</h2>
<p>Uma outra decomposição associada a decomposição em autovalores e autovetores é a decomposição em valores singulares. A principal diferença é que a decomposição em valores singulares é definida para qualquer matriz, enquanto que a decomposição em autovalores e autovetores é definida apenas para matrizes simétricas.</p>
<div class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Teorema 2.1</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Qualquer matriz <span class="math inline">\(\mathbf{A}\)</span> pode ser decomposta em,</p>
<p><span class="math display">\[
\mathbf{A} = \mathbf{U} \mathbf{D} \mathbf{V}^{\top},
\]</span></p>
<p>onde <span class="math inline">\(\mathbf{D}\)</span> é diagonal com entradas não negativas e <span class="math inline">\(\mathbf{U}\)</span> e <span class="math inline">\(\mathbf{V}\)</span> são ortogonal, i.e.&nbsp;<span class="math inline">\(\mathbf{U}^{\top} \mathbf{U} = \mathbf{V}^{\top} \mathbf{V} = \mathbf{I}\)</span>.</p>
</div>
</div>
<p>Note que matrizes não quadradas não tem autovalores, porém <span class="math inline">\(\mathbf{D}\)</span> no Teorema 2.1 é obtida para qualquer matriz. Assim, os elementos de <span class="math inline">\(\mathbf{D}\)</span> são chamados de valores singulares e correspondem aos autovalores de <span class="math inline">\(\mathbf{A}^{\top} \mathbf{A}\)</span>. No caso da decomposição em valores singulares é importante estar atento à dimensão das matrizes envolvidas. Assim,</p>
<ul>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times n\)</span>, então <span class="math inline">\(\mathbf{U}, \mathbf{D}\)</span> e <span class="math inline">\(\mathbf{V}\)</span> são <span class="math inline">\(n \times n\)</span>.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times p\)</span>, sendo <span class="math inline">\(n &gt; p\)</span>, então <span class="math inline">\(\mathbf{U}\)</span> é <span class="math inline">\(n \times p\)</span>, <span class="math inline">\(\mathbf{D}\)</span> e <span class="math inline">\(\mathbf{V}\)</span> são <span class="math inline">\(p \times p\)</span>.</li>
<li>Se <span class="math inline">\(\mathbf{A}\)</span> é <span class="math inline">\(n \times p\)</span>, sendo <span class="math inline">\(n &lt; p\)</span>, então <span class="math inline">\(\mathbf{V}^{\top}\)</span> é <span class="math inline">\(n \times p\)</span>, <span class="math inline">\(\mathbf{D}\)</span> e <span class="math inline">\(\mathbf{U}\)</span> são <span class="math inline">\(n \times n\)</span>.</li>
<li><span class="math inline">\(\mathbf{D}\)</span> será sempre quadrada com dimensão igual ao mínimo entre <span class="math inline">\(p\)</span> e <span class="math inline">\(n\)</span>.</li>
</ul>
<p>Em <code>R</code> a obtenção da decomposição em valores singulares está implementada na função <code>svd()</code>, conforme ilustrado no Código 2.24.</p>
<p><strong>Código 2.24</strong> Decomposição em valores singulares.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="fu">svd</span>(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$d
[1] 1.9342162 0.8726419 0.1931419

$u
           [,1]       [,2]        [,3]
[1,] -0.6712373  0.1815663  0.71866142
[2,] -0.6507744  0.3198152 -0.68862977
[3,] -0.3548708 -0.9299204 -0.09651322

$v
           [,1]       [,2]        [,3]
[1,] -0.6712373  0.1815663  0.71866142
[2,] -0.6507744  0.3198152 -0.68862977
[3,] -0.3548708 -0.9299204 -0.09651322</code></pre>
</div>
</div>
</section>
<section id="regressão-ridge" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="regressão-ridge"><span class="header-section-number">2.6</span> Regressão ridge</h2>
<p>Para ilustrar a aplicação da decomposição em valores singulares em ciência de dados vamos considerar o modelo de <strong>regressão ridge</strong>. Relembre que na seção RLM2.2.7 nós escrevemos o modelo de regressão linear múltipla usando matrizes da seguinte forma:</p>
<p><span class="math display">\[
\underset{n\times 1}{\begin{bmatrix}
y_1\\
y_2\\
\vdots \\
y_n
\end{bmatrix}} =
\underset{n\times p}{\begin{bmatrix}
1  &amp;  x_{11}  &amp;  \ldots  &amp;  x_{p1} \\
1  &amp;  x_{12}  &amp;  \ldots  &amp;  x_{p1} \\
\vdots  &amp;  \vdots   &amp;  \ddots  &amp;  \vdots \\
1 &amp;  x_{1n}  &amp;  \ldots  &amp;  x_{pn}
\end{bmatrix} }
\underset{p \times 1}{
\begin{bmatrix}
\beta_0 \\
\vdots \\
\beta_p
\end{bmatrix}
}.
\]</span></p>
<p>Também, usamos a seguinte notação mais compacta,</p>
<p><span class="math display">\[
\underset{n \times 1}{\mathbf{y}} = \underset{n \times p }{\mathbf{X}} \underset{p\times 1}{\boldsymbol{\beta}}.
\]</span></p>
<p>Vimos que o vetor <span class="math inline">\(\boldsymbol{\hat{\beta}}\)</span> que minimiza a perda quadrática é dado por</p>
<p><span class="math display">\[
\boldsymbol{\hat{\beta}} = (\mathbf{X}^{\top}\mathbf{X})^{-1}\mathbf{X}^{\top}\mathbf{y}.
\]</span></p>
<p>Note a importância do termo <span class="math inline">\((\mathbf{X}^{\top}\mathbf{X})^{-1}\)</span> para a obtenção da solução. Vimos também que para calcular a inversa de uma matriz ela precisa ser não-singular. Neste caso sempre que <span class="math inline">\(n &gt; p\)</span> a matriz <span class="math inline">\(\mathbf{X}^{\top}\mathbf{X}\)</span> será não-singular. Porém, existem situações práticas em ciência de dados em que <span class="math inline">\(n &lt; p\)</span>, ou seja, temos mais covariáveis do que observações na base de dados. Este é o tipo de problema comumente chamado de <em>high dimensional data</em>. Neste caso, o sistema gerado será singular, ou seja, tem múltiplas soluções. Porém, ainda gostaríamos de ajustar um modelo similar ao modelo de regressão linear múltipla.</p>
<p>Para superar o problema de <span class="math inline">\(n &lt; p\)</span> é comum introduzir uma penalização pela complexidade na soma de quadrados. A soma de quadrados penalizada é dada por:</p>
<p><span class="math display">\[
PSQ(\boldsymbol{\beta}) = \sum_{i=1}^n (y_i - \boldsymbol{x}_i^{\top} \boldsymbol{\beta})^2 + \lambda \sum_{j = 1}^p \beta_j^2.
\]</span></p>
<p>Matricialmente, tem-se</p>
<p><span class="math display">\[
PSQ(\boldsymbol{\beta}) = (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta})^{\top}(\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta}) + \lambda \boldsymbol{\beta}^{\top} \boldsymbol{\beta}.
\]</span></p>
<p><strong>IMPORTANTE</strong> Na soma de quadrados penalizada <span class="math inline">\(\boldsymbol{y}\)</span> deve estar centrado na média ou o intercepto do modelo não deve ser penalizado. E a matriz <span class="math inline">\(\mathbf{X}\)</span> deve estar padronizada por coluna, o que implica que cada coluna deve ter média zero e variância um.</p>
<p>Nosso objetivo é minimizar a soma de quadrados penalizada e vamos proceder usando a mesma estratégia da Seção 2.2.7. Começamos obtendo a derivada da soma de quadrados penalizada em relação a <span class="math inline">\(\boldsymbol{\beta}\)</span></p>
<p><span class="math display">\[
\begin{eqnarray*}
\frac{\partial PQS(\boldsymbol{\beta})}{\partial \boldsymbol{\beta}}  &amp; = &amp;  \frac{\partial}{\partial \boldsymbol{\beta}}  \left [  (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} )^{\top} (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} ) + \lambda \boldsymbol{\beta}^{\top}\boldsymbol{\beta} \right ] \\
  &amp; = &amp;  \left [ \frac{\partial}{\partial \boldsymbol{\beta}} (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} )^{\top}  \right ] (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} ) +
    (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} )^{\top} \left [ \frac{\partial}{\partial \boldsymbol{\beta}} (\boldsymbol{y} - \mathbf{X} \boldsymbol{\beta} )  \right ] \\  &amp; + &amp;   \lambda \left\{ \left [  \frac{\partial \boldsymbol{\beta}^{\top}}{\partial \boldsymbol{\beta}}\right ]\boldsymbol{\beta} +  \boldsymbol{\beta}^{\top}  \left [  \frac{\partial \boldsymbol{\beta}}{\partial \boldsymbol{\beta}}\right ] \right\}\\
   &amp; = &amp;  -2 \mathbf{X}^{\top} (\boldsymbol{y} - \mathbf{X}\boldsymbol{\beta}) + 2 \lambda \boldsymbol{\beta} \\
   &amp; = &amp;  -\mathbf{X}^{\top} (\boldsymbol{y} - \mathbf{X}\boldsymbol{\beta}) + \lambda \boldsymbol{\beta}.
\end{eqnarray*}
\]</span></p>
<p>Resolvendo o sistema linear, tem-se</p>
<p><span class="math display">\[
\begin{eqnarray*}
-\mathbf{X}^{\top}(\boldsymbol{y} - \mathbf{X}\boldsymbol{\hat{\beta} }) + \lambda \mathbf{I} \boldsymbol{\hat{\beta}}  &amp; = &amp;  \boldsymbol{0} \\
-\mathbf{X}^{\top}\boldsymbol{y} + \mathbf{X}^{\top}\mathbf{X}\boldsymbol{\hat{\beta} } + \lambda \mathbf{I} \boldsymbol{\hat{\beta}}  &amp; = &amp;  \boldsymbol{0} \\
\mathbf{X}^{\top}\mathbf{X}\boldsymbol{\hat{\beta} } + \lambda \mathbf{I} \boldsymbol{\hat{\beta}}  &amp; = &amp;  \mathbf{X}^{\top}\boldsymbol{y} \\
  \left( \mathbf{X}^{\top}\mathbf{X} + \lambda \mathbf{I} \right )\boldsymbol{\hat{\beta} }  &amp; = &amp;  \mathbf{X}^{\top}\boldsymbol{y} \\
  \boldsymbol{\hat{\beta} }  &amp; = &amp;  \left( \mathbf{X}^{\top}\mathbf{X} + \lambda \mathbf{I} \right )^{-1}\mathbf{X}^{\top}\boldsymbol{y}.
\end{eqnarray*}
\]</span></p>
<p>Note que a solução depende de <span class="math inline">\(\lambda\)</span> e que foi a inclusão de <span class="math inline">\(\lambda\)</span> que tornou o sistema não-singular. Pode-se interpretar que quando fixamos o <span class="math inline">\(\lambda\)</span> selecionamos uma solução particular.</p>
<p>Um aspecto que está subjacente é que matrizes que são diagonais dominantes permitem inversa. Note que <span class="math inline">\(\mathbf{X}^{\top} \mathbf{X}\)</span> não é diagonal dominante no caso em que <span class="math inline">\(n &lt; p\)</span>. Porém, se simplesmente somarmos uma certa quantidade positiva na diagonal de <span class="math inline">\(\mathbf{X}^{\top}\mathbf{X}\)</span> ela será diagonal dominante e portanto permitirá inversa. Apesar de parecer uma solução <em>ad hoc</em>, como mostrado, essa solução tem uma forte fundamentação matemática baseada em uma soma de quadrados penalizada.</p>
<p>Calcular <span class="math inline">\(\boldsymbol{\hat{\beta}}\)</span> envolve a inversão de uma matrix <span class="math inline">\(p \times p\)</span> potencialmente grande</p>
<p><span class="math display">\[
\boldsymbol{\hat{\beta}} = \left( \mathbf{X}^{\top}\mathbf{X} + \lambda \mathbf{I} \right )^{-1}\mathbf{X}^{\top}\boldsymbol{y}.
\]</span></p>
<p>Para obter esta inversa podemos usar a decomposição em valores singulares. Lembre-se que a decomposição em valores singulares, fatora a matriz <span class="math inline">\(\mathbf{X}\)</span> da seguinte forma:</p>
<p><span class="math display">\[
\mathbf{X} = \mathbf{U} \mathbf{D} \mathbf{V}^{\top}.
\]</span></p>
<p>Substituindo na Equação para <span class="math inline">\(\boldsymbol{\hat{\beta}}\)</span> é fácil mostrar que</p>
<p><span class="math display">\[
\begin{equation}
\boldsymbol{\hat{\beta}} = \mathbf{V} \mathrm{diag}\left ( \frac{d_j}{d_j^2 + \lambda} \right ) \mathbf{U}^{\top} \boldsymbol{y}.
  \tag{2.13}
\end{equation}
\]</span></p>
<p>Importante notar que o valor de <span class="math inline">\(\lambda\)</span> é desconhecido e que a escolha de um valor ótimo para <span class="math inline">\(\lambda\)</span> não é uma tarefa fácil. É comum em termos práticos usar <strong>validação cruzada</strong>. A ideia básica é separar o conjunto de dados em dois: um chamado de treino e outro de teste. Ajusta-se o modelo no conjunto de treino com o valor de <span class="math inline">\(\lambda\)</span> fixado em algum valor e avalia-se alguma função perda no conjunto de teste. Este processo é repetido para diversos valores de <span class="math inline">\(\lambda\)</span> e escolhe-se aquele <span class="math inline">\(\lambda\)</span> que minimiza a função perda no conjunto de teste. Existem diversas versões do procedimento de validação cruzada. Porém, está fora do escopo deste livro discutir tais aspectos práticos. O que importa é notar que o sistema terá que ser resolvido para muitos valores de <span class="math inline">\(\lambda\)</span>.</p>
<p>A princípio poderíamos usar a decomposição <span class="math inline">\(\mathbf{LU}\)</span> para resolver o sistema <span class="math inline">\((\mathbf{X}^{\top} \mathbf{X} + \lambda \mathbf{I}) \boldsymbol{\beta} = \mathbf{X}^{\top}\boldsymbol{y}\)</span>. Porém, teríamos que para cada valor de <span class="math inline">\(\lambda\)</span> resolver um novo sistema o que tornaria o problema computacionalmente caro e lento. Por outro lado, note que na Equação SVDREG(2.13) o valor de <span class="math inline">\(\lambda\)</span> aparece apenas no termo <span class="math inline">\(\mathrm{diag}\left ( \frac{d_j}{d_j^2 + \lambda} \right )\)</span> e portanto não afeta as matrizes <span class="math inline">\(\mathbf{V}\)</span> e <span class="math inline">\(\mathbf{U}\)</span> que são obtidas apenas uma vez independente do número de valores para <span class="math inline">\(\lambda\)</span>, o que torna o uso da decomposição em valores singulares bastante interessante neste contexto.</p>
<p>Para ilustrar a implementação computacional do modelo de regressão ridge vamos simular um conjunto de dados com <span class="math inline">\(100\)</span> linhas (observações) e <span class="math inline">\(200\)</span> covariáveis. Para simular as covariáveis vamos usar a distribuição Normal com média zero e variância um. Se você não é familiar com a distribuição Normal, pense que é apenas uma forma de gerar dados artificiais. Para tornar o procedimento de simulação reproduzível vamos usar a função <code>set.seed()</code>. Outro aspecto importante é que a primeira coluna da matriz <span class="math inline">\(\mathbf{X}\)</span> deve ser uma coluna de <span class="math inline">\(1\)</span>s e portanto não deve ser centrada.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fixa a semente para a simulação ser reproduzível</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>) </span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">200</span>, <span class="at">nrow =</span> <span class="dv">100</span>)</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>X[,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co"># Intercepto</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">200</span>) {</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>  X[,i] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>)</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>  X[,i] <span class="ot">&lt;-</span> (X[,i] <span class="sc">-</span> <span class="fu">mean</span>(X[,i]))<span class="sc">/</span><span class="fu">var</span>(X[,i])</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O próximo passo para simular o conjunto de dados é fixar o vetor de parâmetros <span class="math inline">\(\boldsymbol{\beta}\)</span>. Como estamos em um exemplo de <em>high dimensional data</em> é comum a suposição que a solução seja esparsa. Isso significa que apenas alguns elementos do vetor <span class="math inline">\(\boldsymbol{\beta}\)</span> são diferentes de zero. Neste exemplo vamos fixar que os primeiros dez elementos de <span class="math inline">\(\boldsymbol{\beta}\)</span> sejam diferentes de zero assumindo valores entre 5 e 10 de forma uniforme.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Gerando o vetor de beta's</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fu">runif</span>(<span class="dv">9</span>, <span class="at">min =</span> <span class="dv">5</span>, <span class="at">max =</span> <span class="dv">10</span>), <span class="fu">rep</span>(<span class="dv">0</span>, <span class="dv">190</span>))</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Média da distribuição Normal</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> X<span class="sc">%*%</span>beta</span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Gerando as observações</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="at">mean =</span> mu, <span class="at">sd =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos agora usar o nosso procedimento para estimar os coeficientes de regressão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>X_svd <span class="ot">&lt;-</span> <span class="fu">svd</span>(X) <span class="co"># Decomposição svd</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">=</span> <span class="fl">0.1</span> <span class="co"># Penalização</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>DD <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="dv">100</span>, X_svd<span class="sc">$</span>d<span class="sc">/</span>(X_svd<span class="sc">$</span>d<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> lambda))</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>DD[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>beta_hat <span class="ot">=</span> <span class="fu">as.numeric</span>(X_svd<span class="sc">$</span>v<span class="sc">%*%</span>DD<span class="sc">%*%</span><span class="fu">t</span>(X_svd<span class="sc">$</span>u)<span class="sc">%*%</span>y)</span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>beta_hat[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] -0.141227  2.877692  4.457781  3.639234  2.051478  3.333452  5.026439
 [8]  3.340764  5.784538  1.860069</code></pre>
</div>
</div>
<p>Para verificar a qualidade do nosso procedimento comparamos os valores simulados com os estimados via regressão ridge.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/ridge-1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: Parâmetros de regressão versus suas estimativas obtidas via regressão ridge.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Os resultados da Figura 2.1 mostram que a regressão ridge teve sucesso em identificar boa parte dos coeficientes diferentes de zero. No entanto, parece que a penalização precisa ser melhor especificada. O leitor pode verificar o efeito de diferentes valores de <span class="math inline">\(\lambda\)</span> e tamanhos de amostra nas estimativas. Desta forma, terminamos a nossa pequena incursão no mundo da Álgebra Matricial.</p>
</section>
<section id="referências-bibliográficas" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="referências-bibliográficas"><span class="header-section-number">2.7</span> 2.7 Referências bibliográficas</h2>
<p>Novamente, como inspiração para estruturar o capítulo foram usados livros básicos de matemática aplicada à economia e administração tais como Dowling (1984) e Leithold (1988). Para as seções de solução de sistemas lineares e decomposições matriciais as principais referências consultadas foram Gilat and Subramaniam (2009) e Rencher and Schaalje (2008).</p>
</section>
<section id="exercícios" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="exercícios"><span class="header-section-number">2.8</span> 2.8 Exercícios</h2>
<p>Os exercícios deste livro são na forma de tutoriais interativos.</p>
<p>Acesse <a href=".\Exercicios.qmd">Exercícios Álgebra Matricial</a>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../content/Modulo01/index.html" class="pagination-link  aria-label=" &lt;span="" diferencial="" e="" integral&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Cálculo Diferencial e Integral</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../content/Modulo03/index.html" class="pagination-link" aria-label="<span class='chapter-number'>3</span>&nbsp; <span class='chapter-title'>Estatística Não Paramétrica 2</span>">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Estatística Não Paramétrica 2</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Estatística 2023-2026</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://raymz1990.github.io/CE313/edit/main/book/content/Modulo02/index.qmd" class="toc-action"><i class="bi bi-git"></i>Edit this page</a></li><li><a href="https://raymz1990.github.io/CE313/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>